import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as $,a as p,b as t,s as r,n as e,t as u}from"../chunks/B1HoO4k0.js";import{T as F}from"../chunks/CcX1cm_-.js";import{P as x}from"../chunks/ClksMsit.js";import{P as h}from"../chunks/B8FEnsbH.js";import{M as o}from"../chunks/e5qaD0UW.js";import"../chunks/i9XClpbl.js";/* empty css                */import{C as j}from"../chunks/DunPP-_K.js";import{H as z}from"../chunks/VyKLllFE.js";var G=$(`Пусть у нас есть какая-то ассоциативная бинарная операция <!> в алгебре <!>.
        Мы хотим научиться быстро считать степень элемента <!> носителя алгебры <!> по этой
        операции, то есть значение`,1),I=$(`В псевдокоде я заменю операцию <!> на умножение, но это просто для удобства написания.
        В формулах я буду использовать оригинальное обозначение, дабы подчеркнуть универсальность.`,1),J=$("<!> <!> <!>",1),K=$("Можно применить свойство ассоциативности для сведения задачи возведения в степень <!> к вдвое меньшей задаче, используя простое свойство",1),L=$("<!> <!> <!>",1),N=$("Давайте посмотрим на двоичное представление <!>",1),Q=$("<!> <!> <!> <!> <!> <!>",1),R=$("Важное замечание: <!> в этом алгоритме &mdash; нейтральный элемент по операции <!>.",1),S=$(`Оценим количество умножений, требуемых алгоритмом (не важно каким, они одинаковые).
        Пусть для возведения числа <!> в степень <!> требуется <!> умножений.
        Тогда, исходя из нашего алгоритма, справедлива формула`,1),U=$("где <!> &mdash; количество единиц в числе <!>",1),V=$("<!> <!> <!> <!> <!>",1),W=$(`Пусть у нас есть фиксированный объект <!>.
    К нам поступает <!> запросов возведения <!> в степень <!> (<!> - номер запроса).`,1),X=$("Только что мы научились решать эту задачу за <!> умножений, что в итоге выливается в временную сложность <!>",1),Y=$("<!> <!>",1),Z=$("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function mr(B){var k=Z(),b=p(k);F(b,{title:"Быстрое возведение в степень"});var y=r(b,2);x(y,{children:(i,P)=>{var _=J(),c=p(_);h(c,{children:(v,f)=>{e();var a=G(),n=r(p(a));o(n,{m:"\\circ"});var s=r(n,2);o(s,{m:"\\AAA"});var d=r(s,2);o(d,{m:"a"});var g=r(d,2);o(g,{m:"\\AAA"}),e(),t(v,a)}});var l=r(c,2);o(l,{display:!0,m:"a^n = \\underbrace{a \\circ a \\circ \\dotsb \\circ a \\circ a}_{n ~\\text{раз}}"});var m=r(l,2);h(m,{children:(v,f)=>{e();var a=I(),n=r(p(a));o(n,{m:"\\circ"}),e(),t(v,a)}}),t(i,_)}});var A=r(y,2);x(A,{children:(i,P)=>{var _=L(),c=p(_);h(c,{children:(v,f)=>{e();var a=K(),n=r(p(a));o(n,{m:"n"}),e(),t(v,a)}});var l=r(c,2);o(l,{display:!0,m:"a^n = \\cases{a^{n/2} \\circ a^n & n~\\text{чётное} \\\\ a \\circ a^{n-1} & n~\\text{нечётное}}"});var m=r(l,2);h(m,{children:(v,f)=>{e();var a=u("Из этого простого свойства можно сразу вывести простой рекурсивный алгоритм");t(v,a)}}),t(i,_)}});var M=r(A,2);j(M,{code:`function fast_pow(a, int n):
    if n % 2 == 0:
        return fast_pow(a, n/2) ** 2
    else:
        return a * fast_pow(a, n-1)`});var w=r(M,2);x(w,{children:(i,P)=>{var _=Q(),c=p(_);h(c,{children:(n,s)=>{e();var d=u("У рекурсии есть оверхед, от которого хотелось бы избавиться.");t(n,d)}});var l=r(c,2);h(l,{children:(n,s)=>{e();var d=N(),g=r(p(d));o(g,{m:"n"}),t(n,d)}});var m=r(l,2);o(m,{display:!0,m:"n = (n_k \\, n_{k-1} \\, \\dotsm \\, n_2 \\, n_1 \\, n_0)_2 = n_k \\cdot 2^k + n_{k-1} \\cdot 2^{k-1} + \\dotsb + n_2 \\cdot 4 + n_1 \\cdot 2 + n_0"});var v=r(m,2);h(v,{children:(n,s)=>{e();var d=u("Тогда нашу степень можно переписать как");t(n,d)}});var f=r(v,2);o(f,{display:!0,m:"n = ((( \\dotsm ((n_k \\cdot 2 + n_{k-1}) \\cdot 2 + n_{k-2}) \\cdot 2 + \\dotsm) \\cdot 2 + n_2) \\cdot 2 + n_1) \\cdot 2 + n_0"});var a=r(f,2);h(a,{children:(n,s)=>{e();var d=u("Ну и здесь сразу видно, как производить вычисления");t(n,d)}}),t(i,_)}});var q=r(w,2);j(q,{code:`function fast_pow(a, int n):
    int result = 1
    while n > 0:
        if n % 2 == 1:
            result *= a
        a *= a
        n /= 2;
    return result`});var C=r(q,2);x(C,{children:(i,P)=>{h(i,{children:(_,c)=>{e();var l=R(),m=r(p(l));o(m,{m:"1"});var v=r(m,2);o(v,{m:"\\circ"}),e(),t(_,l)}})}});var H=r(C,2);x(H,{children:(i,P)=>{var _=V(),c=p(_);h(c,{children:(a,n)=>{e();var s=S(),d=r(p(s));o(d,{m:"a"});var g=r(d,2);o(g,{m:"n"});var E=r(g,2);o(E,{m:"M(n)"}),e(),t(a,s)}});var l=r(c,2);o(l,{display:!0,m:"M(n) = M\\left( \\left\\lfloor \\frac{n}{2} \\right\\rfloor \\right) + 1 + (n \\bmod 2)"});var m=r(l,2);h(m,{children:(a,n)=>{e();var s=u("Решение этого уравнения");t(a,s)}});var v=r(m,2);o(v,{display:!0,m:"M(n) = \\lfloor \\log_2 n \\rfloor + \\nu(n) - 1"});var f=r(v,2);h(f,{children:(a,n)=>{e();var s=U(),d=r(p(s));o(d,{m:"\\nu(n)"});var g=r(d,2);o(g,{m:"n"}),t(a,s)}}),t(i,_)}});var T=r(H,2);z(T,{children:(i,P)=>{e();var _=u("Предподсчёт");t(i,_)}});var O=r(T,2);x(O,{children:(i,P)=>{var _=Y(),c=p(_);h(c,{children:(m,v)=>{e();var f=W(),a=r(p(f));o(a,{m:"a"});var n=r(a,2);o(n,{m:"q"});var s=r(n,2);o(s,{m:"a"});var d=r(s,2);o(d,{m:"m_i"});var g=r(d,2);o(g,{m:"i"}),e(),t(m,f)}});var l=r(c,2);h(l,{children:(m,v)=>{e();var f=X(),a=r(p(f));o(a,{m:"\\sum_{i=1}^q \\bigl( \\lfloor \\log_2 m_i \\rfloor + \\nu(m_i) \\bigr)"});var n=r(a,2);o(n,{m:"O(q \\cdot \\log \\max m) \\cdot \\time(\\text{одно умножение})"}),t(m,f)}}),t(i,_)}});var D=r(O,2);z(D,{children:(i,P)=>{e();var _=u("Аддитивные цепочки и оптимальный алгоритм");t(i,_)}}),t(B,k)}export{mr as component};
