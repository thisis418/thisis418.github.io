import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as l,a as g,b as _,s as r,n as a,t as K}from"../chunks/BWp35gWV.js";import{H as B}from"../chunks/DXKx2xvL.js";import{P as x}from"../chunks/DPzc5wQr.js";import{P as c}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";import{S as F}from"../chunks/LIUKG8Hf.js";/* empty css                *//* empty css                */import"../chunks/i9XClpbl.js";/* empty css                */import{S as G}from"../chunks/CBbFRhrb.js";var I=l("Пусть у нас есть <!> записей, которые мы хотим упорядочить",1),J=l(`Каждая запись <!> имеет ключ <!>, по которому и происходит сортировка.
        Ключи можно сравнивать друг с другом. Более формально, на множестве ключей введено отношение частичного порядка <!>.`,1),L=l("<!> <!> <!>",1),N=l(`Задача сортировки &mdash; найти такую перестановку записей <!>, после применения которой ключи
        расположились этих записей бы в порядке, заданным отношением <!>`,1),O=l(`Сортировка называется <b>устойчивой</b>, если записи с одинаковыми ключами остаются в изначальном
        порядке`,1),Q=l("<!> <!> <!> <!>",1),T=l(`Пока мы говорим только о <b>внутренней сортировке</b>. Число записей достаточно мало, и сами они невелики,
        поэтому весь процесс можно провести в оперативной памяти.`,1),U=l("<!> <!> <!>",1),V=l("Нам нужно отсортировать <!> записей <!> по ключам <!>.",1),W=l(`<!>-й ключ в отсортированной последовательности превышает ровно <!> остальных ключей.
        Давайте сравним попарно все ключи и для каждого ключа посчитаем количество ключей его меньших.`,1),X=l(`Получается, нужно сравнить <!> и <!> при <!> и <!>.
        На самом деле, нам не надо сравнивать ключ с самим собой и после сравнения ключей <!> и <!> сравнивать <!> и <!> не нужно.`,1),Y=l("В итоге сравнивать нам надо <!> и <!> при <!> и <!>. Получаем алгоритм",1),Z=l("<!> <!> <!> <!>",1),rr=l("<!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function pr(C){var R=rr(),b=g(R);B(b,{children:(t,f)=>{a();var e=K("Сортировка");_(t,e)}});var u=r(b,2);x(u,{children:(t,f)=>{var e=L(),$=g(e);c($,{children:(p,s)=>{a();var d=I(),n=r(g(d));o(n,{m:"n"}),a(),_(p,d)}});var m=r($,2);o(m,{display:!0,m:"R_1, R_2, R_3, \\dotsc, R_{n-1}, R_n"});var h=r(m,2);c(h,{children:(p,s)=>{a();var d=J(),n=r(g(d));o(n,{m:"R_i"});var v=r(n,2);o(v,{m:"K_i"});var i=r(v,2);o(i,{m:"\\le"}),a(),_(p,d)}}),_(t,e)}});var S=r(u,2);F(S,{title:"Сортировка",children:(t,f)=>{var e=Q(),$=g(e);c($,{children:(s,d)=>{a();var n=N(),v=r(g(n));o(v,{m:"\\sigma"});var i=r(v,2);o(i,{m:"\\le"}),_(s,n)}});var m=r($,2);o(m,{display:!0,m:"K_{\\sigma(1)} \\le K_{\\sigma(2)} \\le K_{\\sigma(3)} \\le \\dotsb \\le K_{\\sigma(n-1)} \\le K_{\\sigma(n)} "});var h=r(m,2);c(h,{children:(s,d)=>{a();var n=O();a(2),_(s,n)}});var p=r(h,2);o(p,{display:!0,m:"\\sigma(i) < \\sigma(j) \\quad \\text{для любых}~ K_{\\sigma(i)} = K_{\\sigma(j)} ~\\text{и}~ i < j"}),_(t,e)}});var y=r(S,2);x(y,{children:(t,f)=>{var e=U(),$=g(e);c($,{children:(p,s)=>{a();var d=T();a(2),_(p,d)}});var m=r($,2);c(m,{children:(p,s)=>{a();var d=K(`В зависимости от задачи, мы будем или физически переставлять записи в памяти, или составлять дополнительную
        таблицу, представляющую перестановку.
        Если запись имеет несколько полей, то удобно составить таблицу адресных ссылок, указывающих на записи, и
        работать с ней, не перемещая тяжелые записи.
        Если ключи маленькие, а записи большие, можно добавить ключи к адресной таблице и сортировать так.`);_(p,d)}});var h=r(m,2);c(h,{children:(p,s)=>{a();var d=K("Сама сортировка зависит и от структуры данных, в которой хранятся записи, и от типа самих записей.");_(p,d)}}),_(t,e)}});var H=r(y,2);G(H,{children:(t,f)=>{a();var e=K("Адресная сортировка");_(t,e)}});var M=r(H,2);x(M,{children:(t,f)=>{c(t,{children:(e,$)=>{a();var m=K("Вообще, можно отсортировать набор ключей, а после переставить сами записи в нужном порядке.");_(e,m)}})}});var q=r(M,2);B(q,{children:(t,f)=>{a();var e=K("Пример сортировки");_(t,e)}});var k=r(q,2);x(k,{children:(t,f)=>{c(t,{children:(e,$)=>{a();var m=K(`Посмотрим на довольно неэффективный, но показательный алгоритм сортировки.
        На этом примере мы научимся понимать, писать и анализировать алгоритмы сортировки (на самом деле не только
        сортировки).`);_(e,m)}})}});var D=r(k,2);x(D,{children:(t,f)=>{var e=Z(),$=g(e);c($,{children:(s,d)=>{a();var n=V(),v=r(g(n));o(v,{m:"n"});var i=r(v,2);o(i,{m:"R_1, R_2, \\dotsc, R_n"});var P=r(i,2);o(P,{m:"K_1, K_2, \\dotsc, K_n"}),a(),_(s,n)}});var m=r($,2);c(m,{children:(s,d)=>{var n=W(),v=g(n);o(v,{m:"j"});var i=r(v,2);o(i,{m:"j-1"}),a(),_(s,n)}});var h=r(m,2);c(h,{children:(s,d)=>{a();var n=X(),v=r(g(n));o(v,{m:"K_i"});var i=r(v,2);o(i,{m:"K_j"});var P=r(i,2);o(P,{m:"1 \\le i \\le n"});var j=r(P,2);o(j,{m:"1 \\le j \\le n "});var w=r(j,2);o(w,{m:"K_i"});var z=r(w,2);o(z,{m:"K_j"});var A=r(z,2);o(A,{m:"K_j"});var E=r(A,2);o(E,{m:"K_i"}),a(),_(s,n)}});var p=r(h,2);c(p,{children:(s,d)=>{a();var n=Y(),v=r(g(n));o(v,{m:"K_i"});var i=r(v,2);o(i,{m:"K_j"});var P=r(i,2);o(P,{m:"1 \\le i \\le n"});var j=r(P,2);o(j,{m:"1 \\le j \\lt i "}),a(),_(s,n)}}),_(t,e)}}),_(C,R)}export{pr as component};
