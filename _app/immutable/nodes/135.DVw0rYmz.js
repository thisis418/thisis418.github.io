import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as h,a as c,b as _,s as r,n as e,t as P}from"../chunks/BWp35gWV.js";import{T as xr}from"../chunks/CR7k0xtG.js";import{P as g}from"../chunks/DPzc5wQr.js";import{P as m}from"../chunks/B7flgP-x.js";import{M as s}from"../chunks/BqyEoRxA.js";/* empty css                */import{C as x}from"../chunks/BmgYHZay.js";import{C as w}from"../chunks/BvAJckrt.js";import{H as O}from"../chunks/DXKx2xvL.js";import{S as H}from"../chunks/CBbFRhrb.js";import{D as br}from"../chunks/DlTIf4aM.js";/* empty css                */import{T as pr}from"../chunks/y0AHHn4v.js";import{P as cr}from"../chunks/BBkyo9uE.js";/* empty css                *//* empty css                *//* empty css                */var yr=h(`<b>Свободная позиция</b> в двоичном дереве &mdash; место, куда может быть вставлен новый узел.
    То есть, если у какого-то узла нет какого-то ребёнка,
    то место этого несуществующего ребёнка является свободной позицией.`,1),ur=h(`В бинарном дереве, содержащем <!> вершин,
    существует свободная позиция на глубине не более <!>.`,1),wr=h(`Если бы каждая свободная позиция была бы на глубине более <!>,
    то мы получили бы полное совершенное бинарное дерево с более чем <!> элементами.`,1),Or=h("<!> <!>",1),Hr=h(`Пусть <!> (free distance) &mdash; расстояние от узла <!> до ближайшей свободной позиции в поддереве с корнем в <!>.
    У пустых узлов <!>.
    Теперь наше требование можно переформулировать в более приятной форме:`,1),Dr=h("<!> <!> <!> <!>",1),Ar=h(`Узлы такой левосторонней кучи должны хранить указатели на левого и правого ребёнка,
    а так же значение <!>, для того, чтобы не нужно было его пересчитывать каждый раз.`,1),Cr=h("<!> <!>",1),Tr=h(`При вычислении <!> для узла <!> нужно отдельно проверить,
    не является ли этот узел <!>. Для удобства можно завести отдельную функцию,
    которую, кстати, надо инлайнить.`,1),kr=h(`Воспользуемся тем, что куча левосторонняя.
    Правое поддерево &mdash; самое короткое и не длиннее <!>.
    Поэтому пойдём направо и сольем правое поддерево с кучей.`,1),Mr=h(`Мы вызываем слияние рекурсивно, при этом каждый рекурсивный вызов у одной из сливаемых куч уменьшается высота.
    Значит, слияние будет работать за время <!>.`,1),Sr=h("Более точно, слияние двух куч <!> и <!> с размерами <!> и <!> потребует <!> рекурсивных вызовов.",1),qr=h("<!> <!>",1),jr=h(`Пусть дан массив <!> размера <!> с элементами, которые нужно собрать в кучу.
    Создадим из каждого элемента <!> отдельную левостороннюю кучу (один узел с <!>),
    а затем будем объединять их в пары, пока не останется одна куча.`,1),zr=h(`На каждом уровне итерации объединений количество куч уменьшается вдвое, а общее число операций <!> &mdash; <!>. Каждая операция <!> в худшем случае занимает <!>,
    но так как размеры куч в начале малы, общая сложность построения &mdash; <!>.`,1),Br=h(`Скошенная куча (skew heap) &mdash; это разновидность левосторонней кучи, в которой отсутствует необходимость хранить и
    поддерживать значение <!> для каждого узла.
    Вместо этого скошенная куча на каждом шаге операции слияния она <b>обязательно меняет местами левого и правого
    потомков</b> у текущего узла.
    Это позволяет обойтись без хранения вспомогательных данных, при этом сохраняя амортизированную эффективность.`,1),Er=h(`Операция <!> &mdash; основная для скошенной кучи. В отличие от левосторонней кучи, где на каждом шаге
    проверяется и поддерживается свойство <!>, в скошенной куче мы просто меняем местами
    левого и правого потомков после рекурсивного слияния.`,1),Fr=h(`Помимо <!>, все операции реализуются идентично левосторонней куче, то есть
    построение/вставка/удаление отличаются, только приниципом работы функции <!>.`,1),Gr=h(`Как мы поняли в отличие от левосторонней кучи, в скошенной куче не проверяется
    соотношение между левым и правым поддеревом.
    Вместо этого, после рекурсивного вызова <!>, мы <b>всегда</b> меняем местами левого и правого потомков у <!>.
    Из этого следует явное замечание о том, что в худшем случаем <!> имеет
    сложность <!> операций, но вся ассимптотическая прелесть скошенной кучи раскрывается при большом
    количестве операций <!>, что бы удостовериться в этом проведем амортизационный анализ.`,1),Ir=h("Для того что бы найти примерную сложность операции <!> воспользуемся потенциальным методом анализа.",1),Jr=h(`Пусть <!> &mdash; скошенная куча. Определим её <b>потенциал</b> <!> как количество
    правых детей в дереве, то есть число узлов, которые являются правыми потомками своих родителей.`,1),Kr=h(`Интуитивно заметно, что потенциал измеряет «несбалансированность» кучи,
    то есть  чем больше правых потомков, тем выше потенциал.
    При каждом вызове <!> мы меняем местами левого и правого потомков у корня,
    что может уменьшить потенциал, компенсируя стоимость будущих операций.`,1),Lr=h("Амортизированная стоимость операции <!> для двух скошенных куч с суммарным размером <!> составляет <!>.",1),Nr=h(`Пусть операция <!> выполняет <!> рекурсивных вызовов.
    В худшем случае <!>, но рассмотрим амортизированную стоимость <!>,
    где <!> &mdash; реальная стоимость (число рекурсивных вызовов),
    а <!> &mdash; изменение потенциала.`,1),Qr=h(`То есть, при каждом рекурсивном вызове мы поднимаем одно из сливаемых деревьев по правому пути,
    но после операции <!> все узлы на этом пути становятся левыми потомками, что <b>уменьшает потенциал</b>.
    Выражаясь формально <!> .`,1),Rr=h("<!> <!> <!> <!>",1),Ur=h(`Таким образом, хотя отдельные вызовы могут быть дорогими, путем постоянного хаотичного пермешивания кучи
    мы смогли добиться сложности <!>,
    при этом сохранив память не сохраняя <!> в каждом узле.`,1),Vr=h("<!> <!>",1),Wr=h("<b>1.</b> Почему в скошенной куче нельзя заменить <!> на <!> в коде слияния? Что изменится?",1),Xr=h("<b>2.</b> Пусть в левосторонней куче узел <!> имеет <!> . Какое минимальное количество узлов должно быть в поддереве с корнем <!>?",1),Yr=h("<b>3.</b> Реализуйте скошенную кучу и функции для нее.",1),Zr=h("<b>4.</b> Реализуйте правостороннюю кучу и функции для нее.",1),ro=h("<!> <!> <!> <!>",1),oo=h("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function yo(gr){var D=oo(),A=c(D);xr(A,{title:"Скошенные и левосторонние кучи"});var C=r(A,2);O(C,{children:(n,p)=>{e();var o=P("Левосторонняя куча");_(n,o)}});var T=r(C,2);g(T,{children:(n,p)=>{m(n,{children:(o,l)=>{var t=yr();e(),_(o,t)}})}});var k=r(T,2);pr(k,{title:"Теорема о минимальной свободной позиции",children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=ur(),a=r(c(t));s(a,{m:"n"});var v=r(a,2);s(v,{m:"\\lfloor \\log_2 (n+1) \\rfloor"}),e(),_(o,t)}})}});var M=r(k,2);cr(M,{children:(n,p)=>{var o=Or(),l=c(o);m(l,{children:(a,v)=>{e();var d=wr(),$=r(c(d));s($,{m:"\\log_2 n"});var i=r($,2);s(i,{m:"n"}),e(),_(a,d)}});var t=r(l,2);m(t,{children:(a,v)=>{e();var d=P(`Для получения точной оценки достаточно рассмотреть полное бинарное дерево,
    в котором все свободные позиции находятся наиболее низко.`);_(a,d)}}),_(n,o)}});var S=r(M,2);g(S,{children:(n,p)=>{var o=Dr(),l=c(o);m(l,{children:(d,$)=>{e();var i=P(`Давайте используем этот факт и сконструируем левостороннее дерево.
    Нам нужно потребовать выполнение следующего условия:
    ближайшая к корню свободная позиция должна быть самой правой позицией в дереве.
    Давайте формализуем и переформулируем в полее приятном виде.`);_(d,i)}});var t=r(l,2);m(t,{children:(d,$)=>{e();var i=Hr(),b=r(c(i));s(b,{m:"\\dist v"});var f=r(b,2);s(f,{m:"v"});var y=r(f,2);s(y,{m:"v"});var u=r(y,2);s(u,{m:"\\dist (\\code{\\htmlClass{boolean}{none}}) = 0"}),e(),_(d,i)}});var a=r(t,2);s(a,{display:!0,m:"\\dist ( v.\\code{left} ) \\ge \\dist (v.\\code{right}) \\quad\\text{для всех узлов}~ v"});var v=r(a,2);m(v,{children:(d,$)=>{e();var i=P(`Если вдруг, для какого-то узла это свойство не выполняется,
    то можно поменять местами указатели на правого и левого детей местами.
    После этого свойство левостороннего дерева для этой вершины будет выполняться.`);_(d,i)}}),_(n,o)}});var q=r(S,2);g(q,{children:(n,p)=>{var o=Cr(),l=c(o);m(l,{children:(a,v)=>{e();var d=P(`Возьмём левостороннее дерево и потребуем еще дополнительно, чтобы для него выполнялось свойство кучи:
    приоритет любого узла больше приоритета его детей.
    Мы превратили левостороннее дерево в левостороннюю кучу.`);_(a,d)}});var t=r(l,2);m(t,{children:(a,v)=>{e();var d=Ar(),$=r(c(d));s($,{m:"\\dist(v)"}),e(),_(a,d)}}),_(n,o)}});var j=r(q,2);w(j,{code:`
struct node:
    node* left
    node* right
    int dist
    int priority
`});var z=r(j,2);g(z,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Tr(),a=r(c(t));s(a,{m:"\\dist(v)"});var v=r(a,2);s(v,{m:"v"});var d=r(v,2);x(d,{c:"none"}),e(),_(o,t)}})}});var B=r(z,2);w(B,{code:`
function get_dist(node x):
    if x is none:
        return 0
    else:
        return x.dist
`});var E=r(B,2);H(E,{children:(n,p)=>{e();var o=P("Слияние левосторонних куч");_(n,o)}});var F=r(E,2);g(F,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=kr(),a=r(c(t));s(a,{m:"\\log n"}),e(),_(o,t)}})}});var G=r(F,2);w(G,{code:`
function merge(node* x, node* y):  # x и y являются корнями сливаемых куч
    if x is none:
        return y

    if y is none:
        return x

   if y.priority > x.priority:
       swap x, y

   x.right = merge(x.right, y)

   if get_dist(x.right) > get_dist(x.left):
       swap x.left, x.right

   x.dist = get_dist(x.right) + 1

   return x
`});var I=r(G,2);g(I,{children:(n,p)=>{var o=qr(),l=c(o);m(l,{children:(a,v)=>{e();var d=Mr(),$=r(c(d));s($,{m:"O(\\log n)"}),e(),_(a,d)}});var t=r(l,2);m(t,{children:(a,v)=>{e();var d=Sr(),$=r(c(d));s($,{m:"H_1"});var i=r($,2);s(i,{m:"H_2"});var b=r(i,2);s(b,{m:"n_1"});var f=r(b,2);s(f,{m:"n_2"});var y=r(f,2);s(y,{m:"\\dist H_1 + \\dist H_2 = \\lfloor \\log_2 (n_1 + 1) \\rfloor + \\lfloor \\log_2 (n_2 + 1) \\rfloor"}),e(),_(a,d)}}),_(n,o)}});var J=r(I,2);H(J,{children:(n,p)=>{e();var o=P("Построение левосторонней кучи");_(n,o)}});var K=r(J,2);g(K,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=jr(),a=r(c(t));s(a,{m:"A"});var v=r(a,2);s(v,{m:"n"});var d=r(v,2);s(d,{m:"A[i]"});var $=r(d,2);s($,{m:"\\dist = 1"}),e(),_(o,t)}})}});var L=r(K,2);w(L,{code:`
function build_leftist_heap(A: array[int]):
    n = A.length
    if n == 0:
        return none

    heaps = [new_node(A[i]) for i in 0 .. n-1] # Создаём массив куч по одной куче на элемент

    while heaps.length > 1:
        next_heaps = []
        for i in range(0, heaps.length, 2):
            left_heap = heaps[i]
            if i + 1 < heaps.length:
                right_heap = heaps[i + 1]
            else:
                right_heap = none
            merged = merge(left_heap, right_heap)
            next_heaps.append(merged)
        heaps = next_heaps

return heaps[0]
`});var N=r(L,2);g(N,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=zr(),a=r(c(t));x(a,{c:"merge"});var v=r(a,2);s(v,{m:"n/2 + n/4 + n/8 + \\dotsb = O(n)"});var d=r(v,2);x(d,{c:"merge"});var $=r(d,2);s($,{m:"O(\\log n)"});var i=r($,2);s(i,{m:"O(n \\log n)"}),e(),_(o,t)}})}});var Q=r(N,2);H(Q,{children:(n,p)=>{e();var o=P("Вставка");_(n,o)}});var R=r(Q,2);g(R,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=P(`Вставка нового элемента в кучу очень просто реализуется слиянием.
    Создаём новую левостороннюю кучу, состоящую только из одного элемента — вставляемого.
    Далее сливаем нашу новую кучу с исходной кучей, в которую вставляем элемент.`);_(o,t)}})}});var U=r(R,2);H(U,{children:(n,p)=>{e();var o=P("Извлечение минимума");_(n,o)}});var V=r(U,2);g(V,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=P(`Минимум находится в корне, поэтому для извлечения минимума
    достаточно просто удалить корень и слить его правое и левое поддеревья.`);_(o,t)}})}});var W=r(V,2);O(W,{children:(n,p)=>{e();var o=P("Скошенная куча");_(n,o)}});var X=r(W,2);g(X,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Br(),a=r(c(t));s(a,{m:"\\dist(v)"}),e(3),_(o,t)}})}});var Y=r(X,2);g(Y,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=P("Узел скошенной кучи содержит только указатели на левого и правого потомков и значение приоритета.");_(o,t)}})}});var Z=r(Y,2);w(Z,{code:`struct node:
    node* left
    node* right
    int priority
`});var rr=r(Z,2);g(rr,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Er(),a=r(c(t));x(a,{c:"merge"});var v=r(a,2);s(v,{m:"\\dist"}),e(),_(o,t)}})}});var or=r(rr,2);w(or,{code:`
function merge(node* x, node* y):
    if x is none:
        return y

    if y is none:
        return x

    if y.priority < x.priority:
        swap x, y

    x.left = merge(x.left, y)
    swap x.left, x.right

    return x
`});var er=r(or,2);g(er,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Fr(),a=r(c(t));x(a,{c:"merge"});var v=r(a,2);x(v,{c:"merge"}),e(),_(o,t)}})}});var nr=r(er,2);g(nr,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Gr(),a=r(c(t));x(a,{c:"merge(x.left, y)"});var v=r(a,4);x(v,{c:"x"});var d=r(v,2);x(d,{c:"merge"});var $=r(d,2);s($,{m:"O(n)"});var i=r($,2);x(i,{c:"merge"}),e(),_(o,t)}})}});var tr=r(nr,2);O(tr,{children:(n,p)=>{e();var o=P("Амортизационный анализ скошенной кучи");_(n,o)}});var ar=r(tr,2);g(ar,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Ir(),a=r(c(t));x(a,{c:"merge"}),e(),_(o,t)}})}});var dr=r(ar,2);br(dr,{title:"Потенциал скошенной кучи",children:(n,p)=>{g(n,{children:(o,l)=>{m(o,{children:(t,a)=>{e();var v=Jr(),d=r(c(v));s(d,{m:"H"});var $=r(d,4);s($,{m:"\\Phi(H)"}),e(),_(t,v)}})}})}});var _r=r(dr,2);g(_r,{children:(n,p)=>{m(n,{children:(o,l)=>{e();var t=Kr(),a=r(c(t));x(a,{c:"merge"}),e(),_(o,t)}})}});var sr=r(_r,2);pr(sr,{title:"Амортизированная сложность слияния",children:(n,p)=>{g(n,{children:(o,l)=>{m(o,{children:(t,a)=>{e();var v=Lr(),d=r(c(v));x(d,{c:"merge"});var $=r(d,2);s($,{m:"n"});var i=r($,2);s(i,{m:"O(\\log n)"}),e(),_(t,v)}})}})}});var vr=r(sr,2);cr(vr,{children:(n,p)=>{g(n,{children:(o,l)=>{var t=Rr(),a=c(t);m(a,{children:(i,b)=>{e();var f=Nr(),y=r(c(f));x(y,{c:"merge"});var u=r(y,2);s(u,{m:"t"});var mr=r(u,2);s(mr,{m:"t = O(n)"});var $r=r(mr,2);s($r,{m:"\\hat{c} = t + \\Delta\\Phi"});var hr=r($r,2);s(hr,{m:"t"});var Pr=r(hr,2);s(Pr,{m:"\\Delta\\Phi = \\Phi_{\\text{после}} - \\Phi_{\\text{до}}"}),e(),_(i,f)}});var v=r(a,2);m(v,{children:(i,b)=>{e();var f=Qr(),y=r(c(f));x(y,{c:"merge"});var u=r(y,4);s(u,{m:"\\Delta\\Phi \\le -t + 2 \\log n"}),e(),_(i,f)}});var d=r(v,2);m(d,{children:(i,b)=>{e();var f=P("Подставим в формулу амортизирвоанной сложности и получим:");_(i,f)}});var $=r(d,2);s($,{display:!0,m:"\\hat{c} = t + \\Delta\\Phi \\le t + (-t + 2 \\log n) = 2 \\log n = O(\\log n)."}),_(o,t)}})}});var lr=r(vr,2);g(lr,{children:(n,p)=>{var o=Vr(),l=c(o);m(l,{children:(a,v)=>{e();var d=Ur(),$=r(c(d));s($,{m:"O(\\log n)"});var i=r($,2);s(i,{m:"\\dist(v)"}),e(),_(a,d)}});var t=r(l,2);m(t,{children:(a,v)=>{e();var d=P(`Отсюда следует нехитрый вывод: если нам критически важно поведение структуры данных в worst-case ситуации,
    то стоит прибегать к реализации левосторонней кучи, а если количество операций с кучей
    большое и нам важно сохранить память, то скошенная куча будет эффективнее.`);_(a,d)}}),_(n,o)}});var ir=r(lr,2);O(ir,{children:(n,p)=>{e();var o=P("Задачи");_(n,o)}});var fr=r(ir,2);g(fr,{children:(n,p)=>{var o=ro(),l=c(o);m(l,{children:(d,$)=>{var i=Wr(),b=r(c(i),2);x(b,{c:"swap x.left, x.right"});var f=r(b,2);x(f,{c:"swap x.right, x.left"}),e(),_(d,i)}});var t=r(l,2);m(t,{children:(d,$)=>{var i=Xr(),b=r(c(i),2);s(b,{m:"v"});var f=r(b,2);s(f,{m:"\\dist(v) = k"});var y=r(f,2);s(y,{m:"v"}),e(),_(d,i)}});var a=r(t,2);m(a,{children:(d,$)=>{var i=Yr();e(),_(d,i)}});var v=r(a,2);m(v,{children:(d,$)=>{var i=Zr();e(),_(d,i)}}),_(n,o)}}),_(gr,D)}export{yo as component};
