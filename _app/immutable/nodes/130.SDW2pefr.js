import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as d,a as v,b as a,s as r,n as o,t as q,c as z,r as D}from"../chunks/BWp35gWV.js";import{T as Xr}from"../chunks/CR7k0xtG.js";import{P as A}from"../chunks/DPzc5wQr.js";import{P as _}from"../chunks/B7flgP-x.js";import{M as n}from"../chunks/BqyEoRxA.js";import{S as M}from"../chunks/CBbFRhrb.js";/* empty css                *//* empty css                *//* empty css                *//* empty css                */import{C as T}from"../chunks/BmgYHZay.js";import{H as N}from"../chunks/DXKx2xvL.js";import{T as Jr}from"../chunks/y0AHHn4v.js";import{P as Yr}from"../chunks/BBkyo9uE.js";import{L as Zr}from"../chunks/DDpIWRRY.js";import{C as L}from"../chunks/BvAJckrt.js";import{S as rn}from"../chunks/LIUKG8Hf.js";var nn=d(`Рассмотрим методы сортировок, основными операциями в которых является обмен элементов.
    Да, эта та самая операция <!>.`,1),on=d(`К нам на вход поступает массив из записей <!>,
    у каждой записи <!> есть ключ <!>.
    На ключах задано отношение тотального порядка <!>.`,1),an=d(`Нужно расположить записи по возрастанию ключей,
    то есть надо найти такую перестановку <!>, что`,1),_n=d(`Нам нужно переупорядочить записи в том же пространстве памяти
    в соответствии с этой перестановкой <!>,
    при этом нам разрешено использовать только операцию <!>, которая меняет местами два объекта в памяти.`,1),en=d(`Также можно использовать любые операции, сводящиеся к <!>,
    но в итоговом анализе сложности нас будет интересовать именно количество операций <!>.`,1),tn=d("<!> <!> <!> <!> <!>",1),dn=d(`Наверное, самый очевидный метод сортировки &mdash; сравнивать ключи <!> и <!>,
    и, если <!>, поменять местами записи <!> и <!>.
    Такой операцией мы последовательно устраняем инверсии в перестановке.
    Значит в какой-то момент мы дойдем до перестановки без инверсий. Это и будет наш отсортированный массив.`,1),vn=d(`Пусть <!> &mdash; перестановка элементов <!>,
    и <!> &mdash; соответствующая ей таблица инверсий.`,1),sn=d(`После очередного прохода при сортировке пузырьком перестановка <!> преобразуется в перестановку <!>.
    Таблица инверсий получившейся перестановки <!>.
    Новая таблица инверсий получается из старой путём уменьшения каждого ненулевого элемента на <!>.`,1),mn=d("<!> <!>",1),ln=d(`Если перед <!> имеется больший элемент,
    то <!> поменяется местами с наибольшим из предшествующих элементов.
    Получается, что <!> уменьшится на <!>.
    А если перед <!> нет большего элемента, то <!> никогда ни с кем не
    поменяется,
    и <!> так и останется равным <!>.`,1),cn=d(`Если <!> &mdash; таблица инверсий
    исходной перестановки <!>, то`,1),pn=d("где <!> &mdash; значение <!> перед началом <!>-го прохода.",1),$n=d("После <!> проходов сортировки значение переменной <!> будет равно",1),fn=d("<!> <!> <!> <!> <!> <!> <!> <!> <!>",1),gn=d("<b>Анализ распределения <!> &mdash; количества обменов</b>"),hn=d(`Значение <!> равно числу инверсий
    в перестановке <!>.
    Распределение числа инверсий мы знаем, его параметры`,1),un=d("<!> <!> <!>",1),kn=d("<b>Анализ распределения <!> &mdash; количества проходов</b>"),xn=d("Вероятность того, что нам потребуется не более <!> проходов, равна произведению <!> и числа таблиц инверсий, не содержащих компонент равных <!> или больше.",1),Pn=d("Значит вероятность того, что нам потребуется ровно <!> проходов равна",1),bn=d(`Величина <!> подробно анализировалась в <!>.
    Нам достаточно асимптотического поведения <!>.`,1),jn=d("Подставляем асимптотическое выражение для <!> и получаем",1),qn=d("Получаем результат анализа распределения <!> &mdash; количества проходов при сортировке пузырьком",1),yn=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),Cn=d("<b>Анализ распределения <!> &mdash; количества сравнений.</b>"),En=d(`Итак, нам нужно проанализировать величину <!>,
    где <!>.
    Пусть <!> &mdash; число таких таблиц инверсий <!>,
    для которых при <!> либо <!>, либо <!>.`,1),Hn=d(`Тогда вероятность того, что количество сравнений <!> будет
    не больше <!> выражается через <!>`,1),wn=d("Значит вероятность того, что количество сравнений <!> будет в точности <!> равна",1),An=d("Для вычисления среднего числа сравнений на шаге <!> посчитаем математическое ожидание",1),Sn=d("Тогда, суммируя по <!>, получаем математическое ожидание общего числа сравнений",1),Gn=d("Теперь можно посчитать дисперсию. Начнем с <!>",1),Rn=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),Vn=d(`Сортировка пузырьком, конечно, рабочая, но она относительно медленная.
    В процессе сортировки пузырьком совершается довольно много лишних сравнений,
    и элемент не может за один проход переместиться более чем на <!> позицию,
    поэтому если наименьший элемент будет самым крайним, то нам потребуется максимальное количество сравнений.`,1),Kn=d(`Все эти особенности процесса сортировки пузырьком наталкивают на мысли о сортировке,
    которая будет чередовать направления прохода по массиву.
    Кеннет Айверсон в 1962 году сделал интересное наблюдение:
    если две записи <!> и <!> не поменялись местами
    при двух последовательных проходах в обоих направлениях,
    то они уже стоят на своих местах и их можно исключить из дальнейшего рассмотрения.`,1),On=d("<!> <!>",1),Tn=d(`Пусть снова <!> &mdash; таблица инверсий
    исходной перестановки <!>.
    Считаем величины <!> &mdash; количество проходов, <!> &mdash; количество обменов и <!> &mdash; количество сравнений.`,1),Bn=d("где <!> &mdash; значение <!> перед началом <!>-го прохода.",1),Ln=d("<!> <!> <!>",1),Mn=d("<!> <!>",1),Nn=d("Алгоритм будет работать для <!>.",1),zn=d(`Вычислим <!> &mdash;
    наименьшее такое целое число, для которого <!>.`,1),Dn=d("<!> <!>",1),Fn=d("<!> <!>",1),In=d(`Давайте брать одну из записей и сразу двигать её на то место, которое она должна занять после сортировки.
    Для поиска номера <!>, под которым должна оказаться выбранная запись <!>,
    нам нужно распределить остальные записи так,
    чтобы слева от записи <!> оказались только записи с меньшим ключом,
    а справа от записи <!> оказались только записи с большим ключом.`,1),Jn=d(`После этой операции у нас получатся два подмассива <!> и <!>.
    При этом, если <!> &mdash; ключ записи <!>,
    и <!> &mdash; ключ записи <!>, то`,1),Qn=d("Метод, рассмотренный нами, называется <b>быстрая сортировка</b>, а точнее общая быстрая сортировка.",1),Un=d(`Понятно, что эффективность алгоритма зависит от стратегии выбора записи <!>,
    по которой будем разделять массив.
    Эта запись называется <b>опорным элементом</b> разделения.
    Используя разные алгоритмы выбора опорного элемента мы будем получать разные варианты быстрой сортировки,
    такие как рандомизированная быстрая сортировка, быстрая сортировка Седгевика и быстрая сортировка Хоара.
    Операцию выбора этого элемента назовём <!> и рассмотрим потом отдельно.`,1),Wn=d(`Также эффективность алгоритма зависит от способа разбиения подмассива на две части относительно опорного элемента.
    Как бы операция выбора опорного элемента является частью операции разбиения,
    но для удобства повествования и анализа я разделю эти две операции.
    Операция разделения <!> принимает на вход ссылку на исходный массив, границы подмассива для разделения и индекс элемента,
    который считается опорным. Возвращает индекс, на который переместился опорный элемент.
    При этом записи в подмассиве эта операция перекомпонует так, что
    по индексам от <!> до нового индекса опорного элемента располагаются только записи,
    у которых ключи меньше опорного,
    а по индексам от нового индекса опорного элемента до <!> располагаются только записи,
    у которых ключи больше опорного.`,1),Xn=d("<!> <!> <!> <!> <!> <!> <!> <!>",1),Yn=d(`Если нам не повезет, и по нашей стратегии мы будем выбирать опорный элемент так,
    что одна часть будет состоять только из одной записи,
    а другая часть из всех оставшихся, то время работы нашего алгоритма составит <!>.
    А если нам повезет, и массив разделится ровно пополам,
    то время работы нашего алгоритма составит <!>.
    Получается, что для получения хорошего алгоритма быстрой сортировки нам нужно удачно выбирать опорный элемент.`,1),Zn=d("<!> <!>",1),ro=d(`Пусть также <!> &mdash; вероятность того, что опорный элемент разбивает
    исходный массив на подмассивы длины <!> и <!>.`,1),no=d(`Будем использовать наше стандартное обозначение <!> для количества сравнений.
    Понятно, что это величина случайная. Мы предполагаем равномерное распределение всех входных перестановок.`,1),oo=d(`Пусть <!> &mdash;
    производящая функция вероятностей числа сравнений <!> в быстрой сортировке массива из <!> элементов.`,1),ao=d(`Введём величину <!> &mdash; число сравнений при разбиении при условии,
    что опорный элемент занимает позицию <!>.
    Пусть её производящая функция равна <!> Тогда`,1),_o=d("<!> <!> <!> <!> <!>",1),eo=d(`Теперь получим формулы для <!> &mdash; количество обменов.
    Это тоже случайная величина.`,1),to=d(`Пусть <!> &mdash;
    производящая функция вероятностей числа обменов <!> в быстрой сортировке массива из <!> элементов.
    Здесь опять <!> &mdash; вероятность того, что опорный элемент разбивает
    исходный массив на подмассивы длины <!> и <!>.`,1),vo=d(`Введём также величину <!> &mdash; число обменов при разбиении при условии,
    что опорный элемент занимает позицию <!>.
    Пусть её производящая функция равна <!> Тогда`,1),so=d("<!> <!> <!> <!> <!>",1),io=d("<!> <!>",1),mo=d(`Для фиксированного выбора опорного элемента <!> для всех <!> от <!> до <!>.
    Также при разбиении мы делаем фиксированное число сравнений &mdash; <!>,
    поэтому <!> Подставляем в формулу <!>:`,1),lo=d(`Найти в замкнутом виде выражение для <!> не получится, но это нам и не нужно.
    Нам нужно просто посчитать, чему равны первая и вторая производная в точке <!>,
    чтобы посчитать математическое ожидание и дисперсию числа сравнений`,1),co=d(`Подставляем <!>, и, обозначив <!>,
    получаем рекуррентное соотношение для <!>:`,1),po=d(`Теперь обозначим <!>, и, посчитав вторую производную,
    получим рекуррентное соотношение для <!>:`,1),$o=d(`Максимальное число сравнений достигается тогда, когда опорный элемент оказывается самым минимальным.
    Для максимального числа сравнений <!> получаем рекурренту <!> с <!>,
    решением которой является <!>.`,1),fo=d(`Минимальное число сравнений достигается тогда, когда опорный элемент постоянно является медианой,
    и обрабатываемый массив делится ровно пополам.
    Понятно, что совсем ровное деление мы получить на произвольном массиве не сможем,
    потому что размер массива может быть любой. Оценим пока тут немного грубовато.
    Для минимального числа сравнений <!> получаем рекурренту <!> с <!>, грубым решением которой является <!>.`,1),go=d("Получаем все важные характеристики количества сравнений <!>:",1),ho=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),uo=d(`Для фиксированного выбора опорного элемента <!>, и <!>.
    Обратите внимание: я учитываю только обмены, которые происходят в цикле в операции разбиения
    и не учитываю служебные обмены, которые связаны с размещением опорного элемента,
    потому что количество служебных обменов зависит от реализации.
    Важно только то, что эти служебные обмены добавляют не более константы к числу обменов на каждом уровне разбиения,
    что приводит к линейной поправке в итоговой оценке количества обменов.
    Тогда наша рекуррента превращается в`,1),ko=d(`И снова, найти в замкнутом виде выражение для <!> не получится.
    А нам и не надо. Нам надо только вычислить значения <!> и <!>.`,1),xo=d(`Начнём с первого момента, <!>. Считаем производную <!>,
    подставляем <!> и получаем рекурренту`,1),Po=d("Далее, считаем вторую производную <!>, подставляем <!> и получаем рекурренту для <!>:",1),bo=d(`Максимальное число обменов достигается на полностью отсортированном массиве,
    где на каждом шаге опорный строго больше всех остальных элементов.
    Тогда <!>.`,1),jo=d(`Минимальное число обменов достигается на отсортированном массиве, ведь мы буквально никого ни с кем не обмениваем.
    Тогда <!>.`,1),qo=d("Получаем все важные характеристики количества сравнений <!>:",1),yo=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),Co=d(`Как мы поняли, метод неплохой, работает за ожидаемое время <!>,
    а точнее выполняет в среднем <!> сравнений и <!> обменов.
    У этого метода есть одна большая проблема: он уязвим к умышленным атакам.
    Алгоритм детерминированный, так что можно подобрать такой входной массив,
    что каждый раз будет в качестве опорного элемента выбираться наименьший или наибольший.
    И тогда нам гарантировано максимальное время работы <!>.`,1),Eo=d("<!> <!>",1),Ho=d(`Итак, давайте в качестве опорного элемента выбирать случайную запись.
    То есть опорным элементом <!> может с равной вероятностью оказаться
    каждая из <!> записей <!>.`,1),wo=d(`При случайном выборе опорного элемента из всех <!> позиций,
    вероятность того, что опорный элемент окажется на индексе <!>,
    и даст подмассивы размеров <!> и <!>, равна <!>.
    Это точно такое же распределение <!>,
    как и для фиксированного выбора опорного элемента на случайной перестановке.`,1),Ao=d("Количество сравнений при разбиении <!> тоже равно <!>.",1),So=d(`Количество обменов при разбиении <!> тоже равно <!>,
    ведь для случайной перестановки распределение числа обменов зависит только
    от позиции опорного элемента, а не от того, как он был выбран.`,1),Go=d("Получается, что производящие функции числа сравнений <!> и числа обменов <!> в обоих вариантах совпадают, а значит, я могу просто переписать результат анализа.",1),Ro=d("<!> <!> <!> <!> <!>",1),Vo=d("<!> <!> <!>",1),Ko=d("Опорный элемент фиксированный, так что у нас опять <!>.",1),Oo=d(`Каждый индекс посещается соответствующим указателем ровно один раз:
    указатель <!> начинает с левой границы и движется только вправо,
    а указатель <!> начинает с правой границы и движется только влево.
    Эти два указателя встречаются где-то посередине и останавливаются.
    Значит, каждый индекс будет посещён ровно одним из указателей,
    и для него произойдёт ровно одно сравнение ключа с опорным элементом.`,1),To=d(`Получается, что <!> для всех <!>.
    Подставляем в рекурренту для <!>:`,1),Bo=d("Считаем производную, подставляем <!> и получаем рекурренту для <!>:",1),Lo=d(`Теперь обозначим <!>, и, посчитав вторую производную,
    получим рекуррентное соотношение для <!>:`,1),Mo=d(`Максимальное число сравнений достигается тогда, когда опорный элемент оказывается самым минимальным.
    Для максимального числа сравнений <!> получаем рекурренту <!> с <!>,
    решением которой является <!>.`,1),No=d(`Минимальное число сравнений достигается тогда, когда опорный элемент постоянно является медианой,
    и обрабатываемый массив делится ровно пополам.
    Понятно, что совсем ровное деление мы получить на произвольном массиве не сможем,
    потому что размер массива может быть любой. Оценим пока тут немного грубовато.
    Для минимального числа сравнений <!> получаем рекурренту <!> с <!>, грубым решением которой является <!>.`,1),zo=d("Получаем все важные характеристики количества сравнений <!>:",1),Do=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),Fo=d(`Опорный элемент не участвует в обменах до финального положения.
    Обмены происходят только между элементами левой и правой частями,
    при этом каждая пара <!>, где <!> взят из левой части,
    а <!> взят из правой части, может привести к обмену.
    Обменяются они тогда и только тогда, когда пара <!> будет составлять инверсию.
    Получается, что число обменов при быстрой сортировке со схемой Хоара
    равно числу инверсий между левой и правой частями.`,1),Io=d(`Массив разделён на две части, в одной <!> элементов, а в другой <!> элементов.
    Производящая функция для числа инверсий между множествами размера <!> и <!> равна гауссовому коэффициенту`,1),Jo=d("Тогда, усредняя по всем равновероятным разбиениям, получаем производящую функцию <!> числа обменов операции разбиения по схеме Хоара",1),Qo=d("где <!> &mdash; число инверсий между множествами <!> и <!>.",1),Uo=d("<!> <!> <!> <!> <!> <!> <!>",1),Wo=d(`Теперь мы можем записать производящую функцию <!> и вычислить оба момента <!>,
    чтобы найти главные характеристики числа обменов.`,1),Xo=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function ga(Qr){var F=Xo(),I=v(F);Xr(I,{title:"Сортировка обменами"});var J=r(I,2);A(J,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=nn(),p=r(v(m));T(p,{c:"swap"}),o(),a(t,m)}})}});var Q=r(J,2);rn(Q,{title:"Задача сортировки обменами",children:(c,C)=>{var t=tn(),h=v(t);_(h,{children:(i,k)=>{o();var s=on(),l=r(v(s));n(l,{m:"R_1, R_2, R_3, \\dotsc, R_{n-1}, R_n"});var f=r(l,2);n(f,{m:"R_j"});var x=r(f,2);n(x,{m:"K_j"});var j=r(x,2);n(j,{m:"\\le"}),o(),a(i,s)}});var m=r(h,2);_(m,{children:(i,k)=>{o();var s=an(),l=r(v(s));n(l,{m:"\\sigma \\in \\S_n"}),o(),a(i,s)}});var p=r(m,2);n(p,{display:!0,m:"K_{\\sigma(1)} \\le K_{\\sigma(2)} \\le K_{\\sigma(3)} \\le \\dotsb \\le K_{\\sigma(n-1)} \\le K_{\\sigma(n)}"});var u=r(p,2);_(u,{children:(i,k)=>{o();var s=_n(),l=r(v(s));n(l,{m:"\\sigma"});var f=r(l,2);T(f,{c:"swap"}),o(),a(i,s)}});var $=r(u,2);_($,{children:(i,k)=>{o();var s=en(),l=r(v(s));T(l,{c:"swap"});var f=r(l,2);T(f,{c:"swap"}),o(),a(i,s)}}),a(c,t)}});var U=r(Q,2);N(U,{anchor:"bubble-sort",children:(c,C)=>{o();var t=q("Сортировка пузырьком");a(c,t)}});var W=r(U,2);A(W,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=dn(),p=r(v(m));n(p,{m:"K_i"});var u=r(p,2);n(u,{m:"K_j"});var $=r(u,2);n($,{m:"K_i > K_j"});var i=r($,2);n(i,{m:"R_i"});var k=r(i,2);n(k,{m:"R_j"}),o(),a(t,m)}})}});var X=r(W,2);L(X,{code:`
input mutable array[int] a[n]

int last_swap
int bound = n - 1
bool exchanges_occurred = true

while exchanges_occurred and bound > 0:
    exchanges_occurred = false
    last_swap = 0

    for j = 0; j < bound; j++:
        if a[j] > a[j + 1]:
            swap a[j], a[j + 1]
            exchanges_occurred = true
            last_swap = j

    bound = last_swap
`});var Y=r(X,2);Jr(Y,{title:"Процесс сортировки пузырьком",children:(c,C)=>{A(c,{children:(t,h)=>{var m=mn(),p=v(m);_(p,{children:($,i)=>{o();var k=vn(),s=r(v(k));n(s,{m:"\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n"});var l=r(s,2);n(l,{m:"\\{1, 2, \\dotsc, n\\}"});var f=r(l,2);n(f,{m:"b_1, b_2, \\dotsc, b_n"}),o(),a($,k)}});var u=r(p,2);_(u,{children:($,i)=>{o();var k=sn(),s=r(v(k));n(s,{m:"\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n"});var l=r(s,2);n(l,{m:"\\sigma_1', \\sigma_2', \\dotsc, \\sigma_n'"});var f=r(l,2);n(f,{m:"b_1', b_2', \\dotsc, b_n'"});var x=r(f,2);n(x,{m:"1"}),o(),a($,k)}}),a(t,m)}})}});var Z=r(Y,2);Yr(Z,{children:(c,C)=>{A(c,{children:(t,h)=>{_(t,{children:(m,p)=>{o();var u=ln(),$=r(v(u));n($,{m:"\\sigma_j"});var i=r($,2);n(i,{m:"\\sigma_j"});var k=r(i,2);n(k,{m:"b_{\\sigma_j}"});var s=r(k,2);n(s,{m:"1"});var l=r(s,2);n(l,{m:"\\sigma_j"});var f=r(l,2);n(f,{m:"\\sigma_j"});var x=r(f,2);n(x,{m:"b_{\\sigma_j}"});var j=r(x,2);n(j,{m:"0"}),o(),a(m,u)}})}})}});var rr=r(Z,2);A(rr,{children:(c,C)=>{var t=fn(),h=v(t);_(h,{children:(f,x)=>{o();var j=q("Каждый алгоритм сортировки обменами, в том числе и сортировка пузырьком, характеризуется тремя величинами:");a(f,j)}});var m=r(h,2);n(m,{display:!0,m:`\\align{A &= \\text{количество проходов} \\\\
                  S &= \\text{количество обменов} \\\\
                  C &= \\text{количество сравнений}}`});var p=r(m,2);_(p,{children:(f,x)=>{o();var j=cn(),y=r(v(j));n(y,{m:"b_1, b_2, \\dotsc, b_n"});var w=r(y,2);n(w,{m:"\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n"}),o(),a(f,j)}});var u=r(p,2);n(u,{display:!0,m:`\\align{
          A &= 1 + \\max(b_1, b_2, \\dotsc, b_n) \\\\
          S &= b_1 + b_2 + \\dotsb + b_n \\\\
          C &= c_1 + c_2 + \\dotsb + c_A}`});var $=r(u,2);_($,{children:(f,x)=>{o();var j=pn(),y=r(v(j));n(y,{m:"c_j"});var w=r(y,2);n(w,{m:"\\code{bound} - 1"});var K=r(w,2);n(K,{m:"j"}),o(),a(f,j)}});var i=r($,2);_(i,{children:(f,x)=>{o();var j=$n(),y=r(v(j));n(y,{m:"t"});var w=r(y,2);T(w,{c:"bound"}),o(),a(f,j)}});var k=r(i,2);n(k,{display:!0,m:"\\max~ \\{b_i + i \\mid \\forall b_i \\ge t \\} - t \\quad\\text{при}~ 0 \\le t \\le \\max(b_1, b_2, \\dotsc, b_n)"});var s=r(k,2);_(s,{children:(f,x)=>{o();var j=q("Их этого факта получаем, что");a(f,j)}});var l=r(s,2);n(l,{display:!0,m:"c_j = \\max~ \\{ b_i + i \\mid \\forall b_i \\ge j - 1 \\} - j"}),a(c,t)}});var nr=r(rr,2);A(nr,{children:(c,C)=>{var t=un(),h=v(t);_(h,{children:(u,$)=>{var i=gn(),k=r(z(i));n(k,{m:"S"}),o(),D(i),a(u,i)}});var m=r(h,2);_(m,{children:(u,$)=>{o();var i=hn(),k=r(v(i));n(k,{m:"S = b_1 + b_2 + \\dotsb + b_n"});var s=r(k,2);n(s,{m:"\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n"}),o(),a(u,i)}});var p=r(m,2);n(p,{display:!0,m:`{\\large S :} \\quad
          \\min = 0 ,\\quad
          \\ave = n \\, (n-1) / 4  ,\\quad
          \\max = n \\, (n-1) / 2  ,\\quad
          \\dev = \\frac{1}{6}\\sqrt{n \\, (n-1) \\, (n + 5/2)}
          `}),a(c,t)}});var or=r(nr,2);A(or,{children:(c,C)=>{var t=yn(),h=v(t);_(h,{children:(g,E)=>{var e=kn(),P=r(z(e));n(P,{m:"A"}),o(),D(e),a(g,e)}});var m=r(h,2);_(m,{children:(g,E)=>{o();var e=xn(),P=r(v(e));n(P,{m:"k"});var b=r(P,2);n(b,{m:"1/n!"});var H=r(b,2);n(H,{m:"k"}),o(),a(g,e)}});var p=r(m,2);n(p,{display:!0,m:"\\prob (A \\le k) = \\frac{k^{n-k} \\, k!}{n!} \\quad\\text{при}~ 1 \\le k \\le n"});var u=r(p,2);_(u,{children:(g,E)=>{o();var e=Pn(),P=r(v(e));n(P,{m:"k"}),o(),a(g,e)}});var $=r(u,2);n($,{display:!0,m:"\\prob (A = k) = \\prob (A \\le k) - \\prob(A \\le k-1) = \\frac{1}{n!} \\Bigl( k^{n-k} \\, k! - (k-1)^{n-k+1} \\, (k-1)! \\Bigr)"});var i=r($,2);_(i,{children:(g,E)=>{o();var e=q("Среднее значение вычисляем просто по формуле математического ожидания, выполнив суммирование по частям");a(g,e)}});var k=r(i,2);n(k,{display:!0,m:"\\expect A = \\sum_{k=1}^n k \\cdot \\prob(A = k) = n + 1 - \\sum_{k=0}^n \\frac{k^{n-k} \\, k!}{n!} = n + 1 - P(n)"});var s=r(k,2);_(s,{children:(g,E)=>{o();var e=bn(),P=r(v(e));n(P,{m:"P(n)"});var b=r(P,2);Zr(b,{to:"/calculus/function-properties/asymptotics#sums-factorial",children:(R,O)=>{o();var B=q(`разделе «Факториальные суммы» статьи
        «Асимптотика»`);a(R,B)},$$slots:{default:!0}});var H=r(b,2);n(H,{m:"P(n) = \\sqrt{\\pi n/2} - 2/3 + O(1/\\sqrt{n})"}),o(),a(g,e)}});var l=r(s,2);_(l,{children:(g,E)=>{o();var e=q("В итоге получаем, что");a(g,e)}});var f=r(l,2);n(f,{display:!0,m:"\\expect A = n - \\sqrt{\\frac{\\pi n}{2}} + \\frac{5}{3} + O \\left( \\frac{1}{\\sqrt{n}} \\right)"});var x=r(f,2);_(x,{children:(g,E)=>{o();var e=q("Теперь посчитаем дисперсию");a(g,e)}});var j=r(x,2);n(j,{display:!0,m:`\\align{
      \\var A &= \\sum_{k=1}^n k^2 \\cdot \\prob(A = k) - (\\expect A)^2
      = \\left( (n+1)^2 - 2 \\sum_{k=0}^n k \\cdot \\frac{k^{n-k} \\, k!}{n!} - \\sum_{k=0}^n \\frac{k^{n-k} \\, k!}{n!} \\right) - \\left( n + 1 - \\sum_{k=0}^n \\frac{k^{n-k} \\, k!}{n!} \\right)^2 =\\\\
      &= \\Bigl( (n+1)^2 - 2 \\bigl( P(n+1) \\cdot (n+1) - (n+1) \\bigr) - P(n) \\Bigr) - \\bigl( n + 1 - P(n) \\bigr)^2 = \\\\
      &= 2 \\, (n+1) \\, \\bigl( 1 + P(n) - P(n+1) \\bigr) - P(n) - P(n)^2
      }`});var y=r(j,2);_(y,{children:(g,E)=>{o();var e=jn(),P=r(v(e));n(P,{m:"P(n)"}),o(),a(g,e)}});var w=r(y,2);n(w,{display:!0,m:"\\var A = \\left( 2 - \\frac{\\pi}{2} \\right) \\cdot n - \\frac{2}{3} \\sqrt{\\frac{\\pi n}{2}} + \\frac{2}{9} + O \\left( \\frac{1}{\\sqrt{n}} \\right)"});var K=r(w,2);_(K,{children:(g,E)=>{o();var e=q("Теперь можно вычислить стандартное отклонение");a(g,e)}});var G=r(K,2);n(G,{display:!0,m:`\\dev A
      = \\sqrt{\\left( 2 - \\frac{\\pi}{2} \\right) \\cdot n - \\frac{2}{3} \\sqrt{\\frac{\\pi n}{2}} + \\frac{2}{9} + O \\left( \\frac{1}{\\sqrt{n}} \\right)}
      = \\sqrt{2 - \\frac{\\pi}{2}} \\cdot \\sqrt{n} - \\frac{\\sqrt{\\pi/2}}{3 \\sqrt{2 - \\pi/2}} + O\\left(\\frac{1}{\\sqrt{n}}\\right)`});var V=r(G,2);_(V,{children:(g,E)=>{o();var e=qn(),P=r(v(e));n(P,{m:"A"}),o(),a(g,e)}});var S=r(V,2);n(S,{display:!0,m:`\\align{
          {\\large A :} \\quad&
          \\min = 1 ,\\quad
          \\ave = n - \\sqrt{\\frac{\\pi n}{2}} + \\frac{5}{3} + O \\left( \\frac{1}{\\sqrt{n}} \\right)  ,\\quad
          \\max = n  ,\\\\&
          \\dev = \\sqrt{2 - \\frac{\\pi}{2}} \\cdot \\sqrt{n} - \\frac{\\sqrt{\\pi/2}}{3 \\sqrt{2 - \\pi/2}} + O\\left(\\frac{1}{\\sqrt{n}}\\right)
          }`}),a(c,t)}});var ar=r(or,2);A(ar,{children:(c,C)=>{var t=Rn(),h=v(t);_(h,{children:(G,V)=>{var S=Cn(),g=r(z(S));n(g,{m:"C"}),o(),D(S),a(G,S)}});var m=r(h,2);_(m,{children:(G,V)=>{o();var S=En(),g=r(v(S));n(g,{m:"C = c_1 + c_2 + \\dotsb + c_A"});var E=r(g,2);n(E,{m:"c_j = \\max~ \\{ b_i + i \\mid \\forall b_i \\ge j - 1 \\} - j"});var e=r(E,2);n(e,{m:"f_j (k)"});var P=r(e,2);n(P,{m:"b_1, b_2, \\dotsc, b_n"});var b=r(P,2);n(b,{m:"1 \\le i \\le n"});var H=r(b,2);n(H,{m:"b_i < j-1"});var R=r(H,2);n(R,{m:"b_i + i - j \\le k"}),o(),a(G,S)}});var p=r(m,2);n(p,{display:!0,m:"f_j (k) = (j+k)! \\, (j-1)^{n-j-k} \\quad\\text{для}~ 0 \\le k \\le n - j"});var u=r(p,2);_(u,{children:(G,V)=>{o();var S=Hn(),g=r(v(S));n(g,{m:"c_j"});var E=r(g,2);n(E,{m:"k"});var e=r(E,2);n(e,{m:"f_j (k)"}),a(G,S)}});var $=r(u,2);n($,{display:!0,m:"\\prob (c_j \\le k) = \\frac{f_j (k)}{n!}"});var i=r($,2);_(i,{children:(G,V)=>{o();var S=wn(),g=r(v(S));n(g,{m:"c_j"});var E=r(g,2);n(E,{m:"k"}),o(),a(G,S)}});var k=r(i,2);n(k,{display:!0,m:"\\prob (c_j = k) = \\frac{f_j (k) - f_j (k-1)}{n!} \\quad\\text{при}~ k \\ge 1 \\quad\\text{и}\\quad \\prob(c_j = 0) = \\frac{f_j(0)}{n!} "});var s=r(k,2);_(s,{children:(G,V)=>{o();var S=An(),g=r(v(S));n(g,{m:"j"}),o(),a(G,S)}});var l=r(s,2);n(l,{display:!0,m:"\\expect c_j = \\sum_{k=0}^{n-j} k \\cdot \\prob(c_j = k) = \\frac{1}{n!} \\sum_{k=1}^{n-j} k \\cdot \\bigl( f_j (k) - f_j (k-1) \\bigr)"});var f=r(l,2);_(f,{children:(G,V)=>{o();var S=q("Просуммировав по частям, получаем, что");a(G,S)}});var x=r(f,2);n(x,{display:!0,m:"\\expect c_j = n - j + 1 - \\frac{1}{n!} \\sum_{k=0}^{n-j} f_j (k)"});var j=r(x,2);_(j,{children:(G,V)=>{o();var S=Sn(),g=r(v(S));n(g,{m:"j"}),o(),a(G,S)}});var y=r(j,2);n(y,{display:!0,m:"\\expect C = \\sum_{j=1}^n \\expect c_j = \\binom{n+1}{2} - \\frac{1}{n!} \\sum_{j=1}^n \\sum_{k=0}^{n-j} f_j(k)"});var w=r(y,2);_(w,{children:(G,V)=>{o();var S=Gn(),g=r(v(S));n(g,{m:"c_j"}),a(G,S)}});var K=r(w,2);n(K,{display:!0,m:`\\align{
      \\var c_j &= \\sum_{k=0}^{n-j} k^2 \\cdot \\prob(c_j = k) - (\\expect c_j)^2 = \\frac{1}{n!} \\sum_{k=1}^{n-j} k^2 \\cdot \\bigl( f_j (k) - f_j (k-1) \\bigr) - (\\expect c_j)^2  =\\\\
      &= (n-j+1)^2 - \\frac{1}{n!} \\sum_{k=0}^{n-j} (2k+1) \\, f_j(k) - \\left( n - j + 1 - \\frac{1}{n!} \\sum_{k=0}^{n-j} f_j (k) \\right)^2 = \\\\
      &= \\frac{1}{n!} \\sum_{k=0}^{n-j} \\bigl( 2(n - j - k) + 1 \\bigr) \\, f_j(k) - \\frac{1}{n!^2} \\sum_{k=0}^{n-j} \\sum_{m=0}^{n-j} f_j(k) \\, f_j(m)
      }`}),a(c,t)}});var _r=r(ar,2);N(_r,{children:(c,C)=>{o();var t=q("Шейкерная сортировка");a(c,t)}});var er=r(_r,2);A(er,{children:(c,C)=>{var t=On(),h=v(t);_(h,{children:(p,u)=>{o();var $=Vn(),i=r(v($));n(i,{m:"1"}),o(),a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=Kn(),i=r(v($));n(i,{m:"R_j"});var k=r(i,2);n(k,{m:"R_{j+1}"}),o(),a(p,$)}}),a(c,t)}});var tr=r(er,2);L(tr,{code:`
input mutable array[int] a[n]

int last_swap
int left_bound = 0
int right_bound = n - 1
bool exchanges_occurred = true

while exchanges_occurred and left_bound < right_bound:
    exchanges_occurred = false
    last_swap = left_bound

    for j = left_bound; j < right_bound; j++:
        if a[j] > a[j + 1]:
            swap a[j], a[j + 1]
            exchanges_occurred = true
            last_swap = j

    right_bound = last_swap

    if not exchanges_occurred:
        break

    exchanges_occurred = false
    last_swap = right_bound

    for j = right_bound; j > left_bound; j--:
        if a[j] < a[j - 1]:
            swap a[j], a[j - 1]
            exchanges_occurred = true
            last_swap = j

    left_bound = last_swap
`});var dr=r(tr,2);A(dr,{children:(c,C)=>{var t=Ln(),h=v(t);_(h,{children:(u,$)=>{o();var i=Tn(),k=r(v(i));n(k,{m:"b_1, b_2, \\dotsc, b_n"});var s=r(k,2);n(s,{m:"\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n"});var l=r(s,2);n(l,{m:"A"});var f=r(l,2);n(f,{m:"S"});var x=r(f,2);n(x,{m:"C"}),o(),a(u,i)}});var m=r(h,2);n(m,{display:!0,m:`\\align{
          A &= 1 + \\lceil \\max(b_1, b_2, \\dotsc, b_n) / 2 \\rceil \\\\
          S &= b_1 + b_2 + \\dotsb + b_n \\\\
          C &= c_1 + c_2 + \\dotsb + c_A}`});var p=r(m,2);_(p,{children:(u,$)=>{o();var i=Bn(),k=r(v(i));n(k,{m:"c_j"});var s=r(k,2);n(s,{m:"2 \\cdot (\\code{right\\_bound} - \\code{left\\_bound})"});var l=r(s,2);n(l,{m:"j"}),o(),a(u,i)}}),a(c,t)}});var vr=r(dr,2);N(vr,{children:(c,C)=>{o();var t=q("Сортировка Бетчера");a(c,t)}});var sr=r(vr,2);A(sr,{children:(c,C)=>{var t=Mn(),h=v(t);_(h,{children:(p,u)=>{o();var $=q(`Пока у нас получались только сортировки, которые имеют квадратичную временную сложность.
    Если мы хотим, чтобы наш алгоритм работал быстрее, нам необходимо сравнивать несоседние пары ключей,
    иначе иначе нам придётся сделать столько сравнений, сколько инверсий в перестановке.`);a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=q(`В 1964 году Кеннет Бетчер открыл интересный способ организации сравнений,
    который позволяет значительно ускорить сортировку и даёт возможность её параллелить.`);a(p,$)}}),a(c,t)}});var ir=r(sr,2);A(ir,{children:(c,C)=>{var t=Dn(),h=v(t);_(h,{children:(p,u)=>{o();var $=Nn(),i=r(v($));n(i,{m:"n \\ge 2"}),o(),a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=zn(),i=r(v($));n(i,{m:"t = \\lceil \\log_2 n \\rceil"});var k=r(i,2);n(k,{m:"2^t \\ge n"}),o(),a(p,$)}}),a(c,t)}});var mr=r(ir,2);L(mr,{code:`
input mutable array[int] records[n]

t = 0
while (1 << t) < N:
    t += 1
p = 1 << (t - 1)

while p > 0:
    q = 1 << (t - 1)
    r = 0
    d = p

    while q != p:
        for int i = 0; i < n - d; i++:
            if i & p == r:
                if records[i] > records[i + d]:
                    swap records[i], records[i + d]

        d = q - p
        q = q // 2
        r = p

    for int i = 0; i < n - d; i++:
        if (i & p) == r:
            if records[i][0] > records[i + d][0]:
                swap records[i], records[i + d]

    p = p // 2
`});var lr=r(mr,2);N(lr,{children:(c,C)=>{o();var t=q("Быстрая сортировка");a(c,t)}});var cr=r(lr,2);A(cr,{children:(c,C)=>{var t=Fn(),h=v(t);_(h,{children:(p,u)=>{o();var $=q(`В сортировке Бетчера последовательность сравнений предопределена,
    то есть мы постоянно сравниваем одни и те же пары ключей
    на фиксированных позициях вне зависимости от значения этих ключей.
    А между прочим, уже выполненные операции сравнения могут предоставить нам
    дополнительную информацию о сортируемой последовательности,
    и мы можем использовать эту информацию для выполнения более эффективной и быстрой сортировки.`);a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=q(`Попробуем отказаться от оптимизаций под параллельные алгоритмы в пользу более быстрой сортировки
    на обычных процессорах с последовательным выполнением операций.
    Иными словами, новый метод не будет применим для параллельных вычислений, как сортировка Бетчера,
    но сможет превзойти её на классической однопоточной архитектуре.`);a(p,$)}}),a(c,t)}});var pr=r(cr,2);A(pr,{children:(c,C)=>{var t=Xn(),h=v(t);_(h,{children:(l,f)=>{o();var x=In(),j=r(v(x));n(j,{m:"s"});var y=r(j,2);n(y,{m:"R"});var w=r(y,2);n(w,{m:"R"});var K=r(w,2);n(K,{m:"R"}),o(),a(l,x)}});var m=r(h,2);_(m,{children:(l,f)=>{o();var x=Jn(),j=r(v(x));n(j,{m:"R_1, R_2, \\dotsc, R_{s-1}"});var y=r(j,2);n(y,{m:"R_{s+1}, R_{s+2}, \\dotsc, R_{n}"});var w=r(y,2);n(w,{m:"K"});var K=r(w,2);n(K,{m:"R"});var G=r(K,2);n(G,{m:"K_j"});var V=r(G,2);n(V,{m:"R_j"}),o(),a(l,x)}});var p=r(m,2);n(p,{display:!0,m:"K_1, K_2, \\dotsc, K_{s-1} < K < K_{s+1}, K_{s+2}, \\dotsc, K_n"});var u=r(p,2);_(u,{children:(l,f)=>{o();var x=q(`То есть, наш массив записей стал разбит таким образом,
    что исходная задача сортировки сводится к двум независимым сортировкам пары массивов меньшей длины.
    Можно применять тот же метод к полученным подмассивам до тех пор, пока мы всё не отсортируем.
    При этом массивы единичной длины сортировать не надо.`);a(l,x)}});var $=r(u,2);_($,{children:(l,f)=>{o();var x=Qn();o(2),a(l,x)}});var i=r($,2);_(i,{children:(l,f)=>{o();var x=Un(),j=r(v(x));n(j,{m:"R"});var y=r(j,4);T(y,{c:"select_pivot()"}),o(),a(l,x)}});var k=r(i,2);_(k,{children:(l,f)=>{o();var x=Wn(),j=r(v(x));T(j,{c:"partition(ref array[T] a, int left, int right, int pivot_index) -> int"});var y=r(j,2);T(y,{c:"left"});var w=r(y,2);T(w,{c:"right"}),o(),a(l,x)}});var s=r(k,2);_(s,{children:(l,f)=>{o();var x=q("А пока общий код алгоритма быстрой сортировки");a(l,x)}}),a(c,t)}});var $r=r(pr,2);L($r,{code:`
require type T is comparable


function quick_sort(ref array[T] a[n]):
    recursive_quick_sort(a, left = 0, right = n - 1)


function recursive_quick_sort(ref array[T] a, int left, int right):
    if left >= right:
        return

    # Выбираем опорный элемент и разделяем массив
    int pivot_index = select_pivot(a, left, right)
    int s = partition(a, left, right, pivot_index)

    # Рекурсивно сортируем обе части
    recursive_quick_sort(a, left, s - 1)
    recursive_quick_sort(a, s + 1, right)
`});var fr=r($r,2);A(fr,{children:(c,C)=>{var t=Zn(),h=v(t);_(h,{children:(p,u)=>{o();var $=q(`Важно, что сортировка происходит обменами элементами.
    Конечно, можно было бы создавать новые массивы, а потом их соединять,
    но такой подход добавляет большое количество лишних операций и линейную сложность по памяти.`);a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=Yn(),i=r(v($));n(i,{m:"O(n^2)"});var k=r(i,2);n(k,{m:"O(n \\log n)"}),o(),a(p,$)}}),a(c,t)}});var gr=r(fr,2);M(gr,{children:(c,C)=>{o();var t=q("Аппарат анализа");a(c,t)}});var hr=r(gr,2);A(hr,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=q(`Для анализа различных стратегий выбора опорного элемента установим общие свойства,
    верные для любой реализации быстрой сортировки.`);a(t,m)}})}});var ur=r(hr,2);A(ur,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=q(`Важным свойством быстрой сортировки является сохранение случайности подмассивов после разбиения.
    Относительное положение записей в подмассивах никак не влияет на алгоритм разделения.
    Значит, случайность действительно сохраняется, и верна теорема`);a(t,m)}})}});var kr=r(ur,2);Jr(kr,{title:"Сохранение случайности при разбиении",children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=q(`Если исходный массив является случайной перестановкой,
    то после разбиения относительно опорного элемента оба получившихся подмассива
    являются случайными перестановками своих элементов.`);a(t,m)}})}});var xr=r(kr,2);A(xr,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=ro(),p=r(v(m));n(p,{m:"p_{n, \\- k}"});var u=r(p,2);n(u,{m:"k"});var $=r(u,2);n($,{m:"n-k-1"}),o(),a(t,m)}})}});var Pr=r(xr,2);A(Pr,{children:(c,C)=>{var t=_o(),h=v(t);_(h,{children:(i,k)=>{o();var s=no(),l=r(v(s));n(l,{m:"C"}),o(),a(i,s)}});var m=r(h,2);_(m,{children:(i,k)=>{o();var s=oo(),l=r(v(s));n(l,{m:"G_n (x) = \\sum_{j=0}^\\oo \\prob(C = j) \\cdot x^j"});var f=r(l,2);n(f,{m:"C"});var x=r(f,2);n(x,{m:"n"}),o(),a(i,s)}});var p=r(m,2);_(p,{children:(i,k)=>{o();var s=ao(),l=r(v(s));n(l,{m:"a_{n, \\- k}"});var f=r(l,2);n(f,{m:"k"});var x=r(f,2);n(x,{m:"A_{n, \\- k} (x) = \\sum_{j=0}^\\oo \\prob(a_{n, \\- k} = j) \\cdot x^j"}),o(),a(i,s)}});var u=r(p,2);n(u,{display:!0,m:"G_n (x) = \\sum_{k=0}^{n-1} p_{n, \\- k} \\cdot A_{n, \\- k} (x) \\cdot G_k (x) \\cdot G_{n-k-1} (x) \\quad\\text{и}~ G_0 (x) = 1 ~\\text{и}~ G_1 (x) = 1"});var $=r(u,2);_($,{children:(i,k)=>{o();var s=q("Это свойство производящей функции числа сравнений следует из сохранения случайности при разбиении.");a(i,s)}}),a(c,t)}});var br=r(Pr,2);A(br,{children:(c,C)=>{var t=so(),h=v(t);_(h,{children:(i,k)=>{o();var s=eo(),l=r(v(s));n(l,{m:"S"}),o(),a(i,s)}});var m=r(h,2);_(m,{children:(i,k)=>{o();var s=to(),l=r(v(s));n(l,{m:"H_n (x) = \\sum_{j=0}^\\oo \\prob(S = j) \\cdot x^j"});var f=r(l,2);n(f,{m:"S"});var x=r(f,2);n(x,{m:"n"});var j=r(x,2);n(j,{m:"p_{n, \\- k}"});var y=r(j,2);n(y,{m:"k"});var w=r(y,2);n(w,{m:"n-k-1"}),o(),a(i,s)}});var p=r(m,2);_(p,{children:(i,k)=>{o();var s=vo(),l=r(v(s));n(l,{m:"b_{n, \\- k}"});var f=r(l,2);n(f,{m:"k"});var x=r(f,2);n(x,{m:"B_{n, \\- k} (x) = \\sum_{j=0}^\\oo \\prob(b_{n, \\- k} = j) \\cdot x^j"}),o(),a(i,s)}});var u=r(p,2);n(u,{display:!0,m:"H_n (x) = \\sum_{k=0}^{n-1} p_{n, \\- k} \\cdot B_{n, \\- k} (x) \\cdot H_k (x) \\cdot H_{n-k-1} (x) \\quad\\text{и}~ H_0 (x) = 1 ~\\text{и}~ H_1 (x) = 1"});var $=r(u,2);_($,{children:(i,k)=>{o();var s=q(`Это свойство производящей функции числа обменов следует из сохранения случайности при разбиении
    и условной независимости числа обменов в подмассивах.`);a(i,s)}}),a(c,t)}});var jr=r(br,2);M(jr,{children:(c,C)=>{o();var t=q("Быстрая сортировка с фиксированным опорным элементом и разделение Ломуто");a(c,t)}});var qr=r(jr,2);A(qr,{children:(c,C)=>{var t=io(),h=v(t);_(h,{children:(p,u)=>{o();var $=q(`Рассмотрим простейшую стратегию — выбор элемента по фиксированному индексу.
    Эта стратегия кажется разумной для случайных данных, но, как мы увидим позже,
    она оказывается катастрофично неэффективной для упорядоченных и почти упорядоченных последовательностей.
    Разделение будет происходить по средством одного прямого прохода по массиву.`);a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=q(`Данный алгоритм разбиения был предложен Нико Ломуто в 1970-х годах
    как простой вариант оригинального разбиения Хоара,
    а позже был популяризован в книгах Бентли (Programming Pearls) и Кормена (Введение в алгоритмы).
    В оригинале в качестве опорного выбирался строго последний элемент, для еще большего удобства реализации,
    но я все-таки буду придерживаться принципа максимальной общности и не буду закреплять выбор индекса,
    просто скажу, что индекс фиксирован.`);a(p,$)}}),a(c,t)}});var yr=r(qr,2);L(yr,{code:`
function select_pivot(ref array[T] a, int left, int right) -> int:
    return left  # или любой другой фиксированный индекс от left до right


function partition(ref array[T] a, int left, int right, int pivot_index) -> int:
    # Переносим опорный элемент в конец для удобства
    swap a[pivot_index], a[right]
    T pivot = a[right]

    # i указывает границу между элементами меньших pivot и больших pivot
    int i = left

    for int j = left; j <= right - 1; j++:
        if a[j] < pivot:
            swap a[i], a[j]
            i = i + 1

    # Возвращаем опорный элемент на правильную позицию
    swap a[i], a[right]

    return i
`});var Cr=r(yr,2);A(Cr,{children:(c,C)=>{var t=ho(),h=v(t);_(h,{children:(e,P)=>{o();var b=q("Оценим количество сравнений, выполняемых быстрой сортировкой со схемой Ломуто.");a(e,b)}});var m=r(h,2);_(m,{children:(e,P)=>{o();var b=q(`В схеме Ломуто два элемента сравниваются только когда один из них является опорным элементом.
    При этом каждый элемент становится опорным ровно один раз, после чего занимает свою финальную позицию.
    То есть любые два различных элемента сравниваются не более одного раза за весь алгоритм сортировки.`);a(e,b)}});var p=r(m,2);_(p,{children:(e,P)=>{o();var b=mo(),H=r(v(b));n(H,{m:"p_{n, \\- k} = 1/n"});var R=r(H,2);n(R,{m:"k"});var O=r(R,2);n(O,{m:"0"});var B=r(O,2);n(B,{m:"n-1"});var Fr=r(B,2);n(Fr,{m:"n-1"});var Ir=r(Fr,2);n(Ir,{m:"A_{n, \\- k} = x^{n-1}"});var Wr=r(Ir,2);n(Wr,{m:"G_n (x)"}),o(),a(e,b)}});var u=r(p,2);n(u,{display:!0,m:"G_n (x) = \\frac{x^{n-1}}{n} \\sum_{k=0}^{n-1} G_k(x) \\, G_{n-k-1}(x)"});var $=r(u,2);_($,{children:(e,P)=>{o();var b=lo(),H=r(v(b));n(H,{m:"G(x)"});var R=r(H,2);n(R,{m:"1"}),o(),a(e,b)}});var i=r($,2);n(i,{display:!0,m:"G_n' (x) = \\frac{n-1}{n} \\, x^{n-2} \\sum_{k=0}^{n-1} G_k(x) \\, G_{n-k-1}(x) + \\frac{x^{n-1}}{n} \\sum_{k=0}^{n-1} \\bigl( G_k'(x) \\, G_{n-k-1}(x) + G_k(x) \\, G_{n-k-1}'(x) \\bigr)"});var k=r(i,2);_(k,{children:(e,P)=>{o();var b=co(),H=r(v(b));n(H,{m:"x=1"});var R=r(H,2);n(R,{m:"E_n = G_n'(1)"});var O=r(R,2);n(O,{m:"E_n"}),o(),a(e,b)}});var s=r(k,2);n(s,{display:!0,m:"E_n = n - 1 + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\quad\\text{и}~ E_0 = E_1 = 0"});var l=r(s,2);_(l,{children:(e,P)=>{o();var b=q("Решая эту реккуренту получаем");a(e,b)}});var f=r(l,2);n(f,{display:!0,m:"\\expect C = E_n = 2 \\, (n+1) \\, H_n - 4n"});var x=r(f,2);_(x,{children:(e,P)=>{o();var b=po(),H=r(v(b));n(H,{m:"V_n = G_n''(1)"});var R=r(H,2);n(R,{m:"V_n"}),o(),a(e,b)}});var j=r(x,2);n(j,{display:!0,m:"V_n = (n-1) \\, (n-2) + \\frac{4 \\, (n-1)}{n} \\sum_{k=0}^{n-1} E_k + \\frac{2}{n} \\sum_{k=0}^{n-1} V_k + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\, E_{n-k-1} \\quad\\text{и}~ V_0 = V_1 = 0"});var y=r(j,2);_(y,{children:(e,P)=>{o();var b=q("Решая эту рекурренту получаем");a(e,b)}});var w=r(y,2);n(w,{display:!0,m:"V_n = 4 \\, (n + 1)^2 \\cdot (H_n^2 - H_n^{(2)}) - 4 \\, (n + 1) \\, (4 n + 1) \\, H_n + 23 n^2 + 17 n"});var K=r(w,2);_(K,{children:(e,P)=>{o();var b=q("Тогда");a(e,b)}});var G=r(K,2);n(G,{display:!0,m:"\\var C = V_n + E_n - E_n^2 = 7 n^2 - 4 \\, (n+1)^2 \\, H_n^{(2)} - 2 \\, (n+1) \\, H_n + 13 n"});var V=r(G,2);_(V,{children:(e,P)=>{o();var b=$o(),H=r(v(b));n(H,{m:"C_{\\max} (n)"});var R=r(H,2);n(R,{m:"C_{\\max}(n) = (n-1) + C_{\\max}(n-1)"});var O=r(R,2);n(O,{m:"C_{\\max}(1) = 0"});var B=r(O,2);n(B,{m:"C_{\\max} = n(n-1)/2"}),o(),a(e,b)}});var S=r(V,2);_(S,{children:(e,P)=>{o();var b=fo(),H=r(v(b));n(H,{m:"C_{\\min} (n)"});var R=r(H,2);n(R,{m:"C_{\\min}(n) = (n-1) + C_{\\min}\\bigl( \\lfloor (n-1)/2 \\rfloor \\bigr) + C_{\\min}\\bigl( \\lceil (n-1)/2 \\rceil \\bigr)"});var O=r(R,2);n(O,{m:"C_{\\min}(0) = C_{\\min}(1) = 0"});var B=r(O,2);n(B,{m:"C_{\\min} < n \\log_2 n - n + O(\\log n)"}),o(),a(e,b)}});var g=r(S,2);_(g,{children:(e,P)=>{o();var b=go(),H=r(v(b));n(H,{m:"C"}),o(),a(e,b)}});var E=r(g,2);n(E,{display:!0,m:`\\align{{\\large C :}
         \\quad \\min &< n \\log_2 n - n + O(\\log n)
          \\\\! \\ave &= 2n \\ln n + (2 \\gamma - 4) \\cdot n + 2 \\ln n + (2 \\gamma + 1) + o(1)
          \\\\! \\max &= n^2/2 - n/2
          \\\\  \\dev &= \\sqrt{7-2\\pi^2/3} \\cdot n - \\frac{1}{\\sqrt{7-2\\pi^2/3}} \\cdot \\ln n + \\frac{17-4\\pi^2/3 - 2 \\gamma}{2 \\sqrt{7-2\\pi^2/3}} + o(1)
      }`}),a(c,t)}});var Er=r(Cr,2);A(Er,{children:(c,C)=>{var t=yo(),h=v(t);_(h,{children:(g,E)=>{o();var e=q("Теперь оценим количество обменов.");a(g,e)}});var m=r(h,2);_(m,{children:(g,E)=>{o();var e=uo(),P=r(v(e));n(P,{m:"b_{n, \\- k} = k"});var b=r(P,2);n(b,{m:"B_{n, \\- k} (x) = x^k"}),o(),a(g,e)}});var p=r(m,2);n(p,{display:!0,m:"H_n (x) = \\frac{1}{n} \\sum_{k=0}^{n-1} x^k \\, H_k (x) \\, H_{n-k-1} (x)"});var u=r(p,2);_(u,{children:(g,E)=>{o();var e=ko(),P=r(v(e));n(P,{m:"H(x)"});var b=r(P,2);n(b,{m:"E_n = H_n'(1)"});var H=r(b,2);n(H,{m:"V_n = H_n''(1)"}),o(),a(g,e)}});var $=r(u,2);_($,{children:(g,E)=>{o();var e=xo(),P=r(v(e));n(P,{m:"E_n"});var b=r(P,2);n(b,{m:"H_n'(x)"});var H=r(b,2);n(H,{m:"x=1"}),o(),a(g,e)}});var i=r($,2);n(i,{display:!0,m:"E_n = \\frac{n-1}{2} + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\quad\\text{и}~ E_0 = E_1 = 0"});var k=r(i,2);_(k,{children:(g,E)=>{o();var e=q("Решаем и получаем, что");a(g,e)}});var s=r(k,2);n(s,{display:!0,m:"\\expect S = E_n = (n+1) \\, H_n - 2 n"});var l=r(s,2);_(l,{children:(g,E)=>{o();var e=Po(),P=r(v(e));n(P,{m:"H_m''(x)"});var b=r(P,2);n(b,{m:"x=1"});var H=r(b,2);n(H,{m:"V_n"}),o(),a(g,e)}});var f=r(l,2);n(f,{display:!0,m:"V_n = \\frac{(n-1)\\, (n-2)}{3} + \\frac{2 \\, (n-1)}{n} \\sum_{k=0}^{n-1} E_k + \\frac{2}{n} \\sum_{k=0}^{n-1} V_k + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\, E_{n-k-1} \\quad\\text{и}~ V_0 = V_1 = 0"});var x=r(f,2);_(x,{children:(g,E)=>{o();var e=q("Решая эту рекурренту, получаем значение второго момента");a(g,e)}});var j=r(x,2);n(j,{display:!0,m:"V_n = (n + 1)^2 \\cdot (H_n^2 - H_n^{(2)}) - 2 \\, (n + 1) \\, (2n + 1) \\, H_n + 6 n^2 + 6 n"});var y=r(j,2);_(y,{children:(g,E)=>{o();var e=q("Тогда");a(g,e)}});var w=r(y,2);n(w,{display:!0,m:"\\var S = V_n + E_n - E_n^2 = 2 n ^2 - (n+1)^2 \\, H_n^{(2)} - (n+1) \\, H_n + 4 n"});var K=r(w,2);_(K,{children:(g,E)=>{o();var e=bo(),P=r(v(e));n(P,{m:"S_{\\max}(n) = n \\, (n-1) / 2"}),o(),a(g,e)}});var G=r(K,2);_(G,{children:(g,E)=>{o();var e=jo(),P=r(v(e));n(P,{m:"S_{\\min} = 0"}),o(),a(g,e)}});var V=r(G,2);_(V,{children:(g,E)=>{o();var e=qo(),P=r(v(e));n(P,{m:"C"}),o(),a(g,e)}});var S=r(V,2);n(S,{display:!0,m:`\\align{{\\large S :}
         \\quad \\min &= 0
          \\\\! \\ave &= n \\ln n + (\\gamma - 2) \\cdot n + \\ln n + (\\gamma + 1/2) + o(1)
          \\\\! \\max &= n^2/2 - n/2
          \\\\  \\dev &= \\sqrt{2 - \\pi^2/6} \\cdot n - \\frac{1}{2 \\sqrt{2 - \\pi^2 / 6}} \\cdot \\ln n + \\frac{5 - \\pi^2/3 - \\gamma}{2 \\sqrt{2 - \\pi^2 / 6}} + o(1)
      }`}),a(c,t)}});var Hr=r(Er,2);A(Hr,{children:(c,C)=>{var t=Eo(),h=v(t);_(h,{children:(p,u)=>{o();var $=Co(),i=r(v($));n(i,{m:"O(n \\log n)"});var k=r(i,2);n(k,{m:"2 n \\ln n + O(n)"});var s=r(k,2);n(s,{m:"n \\ln n + O(n)"});var l=r(s,2);n(l,{m:"O(n^2)"}),o(),a(p,$)}});var m=r(h,2);_(m,{children:(p,u)=>{o();var $=q("Проблему исправить можно, если выбирать не фиксированный элемент, а случайный.");a(p,$)}}),a(c,t)}});var wr=r(Hr,2);M(wr,{children:(c,C)=>{o();var t=q("Рандомизированная быстрая сортировка");a(c,t)}});var Ar=r(wr,2);A(Ar,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=Ho(),p=r(v(m));n(p,{m:"R"});var u=r(p,2);n(u,{m:"n"});var $=r(u,2);n($,{m:"R_1, R_2, \\dotsc, R_n"}),o(),a(t,m)}})}});var Sr=r(Ar,2);L(Sr,{code:`
function select_pivot(ref array[T] a, int left, int right) -> int:
    return uniform random(int, [left ... right])
`});var Gr=r(Sr,2);A(Gr,{children:(c,C)=>{var t=Ro(),h=v(t);_(h,{children:(i,k)=>{o();var s=q(`Анализ количества сравнений и количества обменов для рандомизированного выбора опорного элемента
    полностью совпадает с анализом для фиксированного выбора опорного элемента.`);a(i,s)}});var m=r(h,2);_(m,{children:(i,k)=>{o();var s=wo(),l=r(v(s));n(l,{m:"n"});var f=r(l,2);n(f,{m:"k"});var x=r(f,2);n(x,{m:"k"});var j=r(x,2);n(j,{m:"n-k-1"});var y=r(j,2);n(y,{m:"1/n"});var w=r(y,2);n(w,{m:"p_{n, \\- k} = 1/n"}),o(),a(i,s)}});var p=r(m,2);_(p,{children:(i,k)=>{o();var s=Ao(),l=r(v(s));n(l,{m:"a_{n, \\- k}"});var f=r(l,2);n(f,{m:"n-1"}),o(),a(i,s)}});var u=r(p,2);_(u,{children:(i,k)=>{o();var s=So(),l=r(v(s));n(l,{m:"b_{n, \\- k}"});var f=r(l,2);n(f,{m:"k"}),o(),a(i,s)}});var $=r(u,2);_($,{children:(i,k)=>{o();var s=Go(),l=r(v(s));n(l,{m:"C"});var f=r(l,2);n(f,{m:"S"}),o(),a(i,s)}}),a(c,t)}});var Rr=r(Gr,2);A(Rr,{children:(c,C)=>{var t=Vo(),h=v(t);_(h,{children:(u,$)=>{o();var i=q("Для рандомизированной быстрой сортировки");a(u,i)}});var m=r(h,2);n(m,{display:!0,m:`\\align{{\\large C :}
         \\quad \\min &< n \\log_2 n - n + O(\\log n)
          \\\\! \\ave &= 2n \\ln n + (2 \\gamma - 4) \\cdot n + 2 \\ln n + (2 \\gamma + 1) + o(1)
          \\\\! \\max &= n^2/2 - n/2
          \\\\  \\dev &= \\sqrt{7-2\\pi^2/3} \\cdot n - \\frac{1}{\\sqrt{7-2\\pi^2/3}} \\cdot \\ln n + \\frac{17-4\\pi^2/3 - 2 \\gamma}{2 \\sqrt{7-2\\pi^2/3}} + o(1)
      }`});var p=r(m,2);n(p,{display:!0,m:`\\align{{\\large S :}
         \\quad \\min &= 0
          \\\\! \\ave &= n \\ln n + (\\gamma - 2) \\cdot n + \\ln n + (\\gamma + 1/2) + o(1)
          \\\\! \\max &= n^2/2 - n/2
          \\\\  \\dev &= \\sqrt{2 - \\pi^2/6} \\cdot n - \\frac{1}{2 \\sqrt{2 - \\pi^2 / 6}} \\cdot \\ln n + \\frac{5 - \\pi^2/3 - \\gamma}{2 \\sqrt{2 - \\pi^2 / 6}} + o(1)
      }`}),a(c,t)}});var Vr=r(Rr,2);A(Vr,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=q(`В чём же тогда преимущество такого подхода? В том что этот вариант выбора опорного элемента недетерминированный,
    и к нему нельзя просто так подобрать плохие входные данные.
    Да, нам всё еще может не повести с выбором опорного элемента, но вероятность такого невезения крайне мала.
    А от умышленных атак этот алгоритм защищён, по крайней мере до того момента,
    пока злоумышленник не узнает алгоритм генерации случайных чисел и его сид.
    На практике это делает рандомизированную версию значительно устойчивее к враждебным данным`);a(t,m)}})}});var Kr=r(Vr,2);M(Kr,{children:(c,C)=>{o();var t=q("Оригинальная быстрая сортировка Хоара");a(c,t)}});var Or=r(Kr,2);A(Or,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=q(`Рассмотрим оригинальный алгоритм разбиения, предложенный создателем быстрой сортировки
    Чарльзом Энтони Ричардом Хоаром в 1960 году.`);a(t,m)}})}});var Tr=r(Or,2);L(Tr,{code:`
function select_pivot(ref array[T] a, int left, int right) -> int:
    return (left + right) // 2  # или любой другой фиксированный индекс от left до right

function hoare_partition(ref array[T] a, int left, int right, int pivot_index) -> int:
    pivot = a[pivot_index]
    i = left - 1; j = right + 1

    forever:
        do i++ while a[i] < pivot
        do j-- while a[j] > pivot

        if i >= j:
            return j

        swap a[i], a[j]
`});var Br=r(Tr,2);A(Br,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=Ko(),p=r(v(m));n(p,{m:"p_{n, \\- k} = 1/n"}),o(),a(t,m)}})}});var Lr=r(Br,2);A(Lr,{children:(c,C)=>{var t=Do(),h=v(t);_(h,{children:(g,E)=>{o();var e=q("Проанализируем число сравнений, которые случаются при быстрой сортировке со схемой разделения Хоара.");a(g,e)}});var m=r(h,2);_(m,{children:(g,E)=>{o();var e=Oo(),P=r(v(e));T(P,{c:"i"});var b=r(P,2);T(b,{c:"j"}),o(),a(g,e)}});var p=r(m,2);_(p,{children:(g,E)=>{o();var e=To(),P=r(v(e));n(P,{m:"A_{n,\\-k} (x) = x^n"});var b=r(P,2);n(b,{m:"k"});var H=r(b,2);n(H,{m:"G_n (x)"}),o(),a(g,e)}});var u=r(p,2);n(u,{display:!0,m:"G_n (x) = \\frac{x^n}{n} \\sum_{k=0}^{n-1} G_k(x) \\, G_{n-k-1}(x)"});var $=r(u,2);_($,{children:(g,E)=>{o();var e=Bo(),P=r(v(e));n(P,{m:"x=1"});var b=r(P,2);n(b,{m:"E_n = G'(1)"}),o(),a(g,e)}});var i=r($,2);n(i,{display:!0,m:"E_n = n + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\quad\\text{и}~ E_0 = E_1 = 0"});var k=r(i,2);_(k,{children:(g,E)=>{o();var e=q("Решая эту реккуренту получаем");a(g,e)}});var s=r(k,2);n(s,{display:!0,m:"\\expect C = E_n = 2 \\, (n+1) \\, H_n - \\frac{10}{3} n - \\frac{1}{3}"});var l=r(s,2);_(l,{children:(g,E)=>{o();var e=Lo(),P=r(v(e));n(P,{m:"V_n = G_n''(1)"});var b=r(P,2);n(b,{m:"V_n"}),o(),a(g,e)}});var f=r(l,2);n(f,{display:!0,m:"V_n = n \\, (n-1) + 4 \\sum_{k=0}^{n-1} E_k + \\frac{2}{n} \\sum_{k=0}^{n-1} V_k + \\frac{2}{n} \\sum_{k=0}^{n-1} E_k \\, E_{n-k-1} \\quad\\text{и}~ V_0 = V_1 = 0"});var x=r(f,2);_(x,{children:(g,E)=>{o();var e=q("Решая эту рекурренту получаем");a(g,e)}});var j=r(x,2);n(j,{display:!0,m:"V_n = 4 \\, (n + 1)^2 \\cdot (H_n^2 - H_n^{(2)}) - 4 \\, (n + 1) \\, (4 n + 1) \\, H_n + 23 n^2 + 17 n"});var y=r(j,2);_(y,{children:(g,E)=>{o();var e=q("Тогда");a(g,e)}});var w=r(y,2);n(w,{display:!0,m:"\\var C = V_n + E_n - E_n^2 = 7 n^2 - 4 \\, (n+1)^2 \\, H_n^{(2)} - 2 \\, (n+1) \\, H_n + 13 n"});var K=r(w,2);_(K,{children:(g,E)=>{o();var e=Mo(),P=r(v(e));n(P,{m:"C_{\\max} (n)"});var b=r(P,2);n(b,{m:"C_{\\max}(n) = (n-1) + C_{\\max}(n-1)"});var H=r(b,2);n(H,{m:"C_{\\max}(1) = 0"});var R=r(H,2);n(R,{m:"C_{\\max} = n(n-1)/2"}),o(),a(g,e)}});var G=r(K,2);_(G,{children:(g,E)=>{o();var e=No(),P=r(v(e));n(P,{m:"C_{\\min} (n)"});var b=r(P,2);n(b,{m:"C_{\\min}(n) = (n-1) + C_{\\min}\\bigl( \\lfloor (n-1)/2 \\rfloor \\bigr) + C_{\\min}\\bigl( \\lceil (n-1)/2 \\rceil \\bigr)"});var H=r(b,2);n(H,{m:"C_{\\min}(0) = C_{\\min}(1) = 0"});var R=r(H,2);n(R,{m:"C_{\\min} < n \\log_2 n - n + O(\\log n)"}),o(),a(g,e)}});var V=r(G,2);_(V,{children:(g,E)=>{o();var e=zo(),P=r(v(e));n(P,{m:"C"}),o(),a(g,e)}});var S=r(V,2);n(S,{display:!0,m:`\\align{{\\large C :}
         \\quad \\min &< n \\log_2 n - n + O(\\log n)
          \\\\! \\ave &= 2n \\ln n + (2 \\gamma - 4) \\cdot n + 2 \\ln n + (2 \\gamma + 1) + o(1)
          \\\\! \\max &= n^2/2 - n/2
          \\\\  \\dev &= \\sqrt{7-2\\pi^2/3} \\cdot n - \\frac{1}{\\sqrt{7-2\\pi^2/3}} \\cdot \\ln n + \\frac{17-4\\pi^2/3 - 2 \\gamma}{2 \\sqrt{7-2\\pi^2/3}} + o(1)
      }`}),a(c,t)}});var Mr=r(Lr,2);n(Mr,{display:!0,m:""});var Nr=r(Mr,2);A(Nr,{children:(c,C)=>{var t=Uo(),h=v(t);_(h,{children:(s,l)=>{o();var f=q("Проанализируем количество обменов, которое случается при быстрой сортировке со схемой разделения Хоара.");a(s,f)}});var m=r(h,2);_(m,{children:(s,l)=>{o();var f=Fo(),x=r(v(f));n(x,{m:"(i, j)"});var j=r(x,2);n(j,{m:"i"});var y=r(j,2);n(y,{m:"j"});var w=r(y,2);n(w,{m:"(i, j)"}),o(),a(s,f)}});var p=r(m,2);_(p,{children:(s,l)=>{o();var f=Io(),x=r(v(f));n(x,{m:"k"});var j=r(x,2);n(j,{m:"n-k-1"});var y=r(j,2);n(y,{m:"k"});var w=r(y,2);n(w,{m:"n-k-1"}),o(),a(s,f)}});var u=r(p,2);n(u,{display:!0,m:"\\qbinom{n-1}{k}{x} = \\sum_{m=0}^{k \\, (n-k-1)} (\\text{число разбиений с}~ m ~\\text{инверсиями}) \\cdot x^m"});var $=r(u,2);_($,{children:(s,l)=>{o();var f=Jo(),x=r(v(f));n(x,{m:"B_{n, \\- k} (x)"}),o(),a(s,f)}});var i=r($,2);n(i,{display:!0,m:`B_{n, \\- k} = 1 \\bigg/ \\binom{n-1}{k} \\cdot
          \\sum_{\\substack{S \\subset \\{1, 2, \\dotsc, n-1\\} \\\\ |S| = k}} x^{\\inv \\bigr( S, \\{1, 2, \\dotsc, n-1\\} \\without S \\bigr)}
          = \\qbinom{n-1}{k}{x} \\bigg/ \\binom{n-1}{k} \\quad\\text{для}~ 0 \\le k \\le n-2`});var k=r(i,2);_(k,{children:(s,l)=>{o();var f=Qo(),x=r(v(f));n(x,{m:"\\inv (A, B)"});var j=r(x,2);n(j,{m:"A"});var y=r(j,2);n(y,{m:"B"}),o(),a(s,f)}}),a(c,t)}});var zr=r(Nr,2);A(zr,{children:(c,C)=>{_(c,{children:(t,h)=>{o();var m=Wo(),p=r(v(m));n(p,{m:"H_n (x)"});var u=r(p,2);n(u,{m:"S"}),o(),a(t,m)}})}});var Dr=r(zr,2);M(Dr,{children:(c,C)=>{o();var t=q("Быстрая сортировка с медианой трёх");a(c,t)}});var Ur=r(Dr,2);A(Ur,{children:(c,C)=>{_(c,{})}}),a(Qr,F)}export{ga as component};
