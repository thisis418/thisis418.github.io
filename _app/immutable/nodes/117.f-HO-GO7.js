import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as $,a as p,b as e,s as r,n as a,t as g}from"../chunks/BWp35gWV.js";import{T as vr}from"../chunks/CR7k0xtG.js";import{P as j}from"../chunks/DPzc5wQr.js";import{P as h}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";import{D as K}from"../chunks/DlTIf4aM.js";import{C as tr}from"../chunks/BvAJckrt.js";import{S as C}from"../chunks/CBbFRhrb.js";import{H as k}from"../chunks/DXKx2xvL.js";import{C as U}from"../chunks/BmgYHZay.js";var mr=$(`Существует принципиально иной путь &mdash; хеширование.
    Основная идея заключается в том, чтобы отказаться от последовательного просмотра данных, а на основе искомого ключа <!> сразу вычислять значение функции <!>, которая укажет место хранение записи, информацию по ключу или любую другую информацию, которую мы ищем.`,1),ir=$("<!> <!>",1),lr=$(`<b>Хеш-функция</b> &mdash; сюръективная функция, отображающее какой-то объект в фиксированное множество из <!> элементов,
    часто представляющее собой просто <!>`,1),cr=$("Преобразование, выполняемое хеш-функцией называется <b>хешированием</b>.",1),hr=$("<!> <!> <!>",1),$r=$(`Рассмотрим нереалистичный, но показательный пример.
    Пусть у нас <!> ключей <!>.
    Вместо организации их в список или дерево, мы разместим их в обычном массиве <!>.`,1),pr=$(`Сами ключи могут быть очень большими числами, строками, структурами и так далее,
    и не могут в чистом виде выступать в качестве индекса массива.
    Поэтому нам придётся придумывать хеш-функцию <!>, которая будет по заданному ключу <!> вычислять его индекс в массиве <!>, то есть <!>.`,1),fr=$(`Получается, что мы теперь можем искать за чистое время <!> &mdash;
    вычислить <!> и перейти по адресу.
    Добавив особые значения <!> и чуть-чуть модифицировав структуру,
    можем получить не только константный поиск, но и константную вставку и удаления ключей.`,1),Pr=$("<!> <!> <!>",1),gr=$(`Давайте попытаемся отобразить <!>-элементное множество ключей
    в <!>-элементное множество выхода хеш-функции. Считаем, что <!>.
    Всего таких отображений существует <!>, но при этом только <!> из них дают различные значения для различных аргументов. Это ничножно маленькая часть.`,1),xr=$("<!> <!>",1),br=$(`Универсум <!> очень большой, даже бесконечный, а выходное множество очень маленькое.
    Значит, по принципу Дирихле, существуют два таких объекта <!> и <!>,
    что <!> и при этом <!>.`,1),ur=$("<b>Коллизия</b> &mdash; двойка неравных входных данных для хеш-функций, у которых хеши одинаковые.",1),jr=$("<!> <!>",1),yr=$(`Пусть мы всё так же отображаем <!>-элементное множество ключей
    в <!>-элементное множество хешей. Сколько может быть коллизий?
    Предположим, что хеш-функция равномерная, то есть все <!> выходов равновероятны.`,1),qr=$("И тогда математическое ожидание общего количества коллизий <!>",1),Cr=$("<!> <!> <!> <!> <!> <!> <!>",1),kr=$(`Посчитаем ковариации <!> и <!>.
    Вероятности <!>, поэтому`,1),Kr=$("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),Ur=$("Эта вероятность минимальна, когда <!>.",1),Or=$(`То явление, которое мы сейчас наблюдаем, называется <b>парадоксом дней рождений</b>.
    По отношению к нашей теме его можно сформулировать следующим образом:
    в мультимножество нужно добавить <!> случайных чисел от <!> до <!>,
    чтобы какие-то два из них совпали с существенной вероятностью, примерно <!>.
    Вероятность совпадения превысит <!>, если мы попытаемся добавить
    в мультимножество <!> случайных чисел.`,1),wr=$("<!> <!> <!> <!>",1),Ar=$(`Мы научились хешировать числа. Теперь мы хотим научиться хешировать последовательности чисел.
        Точнее, формально, мы хотим научиться хешировать строки из языка <!>,
        где каждый символ в алфавите <!> закодирован каким-то числом.`,1),Dr=$(`Строку <!> будем представлять как упорядоченный набор символов <!>,
        которые будем воспринимать как числа.`,1),Hr=$("<!> <!> <!>",1),Mr=$("<b>Прямым полиномиальным хешем</b> строки <!> называется число",1),Sr=$("<b>Обратным полиномиальным хешем</b> строки <!> называется число",1),Tr=$(`Здесь <!> &mdash; произвольное число, большее размера алфавита,
        а <!> &mdash; достаточно большой модуль, взаимнопростый с <!>.`,1),zr=$("<!> <!> <!> <!> <!>",1),Br=$("<!> <!>",1),Er=$(`Если нам известны хеши двух строк <!> и <!>,
        то мы можем быстро посчитать хеш конкатенации этих строк <!>.`,1),Fr=$(`А для удаления префикса придется делить по модулю <!>,
        то есть умножать на обратный по модулю <!> элемент`,1),Gr=$("<!> <!> <!> <!> <!> <!> <!>",1),Ir=$(`Нам нужна некоторая подготовка. Если мы хотим для данной строки быстро находить хеш любого её среза,
        то нам придется предварительно посчитать хеши всех префиксов этой строки.
        Хранить всё будем в массиве <!>,
        где <!> &mdash; хеш префикса, состоящего из <!> символов.`,1),Jr=$("<!> <!>",1),Lr=$("Теперь хеш среза <!> строки <!> легко считается по формуле",1),Nr=$("<!> <!>",1),Qr=$("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function _o(_r){var O=Qr(),w=p(O);vr(w,{title:"Хеширование"});var A=r(w,2);j(A,{children:(s,x)=>{var n=ir(),m=p(n);h(m,{children:(i,c)=>{a();var d=g("В главах «Простой поиск», «Самобалансирующиеся деревья», «Кусты» и «Боры» мы разбирали исключительно методы поиска, основанные на сравнении ключей целиком или по частям. Любой подход, основанный на сравнении, требует много операций как минимум самого сравнения.");e(i,d)}});var l=r(m,2);h(l,{children:(i,c)=>{a();var d=mr(),t=r(p(d));o(t,{m:"K"});var v=r(t,2);o(v,{m:"h(K)"}),a(),e(i,d)}}),e(s,n)}});var D=r(A,2);k(D,{children:(s,x)=>{a();var n=g("Хеш-функции");e(s,n)}});var H=r(D,2);K(H,{title:"Хеш-функция",children:(s,x)=>{var n=hr(),m=p(n);h(m,{children:(c,d)=>{var t=lr(),v=r(p(t),2);o(v,{m:"m"});var _=r(v,2);o(_,{m:"\\{0, 1, 2, \\dotsc, m-2, m-1\\}"}),e(c,t)}});var l=r(m,2);o(l,{display:!0,m:"\\hash \\colon \\UUU \\surjto \\{0, 1, 2, \\dotsc, m-2, m-1\\}"});var i=r(l,2);h(i,{children:(c,d)=>{a();var t=cr();a(2),e(c,t)}}),e(s,n)}});var M=r(H,2);j(M,{children:(s,x)=>{var n=Pr(),m=p(n);h(m,{children:(c,d)=>{a();var t=$r(),v=r(p(t));o(v,{m:"m"});var _=r(v,2);o(_,{m:"K_1, K_2, \\dotsc, K_m"});var P=r(_,2);U(P,{c:"a"}),a(),e(c,t)}});var l=r(m,2);h(l,{children:(c,d)=>{a();var t=pr(),v=r(p(t));o(v,{m:"h"});var _=r(v,2);o(_,{m:"K"});var P=r(_,2);U(P,{c:"a"});var f=r(P,2);o(f,{m:"\\code{a} \\bigl[ h(K) \\bigr] = K"}),a(),e(c,t)}});var i=r(l,2);h(i,{children:(c,d)=>{a();var t=fr(),v=r(p(t));o(v,{m:"O(1)"});var _=r(v,2);o(_,{m:"h(K)"});var P=r(_,2);U(P,{c:"none"}),a(),e(c,t)}}),e(s,n)}});var S=r(M,2);j(S,{children:(s,x)=>{var n=xr(),m=p(n);h(m,{children:(i,c)=>{a();var d=gr(),t=r(p(d));o(t,{m:"n"});var v=r(t,2);o(v,{m:"m"});var _=r(v,2);o(_,{m:"m > n"});var P=r(_,2);o(P,{m:"m^n"});var f=r(P,2);o(f,{m:"m!/(m-n)!"}),a(),e(i,d)}});var l=r(m,2);h(l,{children:(i,c)=>{a();var d=g(`Вообще, придумать такую функцию, которая попала бы в эту маленькую в часть приемлемых функций очень-очень сложно.
    Более того, такая функция должна просто и быстро вычисляться.`);e(i,d)}}),e(s,n)}});var T=r(S,2);j(T,{children:(s,x)=>{h(s,{children:(n,m)=>{a();var l=br(),i=r(p(l));o(i,{m:"\\UUU"});var c=r(i,2);o(c,{m:"a"});var d=r(c,2);o(d,{m:"b"});var t=r(d,2);o(t,{m:"a \\neq b"});var v=r(t,2);o(v,{m:"\\hash a = \\hash b"}),a(),e(n,l)}})}});var z=r(T,2);K(z,{title:"Коллизии",children:(s,x)=>{var n=jr(),m=p(n);h(m,{children:(i,c)=>{var d=ur();a(),e(i,d)}});var l=r(m,2);o(l,{display:!0,m:"(a, b) ~\\text{--- коллизия} \\defequiv a \\neq b \\land \\hash(a) = \\hash(b)"}),e(s,n)}});var B=r(z,2);j(B,{children:(s,x)=>{h(s,{children:(n,m)=>{a();var l=g(`Коллизии — штуки плохие.
    Нам бы очень хотелось придумать такую хеш-функцию, которая вообще не имела бы коллизий.`);e(n,l)}})}});var E=r(B,2);j(E,{children:(s,x)=>{var n=Cr(),m=p(n);h(m,{children:(_,P)=>{a();var f=yr(),u=r(p(f));o(u,{m:"n"});var b=r(u,2);o(b,{m:"m"});var q=r(b,2);o(q,{m:"m"}),a(),e(_,f)}});var l=r(m,2);h(l,{children:(_,P)=>{a();var f=g("Введём индикаторы для коллизий между элементами");e(_,f)}});var i=r(l,2);o(i,{display:!0,m:"c_{i~j} = [i ~\\text{и}~ j ~\\text{коллидируют}] \\quad\\text{при}~ i < j"});var c=r(i,2);h(c,{children:(_,P)=>{a();var f=g("Тогда можем вычислить математическое ожидание одной коллизии");e(_,f)}});var d=r(c,2);o(d,{display:!0,m:"\\expect c_{i~j} = \\prob \\bigl( h(i) = h(j) \\bigr) = \\frac{1}{m}"});var t=r(d,2);h(t,{children:(_,P)=>{a();var f=qr(),u=r(p(f));o(u,{m:"C = \\sum_{1 \\leq i < j \\leq n} c_{i~j}"}),e(_,f)}});var v=r(t,2);o(v,{display:!0,m:"\\expect C = \\sum_{1 \\leq i < j \\leq n} \\expect c_{i~j} = \\binom{n}{2} \\cdot \\frac{1}{m} = \\frac{n \\, (n-1)}{2m}"}),e(s,n)}});var F=r(E,2);j(F,{children:(s,x)=>{var n=Kr(),m=p(n);h(m,{children:(b,q)=>{a();var y=g("Найдём теперь стандартное отклонение.");e(b,y)}});var l=r(m,2);h(l,{children:(b,q)=>{a();var y=kr(),er=r(p(y));o(er,{m:"c_{i \\- j}"});var nr=r(er,2);o(nr,{m:"c_{k \\- l}"});var sr=r(nr,2);o(sr,{m:"\\prob (c_{i \\- j} = 1 \\land c_{k \\- l}) = 1/m^2"}),a(),e(b,y)}});var i=r(l,2);o(i,{display:!0,m:"\\cov (c_{i \\- j}, c_{k \\- l}) = \\expect (c_{i \\- j} \\, c_{k \\- l}) - \\expect c_{i \\- j} \\cdot \\expect c_{k \\- l} = \\frac{1}{m^2} - \\frac{1}{m} \\cdot \\frac{1}{m} = 0"});var c=r(i,2);h(c,{children:(b,q)=>{a();var y=g(`Интересно получилось: коллизии между элементами некоррелированы, если хеш-функция равномерная.
    Теперь дисперсия`);e(b,y)}});var d=r(c,2);o(d,{display:!0,m:"\\var c_{i \\- j} = \\expect ( c_{i \\- j}^2 ) - ( \\expect c_{i \\- j} )^2 = \\frac{1}{m} - \\frac{1}{m^2} = \\frac{m-1}{m^2}"});var t=r(d,2);h(t,{children:(b,q)=>{a();var y=g("Получается");e(b,y)}});var v=r(t,2);o(v,{display:!0,m:"\\var C = \\sum_{1 \\le i < j \\le n} \\var c_{i \\- j} = \\binom{n}{2} \\cdot \\frac{m-1}{m^2} = \\frac{n \\, (n-1) \\, (m-1)}{2m^2}"});var _=r(v,2);h(_,{children:(b,q)=>{a();var y=g("Тогда стандартное отклонение равно");e(b,y)}});var P=r(_,2);o(P,{display:!0,m:"\\dev C = \\sqrt{\\frac{n \\, (n-1) \\, (m-1)}{2m^2}} = \\frac{1}{m} \\sqrt{n \\, (n-1) \\, (m-1) / 2}"});var f=r(P,2);h(f,{children:(b,q)=>{a();var y=g("Мы получили все важные характеристики");e(b,y)}});var u=r(f,2);o(u,{display:!0,m:`{\\large C :}
          \\quad \\min = 0
         ,\\quad \\ave = n^2/ 2m + O(1)
         ,\\quad\\max = m
         ,\\quad\\dev = n / \\sqrt{2m} + O(1)
      `}),e(s,n)}});var G=r(F,2);j(G,{children:(s,x)=>{var n=wr(),m=p(n);h(m,{children:(d,t)=>{a();var v=g("Какая вероятность того, что коллизий вообще не будет?");e(d,v)}});var l=r(m,2);o(l,{display:!0,m:"\\prob (C = 0) = \\prod_{k=1}^{n-1} \\left(1 - \\frac{k}{m}\\right) = \\frac{m!}{m^n \\, (m-n)!} = \\exp \\left( - \\frac{n^2}{2m} + \\frac{n}{2m} - \\frac{n^3}{6m^2} + \\frac{n^2}{4m^2} + O \\left( \\frac{n}{m^2} \\right) \\right)"});var i=r(l,2);h(i,{children:(d,t)=>{a();var v=Ur(),_=r(p(v));o(_,{m:"m \\sim n^2"}),a(),e(d,v)}});var c=r(i,2);h(c,{children:(d,t)=>{a();var v=Or(),_=r(p(v),3);o(_,{m:"\\sqrt{m}"});var P=r(_,2);o(P,{m:"1"});var f=r(P,2);o(f,{m:"m"});var u=r(f,2);o(u,{m:"1-e^{-1/2} = 0.4"});var b=r(u,2);o(b,{m:"0.5"});var q=r(b,2);o(q,{m:"\\sqrt{2 \\ln 2 \\cdot m}"}),a(),e(d,v)}}),e(s,n)}});var I=r(G,2);k(I,{children:(s,x)=>{a();var n=g("Хеш-функции простых типов");e(s,n)}});var J=r(I,2);C(J,{children:(s,x)=>{a();var n=g("Целые числа");e(s,n)}});var L=r(J,2);C(L,{children:(s,x)=>{a();var n=g("Действительные числа");e(s,n)}});var N=r(L,2);k(N,{children:(s,x)=>{a();var n=g("Хеширование строк");e(s,n)}});var Q=r(N,2);C(Q,{children:(s,x)=>{a();var n=g("Полиномиальное хеширование");e(s,n)}});var R=r(Q,2);j(R,{children:(s,x)=>{var n=Hr(),m=p(n);h(m,{children:(c,d)=>{a();var t=Ar(),v=r(p(t));o(v,{m:"A^*"});var _=r(v,2);o(_,{m:"A"}),a(),e(c,t)}});var l=r(m,2);h(l,{children:(c,d)=>{a();var t=Dr(),v=r(p(t));o(v,{m:"s"});var _=r(v,2);o(_,{m:"s_i"}),a(),e(c,t)}});var i=r(l,2);o(i,{display:!0,m:"s = s_0 \\, s_1 \\, s_2 \\, s_3 \\dotsm s_{n-3} \\, s_{n-2} \\, s_{n-1} \\, s_n"}),e(s,n)}});var V=r(R,2);K(V,{title:"Полиномиальный хеш",children:(s,x)=>{var n=zr(),m=p(n);h(m,{children:(t,v)=>{var _=Mr(),P=r(p(_),2);o(P,{m:"s"}),a(),e(t,_)}});var l=r(m,2);o(l,{display:!0,m:"\\hash(s) = \\sum_{i=0}^{n} s_i \\cdot x^i \\bmod m = \\big( s_0 + s_1 \\cdot x + s_2 \\cdot x^2 + \\dotsb + s_{n-1} \\cdot x^{n-1} + s_n \\cdot x^n \\big) \\bmod m"});var i=r(l,2);h(i,{children:(t,v)=>{var _=Sr(),P=r(p(_),2);o(P,{m:"s"}),a(),e(t,_)}});var c=r(i,2);o(c,{display:!0,m:"\\hash(s) = \\sum_{i=0}^{n} s_i \\cdot x^{n-i} \\bmod m = \\big( s_0 \\cdot x^n + s_1 \\cdot x^{n-1} + s_2 \\cdot x^{n-2} + \\dotsb + s_{n-1} \\cdot x + s_n \\big) \\bmod m"});var d=r(c,2);h(d,{children:(t,v)=>{a();var _=Tr(),P=r(p(_));o(P,{m:"x"});var f=r(P,2);o(f,{m:"m"});var u=r(f,2);o(u,{m:"x"}),a(),e(t,_)}}),e(s,n)}});var W=r(V,2);j(W,{children:(s,x)=>{var n=Br(),m=p(n);h(m,{children:(i,c)=>{a();var d=g(`Считаются прямые и обратные полиномиальные хеши почти в лоб.
        Сами значения многочленов можно быстро считать с помощью индуктивных вычислений,
        ведь сам многочлен — индуктивная функция.`);e(i,d)}});var l=r(m,2);h(l,{children:(i,c)=>{a();var d=g("Обратный хеш еще и красиво пишется. Однако, он немного непривычен из-за обратного порядка символов.");e(i,d)}}),e(s,n)}});var X=r(W,2);tr(X,{code:`const int x = ...
const int m = ...

function forward_hash(string s) -> int:
    int hash = 0
    int monome = 1

    for c of s:
        hash = (hash + monome * c) % m
        monome = (monome * x) % m

    return hash

function backward_hash(string s) -> int:
    int hash = 0

    for c of s:
        hash = (hash * x + c) % m

    return hash`});var Y=r(X,2);C(Y,{children:(s,x)=>{a();var n=g("Свойства и быстрый пересчет");e(s,n)}});var Z=r(Y,2);j(Z,{children:(s,x)=>{var n=Gr(),m=p(n);h(m,{children:(_,P)=>{a();var f=Er(),u=r(p(f));o(u,{m:"a"});var b=r(u,2);o(b,{m:"b"});var q=r(b,2);o(q,{m:"ab"}),a(),e(_,f)}});var l=r(m,2);o(l,{display:!0,m:"\\hash(ab) = \\hash(a) + x^{|a|} \\cdot \\hash(b)"});var i=r(l,2);h(i,{children:(_,P)=>{a();var f=g("Отсюда легко выводятся алгоритмы удаления префикса и суффикса строки");e(_,f)}});var c=r(i,2);h(c,{children:(_,P)=>{a();var f=g("Для удаления суффикса достаточно просто вычесть хеш суффикса");e(_,f)}});var d=r(c,2);o(d,{display:!0,m:"\\hash(a) = \\hash(ab) - x^{|a|} \\cdot \\hash(b)"});var t=r(d,2);h(t,{children:(_,P)=>{a();var f=Fr(),u=r(p(f));o(u,{m:"m"});var b=r(u,2);o(b,{m:"m"}),a(),e(_,f)}});var v=r(t,2);o(v,{display:!0,m:"\\hash(b) = \\big( \\hash(ab) - \\hash(a) \\big) \\cdot \\big( x^{|a|} \\big)^{-1}"}),e(s,n)}});var rr=r(Z,2);j(rr,{children:(s,x)=>{var n=Jr(),m=p(n);h(m,{children:(i,c)=>{a();var d=g("Использовав две предыдущие формулы, можно получить формулу вычисления любого среза строки.");e(i,d)}});var l=r(m,2);h(l,{children:(i,c)=>{a();var d=Ir(),t=r(p(d));o(t,{m:"h"});var v=r(t,2);o(v,{m:"h_i"});var _=r(v,2);o(_,{m:"i"}),a(),e(i,d)}}),e(s,n)}});var or=r(rr,2);tr(or,{code:`const int x = ...
const int m = ...

string s
array[int] h

h[0] = 0  # Хеш пустой строки равен 0

for i = 1; i <= length(s); i++:
    h[i+1] = (h[i] + x ** i * s[i]) % m`});var ar=r(or,2);j(ar,{children:(s,x)=>{var n=Nr(),m=p(n);h(m,{children:(i,c)=>{a();var d=Lr(),t=r(p(d));o(t,{m:"s_{l:r}"});var v=r(t,2);o(v,{m:"s"}),a(),e(i,d)}});var l=r(m,2);o(l,{display:!0,m:"\\hash(s_{l:r}) = (h_r - h_l) \\cdot \\big( x^l \\big)^{-1}"}),e(s,n)}});var dr=r(ar,2);k(dr,{children:(s,x)=>{a();var n=g("Хеширование древовидных структур");e(s,n)}}),e(_r,O)}export{_o as component};
