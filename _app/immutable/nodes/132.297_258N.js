import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as p,a as i,b as o,s as r,n as a,t as h}from"../chunks/BWp35gWV.js";import{T as w}from"../chunks/CR7k0xtG.js";import{P as x}from"../chunks/DPzc5wQr.js";import{M as n}from"../chunks/BqyEoRxA.js";import{P as m}from"../chunks/B7flgP-x.js";import{H as z}from"../chunks/DXKx2xvL.js";import{S as A}from"../chunks/CBbFRhrb.js";var B=p(`Задача &laquo;найти алгоритм сортировки с минимальным числом сравнений&raquo; может показаться некорректной,
    потому что вообще минимальное число сравнений <!>, ведь есть алгоритмы, не требующие сравнений.`,1),C=p("<!> <!>",1),D=p(`Пусть <!> &mdash; минимальное число сравнений, достаточное для сортировки <!> элементов.
    На вопрос &laquo;находятся ли два элемента в отношении <!>?&raquo;
    можно ответить только двумя способами: да и нет.
    Здесь <!> &mdash; отношение, по которому производится сортировка.`,1),E=p(`По ответам на <!> вопросов нам нужно однозначно понять, какая из <!> перестановок
    исходных элементов является их отсортированным порядком. Значит,`,1),F=p("Применяя формулу Стирлинга для неравенства <!>, получаем оценку",1),G=p("<!> <!> <!> <!> <!>",1),I=p("<!> <!> <!> <!>",1),J=p("<!> <!> <!> <!> <!> <!>",1);function Y(S){var k=J(),q=i(k);w(q,{title:"Оптимальная сортировка"});var b=r(q,2);z(b,{children:(l,P)=>{a();var e=h("Сортировка с минимальным числом сравнений");o(l,e)}});var y=r(b,2);x(y,{children:(l,P)=>{var e=C(),v=i(e);m(v,{children:(_,g)=>{a();var t=B(),d=r(i(t));n(d,{m:"0"}),a(),o(_,t)}});var $=r(v,2);m($,{children:(_,g)=>{a();var t=h(`Но мы сейчас говорим только об алгоритмах сортировки,
    которые сортируют элементы множества с заданным на нём отношением линейного порядка.
    В этом контексте понятно, что сравнение — единственная доступная нам операция,
    поэтому придумывать алгоритмы с наименьшим числом сравнений вполне содержательная и интересная задача.`);o(_,t)}}),o(l,e)}});var H=r(y,2);A(H,{children:(l,P)=>{a();var e=h("Оценка снизу");o(l,e)}});var M=r(H,2);x(M,{children:(l,P)=>{var e=G(),v=i(e);m(v,{children:(d,f)=>{a();var s=D(),c=r(i(s));n(c,{m:"k"});var u=r(c,2);n(u,{m:"n"});var O=r(u,2);n(O,{m:"\\le"});var j=r(O,2);n(j,{m:"\\le"}),a(),o(d,s)}});var $=r(v,2);m($,{children:(d,f)=>{a();var s=E(),c=r(i(s));n(c,{m:"k"});var u=r(c,2);n(u,{m:"n!"}),a(),o(d,s)}});var _=r($,2);n(_,{display:!0,m:"n! \\le 2^k"});var g=r(_,2);m(g,{children:(d,f)=>{a();var s=F(),c=r(i(s));n(c,{m:"k \\ge \\lceil \\log_2 n! \\rceil"}),a(),o(d,s)}});var t=r(g,2);n(t,{display:!0,m:"k \\ge n \\log_2 n - n / \\ln 2 + \\log_2 n / 2 + O(1)"}),o(l,e)}});var T=r(M,2);x(T,{children:(l,P)=>{var e=I(),v=i(e);m(v,{children:(t,d)=>{a();var f=h("Этой оценки почти достигают некоторые разобранные ранее алгоритмы.");o(t,f)}});var $=r(v,2);m($,{children:(t,d)=>{a();var f=h("Подходит алгоритм бинарных вставок, количество сравнений в котором выражается формулой");o(t,f)}});var _=r($,2);n(_,{display:!0,m:"\\sum_{k=1}^n \\lceil \\log_2 n \\rceil = n \\cdot \\lceil \\log_2 n \\rceil - 2^{\\lceil \\log_2 n \\rceil} + 1 = n \\log_2 n - n + O(1)"});var g=r(_,2);m(g,{}),o(l,e)}}),o(S,k)}export{Y as component};
