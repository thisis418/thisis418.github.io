import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as i,a as p,b as a,s as o,n as t,t as c}from"../chunks/BWp35gWV.js";import{T as N}from"../chunks/CR7k0xtG.js";/* empty css                */import{P as s}from"../chunks/B7flgP-x.js";/* empty css                *//* empty css                *//* empty css                */import{C as g}from"../chunks/BvAJckrt.js";import{C as _}from"../chunks/BmgYHZay.js";import{H as P}from"../chunks/DXKx2xvL.js";import{M as x}from"../chunks/BqyEoRxA.js";import{B as Q}from"../chunks/CZ1-HcAj.js";import{L as u}from"../chunks/NE91WFFs.js";var R=i(`Изначально у нас есть <!> элементов, каждый из которых находится в своем независимом множестве.
    Структура поддерживает несколько основных операций`,1),S=i("<!> &mdash; объединение двух множеств в одно",1),U=i("<!> &mdash; получение множества, в котором находится данный элемент",1),V=i("<!> &mdash; получение количества элементов в множестве",1),W=i("<!> <!> <!>",1),X=i(`Пусть, для простоты, элементы множеств пронумерованы от <!> до <!>.
    Родителей элементов можно хранить в массиве <!>, тогда родитель элемента <!> &mdash;
    элемент <!>.`,1),Y=i(`Каждое множество в структуре связано со своим лидером.
    Операция <!> будет возвращать лидера множества, в котором содержится элемент <!>.`,1),Z=i("При такой реализации обе операции занимают время <!>, потому что дерево может оказаться бамбуком.",1),rr=i(`Давайте ускорим операцию <!>. После того, как мы нашли лидера множества, в котором находится элемент <!> мы можем подвесить <!> к этому лидеру. Тогда последующие выполнения операции <!> будут работать за время <!> (естественно, при условии, что это множество ни с кем не
    объединяется).`,1),or=i(`Этот прием называется <b>эвристикой сжатия пути</b>. Действительно, мы &laquo;сжимаем&raquo; путь до корня,
    подвешивая все его вершины к корню.`,1),er=i("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function hr(J){var b=er(),C=p(b);N(C,{title:"Система непересекающихся множеств"});var L=o(C,2);s(L,{children:(e,d)=>{t();var r=c(`Система непересекающихся множеств — структура данных, позволяющая объединять непересекающиеся множества и
    отвечать на разные запросы про них.`);a(e,r)}});var q=o(L,2);s(q,{children:(e,d)=>{t();var r=R(),n=o(p(r));x(n,{m:"n"}),t(),a(e,r)}});var B=o(q,2);Q(B,{children:(e,d)=>{var r=W(),n=p(r);u(n,{children:(v,f)=>{var l=S(),h=p(l);_(h,{c:"unite(set a, set b)"}),t(),a(v,l)}});var m=o(n,2);u(m,{children:(v,f)=>{var l=U(),h=p(l);_(h,{c:"get(object x)"}),t(),a(v,l)}});var $=o(m,2);u($,{children:(v,f)=>{var l=V(),h=p(l);_(h,{c:"size(set s)"}),t(),a(v,l)}}),a(e,r)}});var H=o(B,2);P(H,{children:(e,d)=>{t();var r=c("Устройство структуры");a(e,r)}});var M=o(H,2);s(M,{children:(e,d)=>{t();var r=c(`Множества хранятся в виде корневых деревьев, а сами элементы множеств хранятся в вершинах.
    В корне дерева хранится представитель этого множества (лидер).
    В каждой вершине хранится ссылка на родителя.
    Если у какого-то элемента ссылка на родителя указывает на него же, то этот элемент является
    лидером.
    Операция получения множества, в котором хранится данный элемент, будет возвращать нам лидера этого множества.
    При объединении двух множеств деревья объединяются: корень одного дерева подвешивается к корню другого.`);a(e,r)}});var O=o(M,2);s(O,{children:(e,d)=>{t();var r=X(),n=o(p(r));x(n,{m:"0"});var m=o(n,2);x(m,{m:"n-1"});var $=o(m,2);_($,{c:"parents"});var v=o($,2);_(v,{c:"x"});var f=o(v,2);_(f,{c:"parent[x]"}),t(),a(e,r)}});var T=o(O,2);s(T,{children:(e,d)=>{t();var r=c("При инициализации структуры каждый элемент должен попасть в свое собственное независимое множество");a(e,r)}});var j=o(T,2);g(j,{code:`array[int] parents[n]

for i = 0, i < n:
    parents[i] = i`});var k=o(j,2);P(k,{children:(e,d)=>{t();var r=c("Наивная реализация");a(e,r)}});var y=o(k,2);s(y,{children:(e,d)=>{t();var r=Y(),n=o(p(r));_(n,{c:"get"});var m=o(n,2);_(m,{c:"x"}),t(),a(e,r)}});var z=o(y,2);s(z,{children:(e,d)=>{t();var r=c("Для выполнения операции нужно просто пройтись вверх по дереву, пока не дойдем до лидера.");a(e,r)}});var I=o(z,2);g(I,{code:`function get(int x) -> int:
    if parent[x] == x:
        return x
    else:
        return get(parent[x])`});var w=o(I,2);s(w,{children:(e,d)=>{t();var r=c(`Для объединения двух множеств достаточно подвесить одно дерево к другому. Для этого найдем корни каждого дерева
    (лидеры каждого множества) и перезапишем ссылку на родителя одного из них.`);a(e,r)}});var A=o(w,2);g(A,{code:`function unite(int a, int b):
    a = get(a)
    b = get(b)
    parent[a] = b`});var D=o(A,2);s(D,{children:(e,d)=>{t();var r=Z(),n=o(p(r));x(n,{m:"O(n)"}),t(),a(e,r)}});var E=o(D,2);P(E,{children:(e,d)=>{t();var r=c("Эвристика сжатия пути");a(e,r)}});var F=o(E,2);s(F,{children:(e,d)=>{t();var r=rr(),n=o(p(r));_(n,{c:"get"});var m=o(n,2);x(m,{m:"x"});var $=o(m,2);_($,{c:"x"});var v=o($,2);_(v,{c:"get(x)"});var f=o(v,2);x(f,{m:"O(1)"}),t(),a(e,r)}});var G=o(F,2);g(G,{code:`function get(int x) -> int:
    if parent[x] == x:
        return x
    else:
        parent[x] = get(parent[x])
        return parent[x]`});var K=o(G,2);s(K,{children:(e,d)=>{t();var r=or();t(2),a(e,r)}}),a(J,b)}export{hr as component};
