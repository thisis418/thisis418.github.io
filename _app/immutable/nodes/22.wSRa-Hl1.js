import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as v,a as d,b as n,s as r,n as o,t as y}from"../chunks/B1HoO4k0.js";import{H as O}from"../chunks/VyKLllFE.js";import{S as z}from"../chunks/C9QRwwNg.js";import{P as x}from"../chunks/B8FEnsbH.js";import{M as a}from"../chunks/e5qaD0UW.js";import{C as J}from"../chunks/DunPP-_K.js";import{S as K}from"../chunks/D2QCM4hc.js";import{P as R}from"../chunks/ClksMsit.js";var Q=v(`Пусть <!>.
    Мы хотим найти корень <!>, то есть такую точку <!>, что`,1),U=v("<!> <!>",1),V=v(`Пусть <!>.
    Мы хотим найти корень <!>, то есть такой вектор <!>, что`,1),W=v("<!> <!>",1),X=v(`Будем опять находить решение итеративно.
    Пусть <!> &mdash; какое-то приближённое решение задачи, и мы хотим улучшить это решение.
    То есть мы хотим найти такое <!>, чтобы <!>.`,1),Y=v(`Мы очень хотим выбрать такой шаг <!>, чтобы <!>.
    Используем предыдущую формулу`,1),Z=v(`Теперь нам нужно выбрать вектор <!>, по которому нужно двигаться.
    Учитывая, что градиент &mdash; направление наибыстрейшего подъема, кажется естественным выбрать вектор <!> так, чтобы он был коллинеарен градиенту`,1),rr=v(`Осталось решить уравнение <!>.
    Получаем`,1),ar=v("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),or=v(`Напишем алгоритм в псевдокоде.
    Для этого нам нужно уметь вычислять функцию <!> и её градиент <!>.`,1),er=v(`Наш метод будет работать только если начальное значение <!> уже близко к корню.
    Если это не так, то у нас точно возникнет большое количество проблем.`,1),nr=v(`Вместо поиска корня <!> можно найти минимум функции <!>.
    В принципе, для этого можно использовать и другие алгоритмы, но мы посмотрим на алгоритм Ньютона.`,1),tr=v("<!> <!> <!>",1),_r=v(`Пусть <!> &mdash; многомерная функция.
    Мы хотим научиться решать уравнение <!>.`,1),dr=v("Действовать придётся итеративно, начиная с какого-то приближения <!>.",1),vr=v("<!> <!>",1),lr=v("Вспомним формулу для линеаризации, где <!> &mdash; какой-то небольшой шаг:",1),sr=v(`Попробуем выбрать <!> так, чтобы <!>.
    Используем приближение`,1),mr=v(`У нас получилась система линейных уравнений относительно <!>.
    Решаем, находя обратную матрицу`,1),fr=v("<!> <!> <!> <!> <!> <!>",1),ir=v(`Получается, для решения уравнения <!>, нужно выполнять итеративный процесс,
    начиная с точки <!>`,1),xr=v("<!> <!>",1),cr=v("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function yr(A){var D=cr(),j=d(D);z(j,{title:"Нахождение корня функции",children:(s,P)=>{var e=U(),m=d(e);x(m,{children:(f,c)=>{o();var l=Q(),t=r(d(l));a(t,{m:"f \\colon \\RR \\to \\RR"});var _=r(t,2);a(_,{m:"f"});var h=r(_,2);a(h,{m:"x^* \\in \\RR"}),o(),n(f,l)}});var i=r(m,2);a(i,{display:!0,m:"f(x^*) = 0"}),n(s,e)}});var S=r(j,2);O(S,{children:(s,P)=>{o();var e=y("Скалярная функция многих переменных");n(s,e)}});var T=r(S,2);z(T,{title:"Нахождение корня скалярной функции многих переменных",children:(s,P)=>{var e=W(),m=d(e);x(m,{children:(f,c)=>{o();var l=V(),t=r(d(l));a(t,{m:"f \\colon \\RR^n \\to \\RR"});var _=r(t,2);a(_,{m:"f"});var h=r(_,2);a(h,{m:"x^* \\in \\RR^n"}),o(),n(f,l)}});var i=r(m,2);a(i,{display:!0,m:"f(x^*) = 0"}),n(s,e)}});var q=r(T,2);R(q,{children:(s,P)=>{var e=ar(),m=d(e);x(m,{children:($,F)=>{o();var p=X(),b=r(d(p));a(b,{m:"x_k"});var u=r(b,2);a(u,{m:"\\Delta x"});var G=r(u,2);a(G,{m:"f(x_k + \\Delta x) = 0"}),o(),n($,p)}});var i=r(m,2);x(i,{children:($,F)=>{o();var p=y("По формуле Тейлора");n($,p)}});var f=r(i,2);a(f,{display:!0,m:"f(x_k + \\Delta x) \\approx f(x_k) + \\nabla f (x_k) ^\\T \\cdot \\Delta x"});var c=r(f,2);x(c,{children:($,F)=>{o();var p=Y(),b=r(d(p));a(b,{m:"\\Delta x"});var u=r(b,2);a(u,{m:"f(x_k + \\Delta x) = 0"}),o(),n($,p)}});var l=r(c,2);a(l,{display:!0,m:"f(x_k) + \\nabla f (x_k) ^\\T \\cdot \\Delta x \\approx 0"});var t=r(l,2);x(t,{children:($,F)=>{o();var p=Z(),b=r(d(p));a(b,{m:"\\Delta x"});var u=r(b,2);a(u,{m:"\\Delta x"}),o(),n($,p)}});var _=r(t,2);a(_,{display:!0,m:"\\Delta x = - \\alpha \\cdot \\nabla f (x_k)"});var h=r(_,2);x(h,{children:($,F)=>{o();var p=rr(),b=r(d(p));a(b,{m:"f(x_k) + \\nabla f (x_k) ^\\T \\cdot (- \\alpha \\cdot \\nabla f (x_k)) = 0"}),o(),n($,p)}});var g=r(h,2);a(g,{display:!0,m:"\\alpha = \\frac{f(x_k)}{\\nabla f (x_k) \\cdot \\nabla f (x_k) ^\\T} = \\frac{f(x_k)}{ \\|\\nabla f (x_k)\\|_2^2}"});var k=r(g,2);x(k,{children:($,F)=>{o();var p=y(`Мы поняли, как выбирать шаг, для того чтобы двигаться к нулю все ближе.
    Результирующий алгоритм состоит всего из одной формулы`);n($,p)}}),n(s,e)}});var w=r(q,2);a(w,{display:!0,m:"x_{k+1} = x_k - \\frac{f(x_k)}{\\| \\nabla f (x_k) \\|_2^2} \\cdot \\nabla f (x_k)"});var C=r(w,2);R(C,{children:(s,P)=>{x(s,{children:(e,m)=>{o();var i=or(),f=r(d(i));a(f,{m:"f"});var c=r(f,2);a(c,{m:"\\nabla f"}),o(),n(e,i)}})}});var H=r(C,2);J(H,{code:`
function f(vector x) -> real: ...
function gradient(vector[real] x) -> vector[real]: ...

function solve_by_newton(f, gradient) -> real:
    select x: real

    while f(x) >= EPSILON:
        x = f(x) / (norm(gradient(x)) ** 2) * gradient(x)

    return x
`});var M=r(H,2);K(M,{children:(s,P)=>{o();var e=y("Далёкие от корня значения");n(s,e)}});var E=r(M,2);R(E,{children:(s,P)=>{var e=tr(),m=d(e);x(m,{children:(c,l)=>{o();var t=er(),_=r(d(t));a(_,{m:"x_0"}),o(),n(c,t)}});var i=r(m,2);x(i,{children:(c,l)=>{o();var t=nr(),_=r(d(t));a(_,{m:"f"});var h=r(_,2);a(h,{m:"\\frac{1}{2} f(x)^2"}),o(),n(c,t)}});var f=r(i,2);a(f,{display:!0,m:`\\nabla \\left( \\frac{1}{2} \\cdot f^2 \\right) = f \\cdot \\nabla f \\quad\\text{и}\\quad
    \\hess \\left( \\frac{1}{2} \\cdot f^2 \\right) = \\nabla f \\cdot \\nabla f ^\\T + f \\cdot \\hess f`}),n(s,e)}});var I=r(E,2);O(I,{children:(s,P)=>{o();var e=y("Многомерные функции");n(s,e)}});var L=r(I,2);R(L,{children:(s,P)=>{var e=vr(),m=d(e);x(m,{children:(f,c)=>{o();var l=_r(),t=r(d(l));a(t,{m:"F \\colon \\RR^n \\to \\RR^n"});var _=r(t,2);a(_,{m:"F(x) = \\0"}),o(),n(f,l)}});var i=r(m,2);x(i,{children:(f,c)=>{o();var l=dr(),t=r(d(l));a(t,{m:"x_0 \\in \\RR^n"}),o(),n(f,l)}}),n(s,e)}});var N=r(L,2);R(N,{children:(s,P)=>{var e=fr(),m=d(e);x(m,{children:(_,h)=>{o();var g=lr(),k=r(d(g));a(k,{m:"h \\in \\RR^n"}),o(),n(_,g)}});var i=r(m,2);a(i,{display:!0,m:"F(x + h) = F(x) + \\jacobi F (x) \\cdot h + o \\bigl( \\| h \\| \\bigr)"});var f=r(i,2);x(f,{children:(_,h)=>{o();var g=sr(),k=r(d(g));a(k,{m:"h"});var $=r(k,2);a($,{m:"F(x+h) = \\0"}),o(),n(_,g)}});var c=r(f,2);a(c,{display:!0,m:"\\0 = F(x+h) \\approx F(x) + \\jacobi F (x) \\cdot h"});var l=r(c,2);x(l,{children:(_,h)=>{o();var g=mr(),k=r(d(g));a(k,{m:"h"}),o(),n(_,g)}});var t=r(l,2);a(t,{display:!0,m:"\\jacobi F (x) \\cdot h = - F(x) \\implies h = - \\bigl( \\jacobi F (x) \\bigr)^{-1} \\cdot F(x)"}),n(s,e)}});var B=r(N,2);R(B,{children:(s,P)=>{var e=xr(),m=d(e);x(m,{children:(f,c)=>{o();var l=ir(),t=r(d(l));a(t,{m:"F(x) = \\0"});var _=r(t,2);a(_,{m:"x_0"}),n(f,l)}});var i=r(m,2);a(i,{display:!0,m:"x_{j+1} = x_j - \\bigl( \\jacobi F (x_j) \\bigr)^{-1} \\cdot F(x_j)"}),n(s,e)}}),n(A,D)}export{yr as component};
