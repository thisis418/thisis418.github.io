import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as i,a as g,b as _,s as r,n as a,t as P}from"../chunks/BWp35gWV.js";import{P as y}from"../chunks/DPzc5wQr.js";import{M as o}from"../chunks/BqyEoRxA.js";import{H as G}from"../chunks/DXKx2xvL.js";import{P as m}from"../chunks/B7flgP-x.js";import{C as or}from"../chunks/BvAJckrt.js";import{S as N}from"../chunks/CBbFRhrb.js";import{T as ar}from"../chunks/y0AHHn4v.js";import{P as dr}from"../chunks/BBkyo9uE.js";var tr=i("Например, последовательность кодов Грея для <!>",1),vr=i("<!> <!> <!>",1),lr=i(`Пусть <!> &mdash; последовательность кодов Грея длины <!>.
    Тогда <!> и`,1),sr=i(`где <!> означает новую последовательность,
    полученную путём присоединения <!> перед всеми членами последовательности <!>,
    и <!> означает новую последовательность,
    полученную путём разворачивания всех членов последовательности <!> как строк.`,1),mr=i("Поскольку <!> начинается с <!>, то последовательность",1),ir=i("является перестановкой чисел <!>, задающей коды Грея по их индексам.",1),pr=i("<!> <!> <!> <!> <!> <!> <!>",1),$r=i(`Последовательность кодов Грея можно определить, явно указав члены последовательности <!>,
    каждый член <!> &mdash; код Грея с индексом <!>.`,1),cr=i(`Пусть <!>, где <!>.
    Тогда можно воспользоваться рекуррентным соотношением и получить, что`,1),gr=i("Отсюда можно вывести приятную формулу вычисления <!>.",1),hr=i(`Пусть двоичное представление <!>,
    и двоичное представление <!>.
    Тогда`,1),ur=i("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),fr=i("Нужно только понять, какой бит менять на <!>-й итерации.",1),xr=i("<!> &mdash; позиция младшего единичного бита в <!>",1),Pr=i("<!> <!> <!>",1),br=i("Здесь <!> означает <!>-й бит числа <!>.",1),kr=i("<!> <!> <!>",1),jr=i(`<b>Функции Уолша</b> &mdash; функции, введенные Джозефом Леонардом Уолшем для упрощения работы
    с комбинаторными объектами и их генерации.`,1),yr=i("Здесь <!> &mdash; бинарная свёртка чисел <!> и <!>:",1),qr=i("<!> <!> <!> <!> <!> <!>",1),wr=i("<b>Функции Радемахера</b> &mdash; функции, предложенные Гансом Радемахером",1),Rr=i("<!> <!>",1),Gr=i(`Отсюда заключаем, что кратность <!> в <!> представляет собой <!>-й бит числа <!>.
    Тогда`,1),Nr=i("<!> <!> <!> <!>",1),Xr=i("<!> <!>",1),Cr=i(`Вообще получается, что функции Уолша образуют абелеву группу относительно поточечного умножения.
    Из этого факта следует более слабое, но часто встречающееся свойство <!>, где <!> и <!>.`,1),Hr=i("<!> <!> <!> <!> <!> <!> <!>",1),Mr=i(`Код Грея <!> является только одним из множества способов обхода всех бинарных строк
    с изменением только в одном бите за шаг.`,1),Sr=i(`<b>Цикл Грея</b> &mdash; последовательность бинарных строк <!> такая,
    что <!> отличается от <!> только в одном бите.
    Получается, что цикл Грея является гамильтоновым циклом в бинарном <!>-мерном кубе.`,1),Tr=i("<!> <!> <!> <!>",1),Zr=i(`Будем рассматривать битовые строки <!> как числа,
    записанные в двоичной системе счисления.`,1),zr=i("<b>Дельта-последовательность</b> &mdash; последовательность чисел <!>, для которых",1),Ar=i(`Дельта-последовательность показывает, какие биты надо менять на каком шаге.
    Например, для обычного кода Грея <!> дельта-последовательность
    определяется как <!>,
    но последнее значение <!>, а не <!>.`,1),Br=i("<!> <!> <!> <!>",1),Dr=i(`Пусть <!> &mdash;
    дельта-последовательность для <!>-битного цикла Грея, причем
    каждое <!> является одной координатой,
    каждое <!> является последовательностью координат, возможно пустой,
    и <!> нечётное. Тогда`,1),Er=i("<!> <!>",1),Fr=i(`<b>Количества переходов</b> дельта-последовательности <!> &mdash;
    кортеж <!>, в котором`,1),Ir=i("<!> <!> <!> <!>",1),Jr=i("Для любого <!> существует цикл Грея с количествами переходов <!>, для которых",1),Kr=i("<!> <!> <!>",1),Lr=i(`<b>Наилучшая сбалансированность.</b> Каждое количество переходов <!> должно быть чётным числом,
    и <!>.`,1),Or=i(`Условие <!> для <!> выполняется тогда и только тогда, когда <!> количеств равны <!> и <!> количеств равны <!>,
    где <!> и <!>.`,1),Qr=i("<!> <!>",1),Ur=i("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function lo(_r){var X=Ur(),C=g(X);G(C,{children:(p,b)=>{a();var n=P("Код Грея и бинарные строки");_(p,n)}});var H=r(C,2);y(H,{children:(p,b)=>{var n=vr(),l=g(n);m(l,{children:($,t)=>{a();var v=P(`Часто порядок генерации кортежей бывает важен.
    Разберем здесь генерацию бинарных строк таким образом, чтобы каждая следующая строка отличалась от предыдущей ровно
    в однои бите.
    Такой способ кодирования называется кодом Грея.`);_($,v)}});var s=r(l,2);m(s,{children:($,t)=>{a();var v=tr(),e=r(g(v));o(e,{m:"n = 4"}),_($,v)}});var h=r(s,2);o(h,{display:!0,m:`\\align{
0000, \\quad 0001&, \\quad 0011, \\quad 0010, \\quad 0110, \\quad 0111, \\quad 0101, \\quad 0100, \\\\
1100, \\quad 1101&, \\quad 1111, \\quad 1110, \\quad 1010, \\quad 1011, \\quad 1001, \\quad 1000}`}),_(p,n)}});var M=r(H,2);y(M,{children:(p,b)=>{var n=pr(),l=g(n);m(l,{children:(d,u)=>{a();var c=P("Код Грея можно задать рекурсивно.");_(d,c)}});var s=r(l,2);m(s,{children:(d,u)=>{a();var c=lr(),f=r(g(c));o(f,{m:"\\Gamma_n"});var j=r(f,2);o(j,{m:"n"});var x=r(j,2);o(x,{m:"\\Gamma_0 = \\epsilon"}),a(),_(d,c)}});var h=r(s,2);o(h,{display:!0,m:"\\Gamma_{n+1} = 0 \\, \\Gamma_n, ~ 1 \\, \\Gamma_n^\\R"});var $=r(h,2);m($,{children:(d,u)=>{a();var c=sr(),f=r(g(c));o(f,{m:"a \\, X"});var j=r(f,2);o(j,{m:"a"});var x=r(j,2);o(x,{m:"X"});var q=r(x,2);o(q,{m:"X^\\R"});var k=r(q,2);o(k,{m:"X"}),a(),_(d,c)}});var t=r($,2);m(t,{children:(d,u)=>{a();var c=mr(),f=r(g(c));o(f,{m:"\\Gamma_{n+1}"});var j=r(f,2);o(j,{m:"0 \\, \\Gamma_n"}),a(),_(d,c)}});var v=r(t,2);o(v,{display:!0,m:"\\Gamma_\\oo = g(0),~ g(1),~ g(2),~ g(3),~ g(4),~ \\dotsc = 0,~ 1,~ 11,~ 10,~ 110,~ \\dotsc"});var e=r(v,2);m(e,{children:(d,u)=>{a();var c=ir(),f=r(g(c));o(f,{m:"\\NN_0"}),a(),_(d,c)}}),_(p,n)}});var S=r(M,2);y(S,{children:(p,b)=>{var n=ur(),l=g(n);m(l,{children:(x,q)=>{a();var k=$r(),w=r(g(k));o(w,{m:"\\Gamma_\\oo"});var R=r(w,2);o(R,{m:"g(j)"});var nr=r(R,2);o(nr,{m:"j"}),a(),_(x,k)}});var s=r(l,2);m(s,{children:(x,q)=>{a();var k=cr(),w=r(g(k));o(w,{m:"j = 2^k + r"});var R=r(w,2);o(R,{m:"0 \\le r < 2^k"}),a(),_(x,k)}});var h=r(s,2);o(h,{display:!0,m:"g \\bigl( 2^k + r \\bigr) = 2^k + g \\bigl( 2^k - r - 1 \\bigr)"});var $=r(h,2);m($,{children:(x,q)=>{a();var k=gr(),w=r(g(k));o(w,{m:"g(j)"}),a(),_(x,k)}});var t=r($,2);m(t,{children:(x,q)=>{a();var k=hr(),w=r(g(k));o(w,{m:"j = \\bigl( \\dotsm j_2 \\, j_1 \\, j_0 \\bigr)_2"});var R=r(w,2);o(R,{m:"g(j) = \\bigl( \\dotsm g_2 \\, g_1 \\, g_0 \\bigr)_2"}),a(),_(x,k)}});var v=r(t,2);o(v,{display:!0,m:"g_k = j_k \\oplus j_{k+1} \\qquad \\text{для всех}~ k \\ge 0"});var e=r(v,2);m(e,{children:(x,q)=>{a();var k=P("Имеет место и обратная формула");_(x,k)}});var d=r(e,2);o(d,{display:!0,m:`j_k = g_k \\oplus g_{k+1} \\oplus g_{k+2} \\oplus g_{k+3} \\oplus \\dotsb
          = \\bigoplus_{i=0}^\\oo g_{k+i} \\qquad \\text{для всех}~ k \\ge 0`});var u=r(d,2);m(u,{children:(x,q)=>{a();var k=P(`С помощью этих двух формул можно получить способ
    очень легко и быстро вычислять код Грея и номер кода Грея с помощью битовой арифметики`);_(x,k)}});var c=r(u,2);o(c,{display:!0,m:"g(j) = j \\oplus \\lfloor j/2 \\rfloor"});var f=r(c,2);o(f,{display:!0,m:"j = g(j) \\oplus \\lfloor g(j)/2 \\rfloor \\oplus \\lfloor g(j)/4 \\rfloor \\oplus \\dotsb = \\bigoplus_{i=0}^\\oo \\left\\lfloor \\frac{g(j)}{2^i} \\right\\rfloor"});var j=r(f,2);m(j,{children:(x,q)=>{a();var k=P("В коде ещё проще");_(x,k)}}),_(p,n)}});var T=r(S,2);or(T,{language:"cpp",code:`unsigned int to_gray_code(unsigned int n) {
    return n ^ (n >> 1);
}

unsigned int from_gray_code(unsigned int gray) {
    unsigned int n = gray;
    while (gray >>= 1) {
        n ^= gray;
    }
    return n;
}`});var Z=r(T,2);y(Z,{children:(p,b)=>{var n=Pr(),l=g(n);m(l,{children:($,t)=>{a();var v=P(`На основе кодов Грея можно сделать генератор всех битовых строк фиксированной длины,
    при этом каждую итерацию изменяться будет только один бит в выдаваемой строке.`);_($,v)}});var s=r(l,2);m(s,{children:($,t)=>{a();var v=fr(),e=r(g(v));o(e,{m:"k"}),a(),_($,v)}});var h=r(s,2);m(h,{children:($,t)=>{var v=xr(),e=g(v);o(e,{m:"\\rho(k)"});var d=r(e,2);o(d,{m:"k"}),_($,v)}}),_(p,n)}});var z=r(Z,2);or(z,{code:`generator binary_tuples(int n) -> tuple[bool]:
    array[bool] bits = [0, 0, ..., 0]

    yield tuple(bits)

    for int i = 1; i < 2 ** n; i++:
        change_bit = (i ^ (i >> 1)) ^ ((i-1) ^ ((i-1) >> 1))
        pos = change_bit.bit_length() - 1
        bits[pos] ^= 1
        yield tuple(bits)`});var A=r(z,2);G(A,{children:(p,b)=>{a();var n=P("Функции Уолша и Радемахера");_(p,n)}});var B=r(A,2);y(B,{children:(p,b)=>{var n=kr(),l=g(n);m(l,{children:($,t)=>{a();var v=P("Здесь безумно часто будет необходимо получить конкретный бит числа. Поэтому я сразу введу обозначения");_($,v)}});var s=r(l,2);o(s,{display:!0,m:`g(k) = \\bigl( \\dotsm g_3 \\, g_2 \\, g_1 \\, g_0 \\bigr)_2 \\quad\\text{и}\\quad
          x = \\bigl( \\dotsm x_3 \\, x_2 \\, x_1 \\, x_0 \\bigr)_2`});var h=r(s,2);m(h,{children:($,t)=>{a();var v=br(),e=r(g(v));o(e,{m:"x_j"});var d=r(e,2);o(d,{m:"j"});var u=r(d,2);o(u,{m:"x"}),a(),_($,v)}}),_(p,n)}});var D=r(B,2);y(D,{children:(p,b)=>{var n=qr(),l=g(n);m(l,{children:(e,d)=>{var u=jr();a(),_(e,u)}});var s=r(l,2);o(s,{display:!0,m:`w_0(x) = 1 \\quad\\text{и}\\quad
          w_k(x) = (-1)^{x \\bmod 2} \\cdot w_{\\lfloor k/2 \\rfloor} ( \\lfloor x/2 \\rfloor )
          \\quad\\text{для}~ k > 0`});var h=r(s,2);m(h,{children:(e,d)=>{a();var u=P("Функции Уолша классически определяют как раз через код Грея и бинарную свёртку.");_(e,u)}});var $=r(h,2);o($,{display:!0,m:"w_k(x) = (-1) ^ {g(k) \\circledast x}"});var t=r($,2);m(t,{children:(e,d)=>{a();var u=yr(),c=r(g(u));o(c,{m:"g(k) \\circledast x"});var f=r(c,2);o(f,{m:"g(k)"});var j=r(f,2);o(j,{m:"x"}),a(),_(e,u)}});var v=r(t,2);o(v,{display:!0,m:"g(x) \\circledast x = \\sum_{j=0}^\\oo g_j \\cdot x_j"}),_(p,n)}});var E=r(D,2);y(E,{children:(p,b)=>{var n=Rr(),l=g(n);m(l,{children:(h,$)=>{var t=wr();a(),_(h,t)}});var s=r(l,2);o(s,{display:!0,m:"r_k(x) = (-1)^{x_k}"}),_(p,n)}});var F=r(E,2);N(F,{children:(p,b)=>{a();var n=P("Связь с кодами Грея");_(p,n)}});var I=r(F,2);y(I,{children:(p,b)=>{var n=Nr(),l=g(n);m(l,{children:(t,v)=>{a();var e=P("Из этих свойств можно получить важное соотношение между функциями Уолша и функциями Радемахера");_(t,e)}});var s=r(l,2);o(s,{display:!0,m:"w_k(x) = \\prod_{j=0}^\\oo r_j(x)^{g_j}"});var h=r(s,2);m(h,{children:(t,v)=>{a();var e=Gr(),d=r(g(e));o(d,{m:"r_j(x)"});var u=r(d,2);o(u,{m:"w_k(x)"});var c=r(u,2);o(c,{m:"j"});var f=r(c,2);o(f,{m:"g(k)"}),a(),_(t,e)}});var $=r(h,2);o($,{display:!0,m:"w_{k}(x) = r_{\\rho(k)+1}(x) \\cdot w_{k-1}(x) \\quad \\text{для}~ k > 0"}),_(p,n)}});var J=r(I,2);N(J,{children:(p,b)=>{a();var n=P("Ортогональность");_(p,n)}});var K=r(J,2);y(K,{children:(p,b)=>{var n=Xr(),l=g(n);m(l,{children:(h,$)=>{a();var t=P("И функции Уолша, и функции Радемахера ортогональны");_(h,t)}});var s=r(l,2);o(s,{display:!0,m:"\\frac{1}{2^n} \\sum_{x=0}^{2^n-1} w_a(x) \\cdot w_b(x) = [a = b] \\quad\\text{и}\\quad \\frac{1}{2^n} \\sum_{x=0}^{2^n-1} r_a(x) \\cdot r_b(x) = [a = b]"}),_(p,n)}});var L=r(K,2);y(L,{children:(p,b)=>{var n=Hr(),l=g(n);m(l,{children:(d,u)=>{a();var c=P("Функции Радемахера мультипликативны");_(d,c)}});var s=r(l,2);o(s,{display:!0,m:"r_k^{a + b}(x) = r_k^{a \\oplus b}(x)"});var h=r(s,2);m(h,{children:(d,u)=>{a();var c=P("Из мультипликативности функций Радемахера следует групповой закон для функций Уолша");_(d,c)}});var $=r(h,2);o($,{display:!0,m:"w_a(x) \\cdot w_b(x) = w_{a \\oplus b}(x)"});var t=r($,2);m(t,{children:(d,u)=>{a();var c=Cr(),f=r(g(c));o(f,{m:"w_n(x) = w_{2^k}(x) \\cdot w_r(x)"});var j=r(f,2);o(j,{m:"n = 2^k + r"});var x=r(j,2);o(x,{m:"0 \\le r < 2^k"}),a(),_(d,c)}});var v=r(t,2);m(v,{children:(d,u)=>{a();var c=P("А ещё, группа функций Уошла изоморфна натуральным числам с операцией побитового исключающего или");_(d,c)}});var e=r(v,2);o(e,{display:!0,m:"\\bigl( \\{ w_k : k \\in \\N_0 \\}, \\cdot \\bigr) \\isom (\\NN_0, \\oplus) \\isom \\ZZ_2^\\oo"}),_(p,n)}});var O=r(L,2);G(O,{children:(p,b)=>{a();var n=P("Циклы Грея");_(p,n)}});var Q=r(O,2);y(Q,{children:(p,b)=>{var n=Tr(),l=g(n);m(l,{children:(t,v)=>{a();var e=Mr(),d=r(g(e));o(d,{m:"g(\\cdot)"}),a(),_(t,e)}});var s=r(l,2);m(s,{children:(t,v)=>{var e=Sr(),d=r(g(e),2);o(d,{m:"v_0, v_1, v_2, \\dotsc, v_{2^n-1}"});var u=r(d,2);o(u,{m:"v_k"});var c=r(u,2);o(c,{m:"v_{(k+1) \\bmod 2^n}"});var f=r(c,2);o(f,{m:"n"}),a(),_(t,e)}});var h=r(s,2);m(h,{children:(t,v)=>{a();var e=P("Поскольку цикл Грея является гамильтоновым циклом, можно выбрать индексы так, чтобы");_(t,e)}});var $=r(h,2);o($,{display:!0,m:"v_0 = 000 \\dotsm 00"}),_(p,n)}});var U=r(Q,2);y(U,{children:(p,b)=>{var n=Br(),l=g(n);m(l,{children:(t,v)=>{a();var e=Zr(),d=r(g(e));o(d,{m:"v_0, v_1, \\dotsc, v_{2^n-1}"}),a(),_(t,e)}});var s=r(l,2);m(s,{children:(t,v)=>{var e=zr(),d=r(g(e),2);o(d,{m:"\\delta_k"}),a(),_(t,e)}});var h=r(s,2);o(h,{display:!0,m:"v_{(k+1) \\bmod 2^n} = v_k \\oplus 2^{\\delta_k}"});var $=r(h,2);m($,{children:(t,v)=>{a();var e=Ar(),d=r(g(e));o(d,{m:"g(\\cdot)"});var u=r(d,2);o(u,{m:"\\delta_k = \\rho(k+1)"});var c=r(u,2);o(c,{m:"\\delta_{2^n-1} = n-1"});var f=r(c,2);o(f,{m:"n"}),a(),_(t,e)}}),_(p,n)}});var V=r(U,2);ar(V,{title:"Расширение цикла Грея",children:(p,b)=>{var n=Er(),l=g(n);m(l,{children:(h,$)=>{a();var t=Dr(),v=r(g(t));o(v,{m:"\\alpha_1 \\, j_1 \\, \\alpha_2 \\, j_2 \\dotsm \\alpha_l \\, j_l"});var e=r(v,2);o(e,{m:"n"});var d=r(e,2);o(d,{m:"j_k"});var u=r(d,2);o(u,{m:"\\alpha_k"});var c=r(u,2);o(c,{m:"l"}),a(),_(h,t)}});var s=r(l,2);o(s,{display:!0,m:"\\alpha_1 \\, (n+1) \\, \\alpha_1^\\R \\, n \\, \\alpha_1 \\,\\, j_1 \\,\\, \\alpha_2 \\, n \\, \\alpha_2^\\R \\, (n+1) \\alpha_2 \\,\\, j_2 \\,\\, \\alpha_3 \\, (n+1) \\, \\alpha_3^\\R \\, n \\alpha_3 \\,\\, j_3 \\,\\, \\cdots \\,\\, j_{l-1} \\,\\, \\alpha_l \\, (n+1) \\, \\alpha_l^\\R \\, n \\, \\alpha_l \\,\\, (n+1) \\, \\alpha_l^\\R \\, j_{l-1} \\, \\alpha_{l-1}^\\R \\, j_{l-2} \\, \\cdots \\, \\alpha_2^\\R \\, j_1 \\alpha_1^\\R \\, n"}),_(p,n)}});var W=r(V,2);N(W,{children:(p,b)=>{a();var n=P("Количества переходов");_(p,n)}});var Y=r(W,2);y(Y,{children:(p,b)=>{var n=Ir(),l=g(n);m(l,{children:(t,v)=>{var e=Fr(),d=r(g(e),2);o(d,{m:"\\delta_0, \\delta_1, \\delta_2, \\dotsc, \\delta_{2^n-1}"});var u=r(d,2);o(u,{m:"(c_0, c_1, c_2, \\dotsc, c_{n-1})"}),a(),_(t,e)}});var s=r(l,2);o(s,{display:!0,m:"c_j = \\bigl( \\text{количество раз, когда}~ \\delta_k = j \\bigr)"});var h=r(s,2);m(h,{children:(t,v)=>{a();var e=P("Количества переходов выражают частоту изменения битов с определенными номерами.");_(t,e)}});var $=r(h,2);m($,{children:(t,v)=>{a();var e=P(`Можно аккуратно выбрать дельта-последовательность,
    чтобы в итоге получить более-менее сбалансированные количества переходов.`);_(t,e)}}),_(p,n)}});var rr=r(Y,2);ar(rr,{title:"Наилучшее условие сбалансированности",children:(p,b)=>{var n=Kr(),l=g(n);m(l,{children:($,t)=>{a();var v=Jr(),e=r(g(v));o(e,{m:"n"});var d=r(e,2);o(d,{m:"(c_0, c_1, c_2, \\dotsc, c_{n-1})"}),a(),_($,v)}});var s=r(l,2);o(s,{display:!0,m:"|c_j - c_k| \\le 2 \\quad\\text{для}~ 0 \\le j < k < n"});var h=r(s,2);m(h,{children:($,t)=>{a();var v=P("Причём это условие сбалансированности является наилучшим.");_($,v)}}),_(p,n)}});var er=r(rr,2);dr(er,{children:(p,b)=>{y(p,{children:(n,l)=>{var s=Qr(),h=g(s);m(h,{children:(t,v)=>{var e=Lr(),d=r(g(e),2);o(d,{m:"c_j"});var u=r(d,2);o(u,{m:"c_0 + c_1 + c_2 + \\dotsb + c_{n-2} + c_{n-1} = 2^n"}),a(),_(t,e)}});var $=r(h,2);m($,{children:(t,v)=>{a();var e=Or(),d=r(g(e));o(d,{m:"|c_j - c_k| \\le 2"});var u=r(d,2);o(u,{m:"0 \\le j < k < n"});var c=r(u,2);o(c,{m:"n-r"});var f=r(c,2);o(f,{m:"2q"});var j=r(f,2);o(j,{m:"r"});var x=r(j,2);o(x,{m:"2q+2"});var q=r(x,2);o(q,{m:"q = \\lfloor 2^{n-1} / n \\rfloor"});var k=r(q,2);o(k,{m:"r = 2^{n-1} \\bmod n"}),a(),_(t,e)}}),_(n,s)}})}}),_(_r,X)}export{lo as component};
