import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as s,a as l,b as e,s as r,n as a,t as j}from"../chunks/BWp35gWV.js";import{T as V}from"../chunks/CR7k0xtG.js";import{P as q}from"../chunks/DPzc5wQr.js";import{P as p}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";import{C}from"../chunks/BmgYHZay.js";import{C as B}from"../chunks/BvAJckrt.js";import{H as W}from"../chunks/DXKx2xvL.js";import{S as N}from"../chunks/CBbFRhrb.js";var X=s(`Мы хотим создать такую структуру данных, в которую можно будет добавлять объекты
    и пытаться определять наличие в ней объектов.
    На запрос &laquo;есть ли в множестве объект <!>?&raquo; можно получить или определенный
    отрицательный ответ &laquo;объекта <!> точно нет&raquo; или неопределенный положительный ответ
    &laquo;объект <!>, возможно, в множестве есть&raquo;.`,1),Y=s("Пусть все наши объекты &mdash; элементы какого-то универсума <!>.",1),Z=s("<!> <!> <!> <!>",1),rr=s(`Реализацией нашей идеи служит структура <b>фильтр Блума</b> (Bloom filter).
    Эта структура данных использует хеширование.`,1),or=s(`Заведем битовый массив <!>, состоящий из <!> элементов.
    Этот битовый массив будет хранить информацию о наличии и отсутствии объектов в нашем множестве.`,1),ar=s("Создадим еще <!> независимых хеш-функций <!>.",1),er=s("<!> <!> <!>",1),nr=s("При добавлении элемента <!> в множество нужно записать <!> в массив <!> на каждую из позиций <!>.",1),tr=s("Временная сложность выполнения операции &mdash; <!>.",1),_r=s(`Чтобы проверить, что элемент <!> принадлежит множеству, нужно проверить,
    что все биты в массиве <!> на позициях <!> установлены в <!>.
    Если хотя бы один бит равен <!>, то элемента <!> в множестве быть не может.`,1),dr=s("Временная сложность выполнения операции &mdash; <!>.",1),vr=s(`Как уже упоминалось выше, операция <!> может вернуть или определенный отрицательный ответ,
    или неопределенный положительный.
    Из-за этого свойства фильтр Блума нельзя использовать напрямую, если важна точность.
    Но он очень сильно пригождается тогда, когда надо выполнять много дорогостоящих запросов к другой структуре.`,1),mr=s("<!> <!>",1),sr=s(`Давайте посчитаем вероятность ложного положительного срабатывания операции <!>.
    Как и прежде, размер битового массива <!>, количество хеш-функций <!>.
    Пусть в нашем множестве уже содержится <!> элементов.`,1),ir=s("Посчитаем вероятность того, что конкретный бит <!> не будет установлен в <!> хеш-функцией <!> при вставке очередного элемента <!>.",1),lr=s("Тогда для <!> хеш-функций вероятность того, что конкретный бит <!> не будет установлен в <!> равна",1),pr=s("Теперь можем посчитать вероятность того, что <!>-ый бит будет равен <!> после вставки <!> элементов в изначально пустой фильтр Блума",1),cr=s(`Ложное положительное срабатывание <!> происходит тогда,
    когда для несуществующего элемента <!> все <!> бит окажутся ненулевыми.
    Вероятность такого события равна`,1),$r=s("<!> <!> <!> <!> <!> <!> <!> <!> <!>",1),hr=s(`Можно вычислить оптимальное значение <!>, которое минимизирует ошибку.
    В таком виде задача минимизации не решается, придется прибегнуть к асимптотическим оценкам.
    Используя второй замечательный предел, можно упростить`,1),fr=s(`И вот уже в такой форме можно найти такое <!>, при котором вероятность ошибки минимальная.
    Достаточно прологарифмировать вероятность ошибки и найти ноль производной. В итоге получается`,1),gr=s("Подставив это значение <!> можно найти эту самую минимальную вероятность ошибки",1),xr=s("<!> <!> <!> <!> <!> <!> <!> <!>",1),Pr=s("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Or(Q){var H=Pr(),M=l(H);V(M,{title:"Фильтр Блума"});var O=r(M,2);q(O,{children:(i,u)=>{var n=Z(),h=l(n);p(h,{children:(t,v)=>{a();var m=j(`Вспомним про абстрактную структуру данных множество.
    Для её адекватной реализации в любом случае требуется достаточно много памяти.
    Мы можем попытаться ослабить это требования за счёт возможности ошибаться.`);e(t,m)}});var _=r(h,2);p(_,{children:(t,v)=>{a();var m=X(),f=r(l(m));o(f,{m:"x"});var k=r(f,2);o(k,{m:"x"});var g=r(k,2);o(g,{m:"x"}),a(),e(t,m)}});var d=r(_,2);p(d,{children:(t,v)=>{a();var m=Y(),f=r(l(m));o(f,{m:"\\UUU"}),a(),e(t,m)}});var c=r(d,2);p(c,{children:(t,v)=>{a();var m=j("Про удаление объектов из нашей структуры пока не думаем и не говорим.");e(t,m)}}),e(i,n)}});var S=r(O,2);q(S,{children:(i,u)=>{var n=er(),h=l(n);p(h,{children:(c,t)=>{a();var v=rr();a(2),e(c,v)}});var _=r(h,2);p(_,{children:(c,t)=>{a();var v=or(),m=r(l(v));o(m,{m:"b \\in \\{0, 1\\}^m"});var f=r(m,2);o(f,{m:"m"}),a(),e(c,v)}});var d=r(_,2);p(d,{children:(c,t)=>{a();var v=ar(),m=r(l(v));o(m,{m:"k"});var f=r(m,2);o(f,{m:"h_1, h_2, \\dotsc, h_k \\colon \\UUU \\surjto \\{1, 2, \\dotsb, m\\}"}),a(),e(c,v)}}),e(i,n)}});var T=r(S,2);B(T,{code:`const array h[k]
array[bool] b[m]`});var w=r(T,2);N(w,{children:(i,u)=>{a();var n=j("Добавление элемента");e(i,n)}});var z=r(w,2);q(z,{children:(i,u)=>{p(i,{children:(n,h)=>{a();var _=nr(),d=r(l(_));o(d,{m:"x"});var c=r(d,2);o(c,{m:"1"});var t=r(c,2);o(t,{m:"b"});var v=r(t,2);o(v,{m:"h_1(x), h_2(x), \\dotsc, h_k(x)"}),a(),e(n,_)}})}});var A=r(z,2);B(A,{code:`function add(x):
    for int i = 0; i < k:
        int index = h[i](x)
        b[index] = true`});var D=r(A,2);q(D,{children:(i,u)=>{p(i,{children:(n,h)=>{a();var _=tr(),d=r(l(_));o(d,{m:"O(k)"}),a(),e(n,_)}})}});var E=r(D,2);N(E,{children:(i,u)=>{a();var n=j("Проверка наличия");e(i,n)}});var F=r(E,2);q(F,{children:(i,u)=>{p(i,{children:(n,h)=>{a();var _=_r(),d=r(l(_));o(d,{m:"x"});var c=r(d,2);o(c,{m:"b"});var t=r(c,2);o(t,{m:"h_1(x), h_2(x), \\dotsc, h_k(x)"});var v=r(t,2);o(v,{m:"1"});var m=r(v,2);o(m,{m:"0"});var f=r(m,2);o(f,{m:"x"}),a(),e(n,_)}})}});var G=r(F,2);B(G,{code:`function check(x) -> bool:
    bool contains = true
    for int i = 0; i < k:
        int index = h[i](x)
        contains &= b[index]

    return contains`});var I=r(G,2);q(I,{children:(i,u)=>{p(i,{children:(n,h)=>{a();var _=dr(),d=r(l(_));o(d,{m:"O(k)"}),a(),e(n,_)}})}});var J=r(I,2);q(J,{children:(i,u)=>{var n=mr(),h=l(n);p(h,{children:(d,c)=>{a();var t=vr(),v=r(l(t));C(v,{c:"check(x)"}),a(),e(d,t)}});var _=r(h,2);p(_,{children:(d,c)=>{a();var t=j(`Например, есть у нас какая-то база данных (на самом деле любая структура данных) с дорогим доступом к элементам.
    Создадим поверх этой базы фильтр Блума, добавив в него все элементы, которые есть в базе данных.
    Теперь, когда нам приходит запрос к несуществующим данным, мы его отфильтруем фильтром Блума
    и не пустим дальше к базе данных.
    В итоге у нас значительно уменьшилось количество дорогостоящих запросов к базе данных
    ценой небольшого количества дополнительной памяти на фильтр.`);e(d,t)}}),e(i,n)}});var K=r(J,2);W(K,{children:(i,u)=>{a();var n=j("Вероятность ошибки и её минимизация");e(i,n)}});var L=r(K,2);q(L,{children:(i,u)=>{var n=$r(),h=l(n);p(h,{children:(g,x)=>{a();var $=sr(),P=r(l($));C(P,{c:"check(x)"});var b=r(P,2);o(b,{m:"m"});var y=r(b,2);o(y,{m:"k"});var U=r(y,2);o(U,{m:"n"}),a(),e(g,$)}});var _=r(h,2);p(_,{children:(g,x)=>{a();var $=ir(),P=r(l($));o(P,{m:"j"});var b=r(P,2);o(b,{m:"1"});var y=r(b,2);o(y,{m:"h_i"});var U=r(y,2);o(U,{m:"x"}),a(),e(g,$)}});var d=r(_,2);o(d,{display:!0,m:"\\prob \\big( h_i(x) \\neq j \\big) = 1 - \\frac{1}{m}"});var c=r(d,2);p(c,{children:(g,x)=>{a();var $=lr(),P=r(l($));o(P,{m:"k"});var b=r(P,2);o(b,{m:"j"});var y=r(b,2);o(y,{m:"1"}),a(),e(g,$)}});var t=r(c,2);o(t,{display:!0,m:"\\prob \\big( h_i(x) \\neq j \\? \\forall i \\big) = \\left( 1 - \\frac{1}{m} \\right)^k"});var v=r(t,2);p(v,{children:(g,x)=>{a();var $=pr(),P=r(l($));o(P,{m:"j"});var b=r(P,2);o(b,{m:"0"});var y=r(b,2);o(y,{m:"n"}),a(),e(g,$)}});var m=r(v,2);o(m,{display:!0,m:"\\prob \\big( b[j] = 0 \\big) = \\left( 1 - \\frac{1}{m} \\right)^{kn}"});var f=r(m,2);p(f,{children:(g,x)=>{a();var $=cr(),P=r(l($));C(P,{c:"check(x)"});var b=r(P,2);o(b,{m:"x"});var y=r(b,2);o(y,{m:"k"}),a(),e(g,$)}});var k=r(f,2);o(k,{display:!0,m:"\\prob (\\text{ложное срабатывание}) = \\Bigg( 1 - \\left( 1 - \\frac{1}{m} \\right)^{kn} \\Bigg)^k"}),e(i,n)}});var R=r(L,2);q(R,{children:(i,u)=>{var n=xr(),h=l(n);p(h,{children:(k,g)=>{a();var x=hr(),$=r(l(x));o($,{m:"k"}),a(),e(k,x)}});var _=r(h,2);o(_,{display:!0,m:"\\left( 1 - \\frac{1}{m} \\right)^{kn} \\approx e^{-kn/m}"});var d=r(_,2);p(d,{children:(k,g)=>{a();var x=j("Тогда");e(k,x)}});var c=r(d,2);o(c,{display:!0,m:"\\prob (\\text{ошибка}) \\approx \\left( 1 - e^{-kn/m} \\right)^k"});var t=r(c,2);p(t,{children:(k,g)=>{a();var x=fr(),$=r(l(x));o($,{m:"k"}),a(),e(k,x)}});var v=r(t,2);o(v,{display:!0,m:"\\argmin_k \\prob (\\text{ошибка}) \\approx \\frac{m}{n} \\cdot \\ln 2"});var m=r(v,2);p(m,{children:(k,g)=>{a();var x=gr(),$=r(l(x));o($,{m:"k"}),a(),e(k,x)}});var f=r(m,2);o(f,{display:!0,m:"\\min \\prob (\\text{ошибка}) \\approx \\left( 1 - \\frac{1}{e} \\right) ^{m/n \\cdot \\ln 2}"}),e(i,n)}}),e(Q,H)}export{Or as component};
