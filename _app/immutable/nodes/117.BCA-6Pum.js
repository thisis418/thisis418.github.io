import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as $,a as c,b as t,s as o,n as s,t as l}from"../chunks/B1HoO4k0.js";import{T as D}from"../chunks/CcX1cm_-.js";import{P as _}from"../chunks/B8FEnsbH.js";import{P as f}from"../chunks/ClksMsit.js";import{C as b}from"../chunks/0Rd6UPhr.js";import{M as g}from"../chunks/e5qaD0UW.js";/* empty css                */import{B as G}from"../chunks/Dv4xhkGP.js";import{L as J}from"../chunks/_RU5sT8R.js";/* empty css                *//* empty css                */import{H as u}from"../chunks/VyKLllFE.js";import{S as K}from"../chunks/D2QCM4hc.js";import{E as N}from"../chunks/Swjzo_E6.js";import{E as Q}from"../chunks/C0Z7FaNC.js";var R=$("<b>Стек</b> &mdash; линейный список, в котором вставка и удаление выполняются только на одном конце.",1),U=$(`<b>Очередь</b> &mdash; линейный список, в котором вставка происходит в один конец, а удаление (извлечение) из
    другого конца.`,1),V=$(`<b>Дек</b> &mdash; линейный список, в котором доступ, вставка и удаление могут выполняться на обоих концах.
    Дек, получается, может выполнять функции и стека, и очереди.`,1),W=$("<!> <!> <!>",1),X=$("<!> <!> <!>",1),Y=$("<!> &mdash; проверка, является ли стек пустым",1),Z=$("<!> &mdash; помещение <!> на верх стека",1),rr=$("<!> &mdash; извлечение объекта с верха стека",1),or=$("<!> <!> <!>",1),ar=$(`Для стека, содержащего <!> элементов, потребуется в любом случае память <!>,
    ведь все эти элементы надо как-то хранить.`,1),tr=$("<!> <!> <!>",1),er=$(`Покажите, что с помощью стека можно получить
    перестановку <!> чисел <!> только в том случае, если не существует таких индексов <!> таких,
    что <!>.`,1),nr=$("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Lr(z){var E=nr(),F=c(E);D(F,{title:"Стеки, очереди, деки"});var I=o(F,2);f(I,{children:(a,i)=>{_(a,{children:(r,v)=>{s();var d=l("Разберем разновидности линейных списков, в которых доступ к элементам осуществляется только с концов.");t(r,d)}})}});var T=o(I,2);f(T,{children:(a,i)=>{var r=W(),v=c(r);_(v,{children:(n,p)=>{var e=R();s(),t(n,e)}});var d=o(v,2);_(d,{children:(n,p)=>{var e=U();s(),t(n,e)}});var m=o(d,2);_(m,{children:(n,p)=>{var e=V();s(),t(n,e)}}),t(a,r)}});var j=o(T,2);u(j,{children:(a,i)=>{s();var r=l("Стек");t(a,r)}});var k=o(j,2);f(k,{children:(a,i)=>{var r=X(),v=c(r);_(v,{children:(n,p)=>{s();var e=l(`Элементы в стеке организованы по принципу LIFO (последним вошел — первым вышел).
    Извлекаются элементы из стека в порядке от младшего к старшему,
    то есть первым будет извлекаться тот элемент, который был вставлен в стек позже всех.`);t(n,e)}});var d=o(v,2);_(d,{children:(n,p)=>{s();var e=l(`Можно представить стек как стопку тарелок: класть новую тарелку можно только на верх стопки и забирать
    тарелки можно только с верху стопки. Из середины тарелки вытаскивать нельзя.`);t(n,e)}});var m=o(d,2);_(m,{children:(n,p)=>{s();var e=l(`Когда элемент помещается в стек, говорят, что элемент кладётся на верх стека,
    и забирается, соответственно, тоже с верха.
    Просто удобная терминология.`);t(n,e)}}),t(a,r)}});var B=o(k,2);f(B,{children:(a,i)=>{_(a,{children:(r,v)=>{s();var d=l("Интерфейс стека состоит из трех методов");t(r,d)}})}});var C=o(B,2);G(C,{children:(a,i)=>{J(a,{children:(r,v)=>{var d=or(),m=c(d);_(m,{children:(e,x)=>{var h=Y(),P=c(h);b(P,{c:"empty()"}),s(),t(e,h)}});var n=o(m,2);_(n,{children:(e,x)=>{var h=Z(),P=c(h);b(P,{c:"push(value)"});var L=o(P,2);b(L,{c:"value"}),s(),t(e,h)}});var p=o(n,2);_(p,{children:(e,x)=>{var h=rr(),P=c(h);b(P,{c:"pop() -> value"}),s(),t(e,h)}}),t(r,d)}})}});var H=o(C,2);f(H,{children:(a,i)=>{_(a,{children:(r,v)=>{s();var d=ar(),m=o(c(d));g(m,{m:"n"});var n=o(m,2);g(n,{m:"\\Theta(n)"}),s(),t(r,d)}})}});var M=o(H,2);K(M,{children:(a,i)=>{s();var r=l("Стек на массиве");t(a,r)}});var O=o(M,2);u(O,{children:(a,i)=>{s();var r=l("Очередь");t(a,r)}});var S=o(O,2);f(S,{children:(a,i)=>{var r=tr(),v=c(r);_(v,{children:(n,p)=>{s();var e=l(`В очереди элементы организованы по принципу FIFO (первым пошел — первым вышел).
    Извлекаются элементы из очереди в порядке от старшего к младшему,
    то есть первым будет извлекаться тот элемент, который вошел в очередь раньше всех.`);t(n,e)}});var d=o(v,2);_(d,{children:(n,p)=>{s();var e=l(`Очередь, собственно, работает как нормальная человеческая очередь.
    Человек, который раньше в эту очередь встал, раньше из нее выйдет.`);t(n,e)}});var m=o(d,2);_(m,{children:(n,p)=>{s();var e=l(`Когда элемент помещается в очередь, говорят, что элемент в очередь заходит,
    а при извлечении элемента из очереди он из неё выходит.
    Уже не такая интуитивная терминология, как у стека, но тоже ничего.`);t(n,e)}}),t(a,r)}});var y=o(S,2);u(y,{children:(a,i)=>{s();var r=l("Дек");t(a,r)}});var q=o(y,2);f(q,{children:(a,i)=>{_(a,{children:(r,v)=>{s();var d=l(`В деке все операции с элементами могут выполняться с обоих концов.
    Концы традиционно называют правым и левым.`);t(r,d)}})}});var w=o(q,2);u(w,{children:(a,i)=>{s();var r=l("Упражнения");t(a,r)}});var A=o(w,2);N(A,{children:(a,i)=>{Q(a,{number:1,children:(r,v)=>{f(r,{children:(d,m)=>{_(d,{children:(n,p)=>{s();var e=er(),x=o(c(e));g(x,{m:"(\\sigma_1, \\sigma_2, \\dotsc, \\sigma_n)"});var h=o(x,2);g(h,{m:"(1, 2, \\dotsc, n)"});var P=o(h,2);g(P,{m:"i < j < k"});var L=o(P,2);g(L,{m:"\\sigma_j < \\sigma_k < \\sigma_i"}),s(),t(n,e)}})}})}})}}),t(z,E)}export{Lr as component};
