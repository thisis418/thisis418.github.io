import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as s,a as l,b as e,s as r,n as o,t as u}from"../chunks/BWp35gWV.js";import{T as O}from"../chunks/CR7k0xtG.js";import{P as y}from"../chunks/DPzc5wQr.js";import{P as h}from"../chunks/B7flgP-x.js";/* empty css                *//* empty css                */import{S as F}from"../chunks/CBbFRhrb.js";import{C as Q}from"../chunks/BvAJckrt.js";import"../chunks/i9XClpbl.js";/* empty css                */import{H as R}from"../chunks/DXKx2xvL.js";import{M as a}from"../chunks/BqyEoRxA.js";import{B as U}from"../chunks/CZ1-HcAj.js";import{L as k}from"../chunks/NE91WFFs.js";var V=s(`Давайте рассмотрим довольно простую идею,
        которая открывает нам практически безграничные просторы внешнего поиска.
        Место нашего поиска буду дальше называть диском.
        Вот пусть для поиска в диске мы используем бинарное дерево. Записей у нас <!>.
        Если наше дерево идеально сбалансировано,
        то при поиске нам понадобится сделать <!> обращений к диску.`,1),W=s(`Разделим наши данные в древесной структуре на страницы фиксированного размера, как на рисунке.
        Будем из диска запрашивать не по одному значению, а сразу по страницам.
        Тогда наш поиск ускорится в <!> раз!`,1),X=s("<!> <!> <!> <!>",1),Y=s("<b>B-дерево</b> порядка <!> &mdash; сильноветвящиеся дерево, у которого",1),Z=s("у каждого узла максимум <!> детей",1),rr=s("у каждого узла, кроме корня и листов, минимум <!> детей",1),or=s("корневой узел, если не является листом, имеет минимум <!> ребенка",1),ar=s("любой узел с <!> детьми содержит <!> ключ",1),er=s("<!> <!> <!> <!> <!>",1),tr=s(`B-деревьев порядка <!> не бывает,
        а B-деревья порядка <!> &mdash; это простые бинарные деревья.
        Поэтому будем рассматривать только B-деревья порядка <!> и больше, <!>.`,1),nr=s("<!> <!> <!>",1),_r=s(`Каждый узел B-дерева можно представить как массив из <!> элементов.
        На нечётных позициях стоят ссылки на детей.
        На чётных позициях находятся ключи.`,1),dr=s(`В узлах ключи упорядочены: <!>,
        а каждая ссылка <!> указывает на узел,
        в котором все ключи находятся между ключами <!> и <!> родительского узла.`,1),mr=s("<!> <!> <!> <!>",1),vr=s(`Ключевой характеристикой для B-дерева является высота.
        От нее зависит и временная сложность операций, и количество обращений к диску.
        Пусть в B-дереве хранится <!> ключей. Оценим высоту дерева &mdash; <!>.`,1),lr=s(`В корне минимум <!> ключ и минимум <!> ребёнка.
        В остальных узлах минимум <!> ключей
        и минимум <!> детей.
        Получаем формулу для подсчёта минимального количества ключей в B-дереве высоты <!>:`,1),sr=s("<!> <!> <!> <!> <!> <!> <!> <!> <!>",1),ir=s(`Пусть нам нужно найти ключ <!> в B-дереве.
        Обращаемся к диску, получаем узел и сохраняем его в оперативную память.
        Ищем в этом узле ключ <!>, или ссылку <!>, где <!>.
        Переходим по этой ссылке, получаем новый узел, и продолжаем наш поиск.
        Если мы дошли до листа и не нашли узел <!>, значит его в B-дереве нет.`,1),$r=s("<!> <!>",1),pr=s("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Mr(G){var C=pr(),H=l(C);O(H,{title:"B-деревья"});var M=r(H,2);y(M,{children:(i,q)=>{var n=X(),P=l(n);h(P,{children:(_,d)=>{o();var t=u(`Метода поиска с помощью деревьев больше подходят для задачи внутреннего поиска,
        когда все данные хранятся в оперативной памяти, и нам почти ничего не стоит обращаться к ним много раз.
        Решение задачи внешнего поиска, когда данные хранятся на внешнем накопителе с дорогим доступом,
        требует чуть-чуть иных подходов.`);e(_,t)}});var c=r(P,2);h(c,{children:(_,d)=>{o();var t=u(`Древовидные структуры и деревья всё еще удобны и для внешнего поиска.
        Надо только выбрать способ правильно представить дерева
        и максимально эффективно использовать оперативную память.`);e(_,t)}});var g=r(c,2);h(g,{children:(_,d)=>{o();var t=V(),m=r(l(t));a(m,{m:"1\\,000\\,000"});var f=r(m,2);a(f,{m:"\\log_2 1\\,000\\,000 \\approx 20"}),o(),e(_,t)}});var x=r(g,2);h(x,{children:(_,d)=>{o();var t=W(),m=r(l(t));a(m,{m:"\\log_2 (\\text{высота страницы})"}),o(),e(_,t)}}),e(i,n)}});var S=r(M,2);y(S,{children:(i,q)=>{h(i,{children:(n,P)=>{o();var c=u("...");e(n,c)}})}});var T=r(S,2);R(T,{children:(i,q)=>{o();var n=u("B-деревья");e(i,n)}});var I=r(T,2);y(I,{children:(i,q)=>{var n=nr(),P=l(n);h(P,{children:(x,_)=>{var d=Y(),t=r(l(d),2);a(t,{m:"m"}),o(),e(x,d)}});var c=r(P,2);U(c,{children:(x,_)=>{var d=er(),t=l(d);k(t,{children:(v,K)=>{o();var p=Z(),B=r(l(p));a(B,{m:"m"}),o(),e(v,p)}});var m=r(t,2);k(m,{children:(v,K)=>{o();var p=rr(),B=r(l(p));a(B,{m:"\\lceil m/2 \\rceil"}),o(),e(v,p)}});var f=r(m,2);k(f,{children:(v,K)=>{o();var p=or(),B=r(l(p));a(B,{m:"2"}),o(),e(v,p)}});var $=r(f,2);k($,{children:(v,K)=>{o();var p=u("все листья находятся на одном уровне");e(v,p)}});var b=r($,2);k(b,{children:(v,K)=>{o();var p=ar(),B=r(l(p));a(B,{m:"k"});var L=r(B,2);a(L,{m:"k-1"}),o(),e(v,p)}}),e(x,d)}});var g=r(c,2);h(g,{children:(x,_)=>{o();var d=tr(),t=r(l(d));a(t,{m:"1"});var m=r(t,2);a(m,{m:"2"});var f=r(m,2);a(f,{m:"3"});var $=r(f,2);a($,{m:"m \\ge 3"}),o(),e(x,d)}}),e(i,n)}});var j=r(I,2);y(j,{children:(i,q)=>{var n=mr(),P=l(n);h(P,{children:(_,d)=>{o();var t=_r(),m=r(l(t));a(m,{m:"2m-1"}),o(),e(_,t)}});var c=r(P,2);a(c,{display:!0,m:"\\Big( P_1 \\quad K_1 \\quad P_2 \\quad K_2 \\quad P_3 \\quad K_3 \\quad \\cdots \\quad P_{m-1} \\quad K_{m-1} \\quad P_m \\Big)"});var g=r(c,2);h(g,{children:(_,d)=>{o();var t=u("Вообще, реальный способ хранения отличается от нашего логического представления, но нам удобнее думать так.");e(_,t)}});var x=r(g,2);h(x,{children:(_,d)=>{o();var t=dr(),m=r(l(t));a(m,{m:"K_1 < K_2 < \\dotsb < K_{m-1}"});var f=r(m,2);a(f,{m:"P_i"});var $=r(f,2);a($,{m:"K_{i-1}"});var b=r($,2);a(b,{m:"K_i"}),o(),e(_,t)}}),e(i,n)}});var w=r(j,2);F(w,{children:(i,q)=>{o();var n=u("Высота B-дерева");e(i,n)}});var z=r(w,2);y(z,{children:(i,q)=>{var n=sr(),P=l(n);h(P,{children:($,b)=>{o();var v=vr(),K=r(l(v));a(K,{m:"n"});var p=r(K,2);a(p,{m:"h"}),o(),e($,v)}});var c=r(P,2);h(c,{children:($,b)=>{o();var v=lr(),K=r(l(v));a(K,{m:"1"});var p=r(K,2);a(p,{m:"2"});var B=r(p,2);a(B,{m:"\\lceil m/2 \\rceil - 1"});var L=r(B,2);a(L,{m:"\\lceil m/2 \\rceil"});var N=r(L,2);a(N,{m:"h"}),o(),e($,v)}});var g=r(c,2);a(g,{display:!0,m:"n_{\\mathrm{min}}(h) = 1 + 2 \\cdot n_{\\mathrm{min}}(h-1) \\implies n_{\\mathrm{min}}(h) = 2 \\cdot \\lceil m/2 \\rceil^h - 1"});var x=r(g,2);h(x,{children:($,b)=>{o();var v=u("Аналогично, для максимального количества ключей");e($,v)}});var _=r(x,2);a(_,{display:!0,m:"n_{\\mathrm{max}}(h) = (m-1) + m \\cdot n_{\\mathrm{max}}(h) \\implies n_{\\mathrm{max}}(h) = m^{h+1} - 1"});var d=r(_,2);h(d,{children:($,b)=>{o();var v=u("Тогда из общего неравенства");e($,v)}});var t=r(d,2);a(t,{display:!0,m:"2 \\cdot \\lceil m/2 \\rceil^h - 1 \\le n \\le m^{h+1} - 1"});var m=r(t,2);h(m,{children:($,b)=>{o();var v=u("можно получить неравенство для высоты дерева");e($,v)}});var f=r(m,2);a(f,{display:!0,m:"\\lfloor \\log_m n \\rfloor - 1 \\le h \\le \\left\\lceil \\log_{\\lceil m/2 \\rceil} \\frac{n+1}{2} \\right\\rceil"}),e(i,n)}});var A=r(z,2);F(A,{children:(i,q)=>{o();var n=u("Поиск");e(i,n)}});var D=r(A,2);y(D,{children:(i,q)=>{var n=$r(),P=l(n);h(P,{children:(g,x)=>{o();var _=u("В целом операция поиска в B-дереве аналогична операции поиска в бинарном дереве.");e(g,_)}});var c=r(P,2);h(c,{children:(g,x)=>{o();var _=ir(),d=r(l(_));a(d,{m:"K"});var t=r(d,2);a(t,{m:"K"});var m=r(t,2);a(m,{m:"P_i"});var f=r(m,2);a(f,{m:"K_{i-1} < K < K_i"});var $=r(f,2);a($,{m:"K"}),o(),e(g,_)}}),e(i,n)}});var E=r(D,2);Q(E,{code:`function search(node root, key) -> node:
    ...`});var J=r(E,2);y(J,{children:(i,q)=>{h(i,{children:(n,P)=>{o();var c=u("В целом нам потребуется максимум");e(n,c)}})}}),e(G,C)}export{Mr as component};
