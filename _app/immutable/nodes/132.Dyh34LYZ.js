import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as p,a as $,b as o,s as r,n as a,t as u}from"../chunks/B1HoO4k0.js";import{T as sr}from"../chunks/CcX1cm_-.js";import{P as b}from"../chunks/ClksMsit.js";import{P as i}from"../chunks/B8FEnsbH.js";import{M as A}from"../chunks/e5qaD0UW.js";import{C as t}from"../chunks/0Rd6UPhr.js";import{H as T}from"../chunks/VyKLllFE.js";import{E as or}from"../chunks/BnlOlOSM.js";import{L}from"../chunks/_RU5sT8R.js";import{S as ar}from"../chunks/D2QCM4hc.js";import{C as er}from"../chunks/DunPP-_K.js";import{E as vr}from"../chunks/Swjzo_E6.js";import{E as nr}from"../chunks/C0Z7FaNC.js";var lr=p("<!> <!>",1),cr=p(`Если максимально обобщать, работа аллокаторов сводится к выполнению двух операций &mdash;
    выделения блока памяти <!> и освобождения блока памяти <!>.`,1),ir=p("<!> <!>",1),mr=p("Во время вызова <!> происходит примерно следующее:",1),$r=p("<!> <!> <!>",1),pr=p(`Если найденный блок не совпадает по размеру с запрашиваемым, он делится на два.
    Например, если был запрошен блок в <!> байт, а аллокатор нашёл блок в <!> байта,
    аллокатор поделит найденный блок на два блока &mdash;
    один в <!> байт и второй в <!> байт.`,1),hr=p("<!> <!> <!>",1),gr=p("Во время вызова <!> происходит примерно следующее:",1),fr=p("<!> <!>",1),Pr=p(`Аллокатор был реализован как кольцевой односвязный список.
    В списке хранились блоки памяти с заголовком &mdash; указателем на следующий блок <!>.
    В те времена размер указателя был всего <!> байта.
    Длина блока вычислялась неявно по формуле`,1),ur=p(`Блоки были выровнены по <!> байтам, поэтому младший бит <!> был всегда <!>.
    Его использовали как флаг занятости блока: <!> &mdash; блок свободен, <!> &mdash; блок
    занят.`,1),xr=p(`Когда <!> находил адрес свободного блока,
    он сдвигал его на длину заголовка и возвращал сдвинутый адрес, пряча тем самым заголовок.`,1),Er=p("<!> <!> <!> <!> <!>",1),Ar=p(`Поиск свободного пространства ускорялся за счёт введения блуждающего указателя <!>.
    Этот указатель запоминал позицию, где аллокатор закончил работу в прошлый раз.
    Это ускоряло последующие поиски, так как поиск начинался
    не с начала списка каждый раз, а с места последней операции.`,1),br=p(`Объединение во время выполнения операции <!> не происходит.
    Там просто освобождаемый блок помечается свободным.
    Объединение будет произведено во время следующего обхода списка при выполнении операции <!>.`,1),Mr=p("<!> <!>",1),Or=p(`Накладные расходы на память у такого аллокатора минимальны.
    Но есть две проблемы: невысокая производительность и внешняя фрагментация.
    Быстро накапливаются мелкие свободные блоки, при этом при
    большом количестве свободной памяти какой-нибудь большой кусок выделить невозможно &mdash; просто нет такой
    непрерывной свободной области. Да и слияние блоков во время <!> неэффективно.`,1),Lr=p("<!> <!>",1),Rr=p(`<!> (memory map) &mdash; системный вызов в Unix-подобных системах,
    который отображает файлы или устройства в память процесса.
    Его также используют для анонимного выделения памяти, без привязки к файлу.`,1),Tr=p(`<!> &mdash; желаемый адрес для размещения.
    Если <!>, то ядро выберет адрес само.
    Если не пусто, будет попытка разместить блок памяти по указанному адресу.`,1),Cr=p(`<!> &mdash; размер выделяемой области памяти.
    Округляется вверх до кратного размеру страницы.`,1),Nr=p(`<!> &mdash; флаги защиты памяти (protection flags).
    Определяет права доступа к выделенной памяти, а точнее к странице памяти.
    Можно комбинировать через <!>.<br/> <!> &mdash; чтение, можно читать из памяти;<br/> <!> &mdash; запись, можно записывать в память;<br/> <!> &mdash; исполнение, можно исполнять как код;<br/> <!> &mdash; нет доступа, память полностью недоступна.`,1),Ir=p(`<!> &mdash; тип и свойства памяти.
    Определяет поведение выделенной памяти, а точнее страниц памяти.
    Можно комбинировать через <!>.<br/> <!> &mdash; общее отображение, изменения видны другим процессам и записываются в файл;<br/> <!> &mdash; приватное отображение, изменения не видны другим, используется Copy-on-Write;<br/> <!> &mdash; анонимное отображение, не связанное с файлом, применяется для кучи;<br/> <!> &mdash; точное расположение, требуется разместить точно по <!>, даже если придётся перекрыть какое-то существующее отображение;<br/> <!> &mdash; как и точное расположение, но перекрытие существующих отображений невозможно;<br/> <!> &mdash; сразу выделить физические страницы;<br/> <!> &mdash; заблокировать, страницы не могут быть вытеснены в swap;<br/> <!> &mdash; использовать большие страницы.<br/>`,1),Ur=p(`<!> &mdash; файловый дескриптор для отображения в память.
    Для анонимного отображения должно быть <!>.`,1),Dr=p(`<!> &mdash; смещение в файле, с которого нужно начинать отображение.
    Для анонимного отображения должно быть <!>.`,1),zr=p("<!> <!> <!> <!> <!> <!>",1),Sr=p(`Придумайте последовательность вызовов <!> и <!>, которая заставит
    классический алгоритм first-fit работать за время <!> на каждый вызов <!>.
    Объясните, как блуждающий указатель смягчает эту проблему, но не решает её полностью.`,1),Hr=p("<!> <!>",1),wr=p("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function ro(tr){var C=wr(),N=$(C);sr(N,{title:"Куча"});var I=r(N,2);T(I,{children:(d,x)=>{a();var e=u("Аллокаторы");o(d,e)}});var U=r(I,2);b(U,{children:(d,x)=>{var e=lr(),m=$(e);i(m,{children:(n,f)=>{a();var _=u("Куча структурно представляет собой много блоков памяти, которые или заняты, или свободны.");o(n,_)}});var c=r(m,2);i(c,{children:(n,f)=>{a();var _=u("картинка");o(n,_)}}),o(d,e)}});var D=r(U,2);b(D,{children:(d,x)=>{var e=ir(),m=$(e);i(m,{children:(n,f)=>{a();var _=u(`Самих реализаций аллокаторов много, все отличаются друг от друга структурой хранения блоков,
    стратегией и алгоритмом поиска блоков и самой организации блоков.`);o(n,_)}});var c=r(m,2);i(c,{children:(n,f)=>{a();var _=cr(),h=r($(_));t(h,{c:"malloc"});var s=r(h,2);t(s,{c:"free"}),a(),o(n,_)}}),o(d,e)}});var z=r(D,2);b(z,{children:(d,x)=>{i(d,{children:(e,m)=>{a();var c=mr(),n=r($(c));t(n,{c:"malloc"}),a(),o(e,c)}})}});var S=r(z,2);or(S,{wide:!0,children:(d,x)=>{var e=hr(),m=$(e);L(m,{children:(f,_)=>{var h=$r(),s=$(h);i(s,{children:(l,P)=>{a();var E=u("Среди свободных блоков ищется блок подходящего размера.");o(l,E)}});var g=r(s,2);i(g,{children:(l,P)=>{a();var E=u(`Используются разные стратегии: может выбираться как первый подходящий (first-fit), как самый маленький
    среди подходящих (best-fit), так и самый большой среди подходящих (worst-fit).`);o(l,E)}});var v=r(g,2);i(v,{children:(l,P)=>{a();var E=u("Если блок найден не был, то куча расширяется и появляются новые свободные блоки.");o(l,E)}}),o(f,h)}});var c=r(m,2);L(c,{children:(f,_)=>{i(f,{children:(h,s)=>{a();var g=pr(),v=r($(g));A(v,{m:"20"});var l=r(v,2);A(l,{m:"32"});var P=r(l,2);A(P,{m:"20"});var E=r(P,2);A(E,{m:"12"}),a(),o(h,g)}})}});var n=r(c,2);L(n,{children:(f,_)=>{i(f,{children:(h,s)=>{a();var g=u("Выбранный блок помечается занятым и передаётся программе.");o(h,g)}})}}),o(d,e)}});var H=r(S,2);b(H,{children:(d,x)=>{i(d,{children:(e,m)=>{a();var c=gr(),n=r($(c));t(n,{c:"free"}),a(),o(e,c)}})}});var w=r(H,2);or(w,{wide:!0,children:(d,x)=>{var e=fr(),m=$(e);L(m,{children:(n,f)=>{i(n,{children:(_,h)=>{a();var s=u("Выбранный блок помечается свободным");o(_,s)}})}});var c=r(m,2);L(c,{children:(n,f)=>{i(n,{children:(_,h)=>{a();var s=u("Свободный блок объединяется с соседними свободными блоками в один большой свободный блок.");o(_,s)}})}}),o(d,e)}});var y=r(w,2);ar(y,{children:(d,x)=>{a();var e=u("Классический first-fit");o(d,e)}});var X=r(y,2);b(X,{children:(d,x)=>{var e=Er(),m=$(e);i(m,{children:(h,s)=>{a();var g=u(`Этот алгоритм был первым алгоритмом раздачи памяти в C.
    Появился он ещё в 1970-х годах в самых первых версиях Unix и C, разработанных в Bell Labs.
    При этом держался такой алгоритм долго,
    даже в 1985 году Давид Корн на конференции USENIX говорит об этом алгоритме как о всё ещё распространённом.`);o(h,g)}});var c=r(m,2);i(c,{children:(h,s)=>{a();var g=Pr(),v=r($(g));t(v,{c:"next"});var l=r(v,2);A(l,{m:"2"}),a(),o(h,g)}});var n=r(c,2);A(n,{display:!0,m:"\\text{размер данных текущего блока} = \\text{адрес следующего блока}~\\code{next} - \\text{адрес текущего блока} - \\text{длина заголовка}"});var f=r(n,2);i(f,{children:(h,s)=>{a();var g=ur(),v=r($(g));A(v,{m:"2"});var l=r(v,2);t(l,{c:"next"});var P=r(l,2);A(P,{m:"0"});var E=r(P,2);A(E,{m:"0"});var M=r(E,2);A(M,{m:"1"}),a(),o(h,g)}});var _=r(f,2);i(_,{children:(h,s)=>{a();var g=xr(),v=r($(g));t(v,{c:"malloc"}),a(),o(h,g)}}),o(d,e)}});var B=r(X,2);b(B,{children:(d,x)=>{var e=Mr(),m=$(e);i(m,{children:(n,f)=>{a();var _=Ar(),h=r($(_));t(h,{c:"roving_ptr"}),a(),o(n,_)}});var c=r(m,2);i(c,{children:(n,f)=>{a();var _=br(),h=r($(_));t(h,{c:"free"});var s=r(h,2);t(s,{c:"malloc"}),a(),o(n,_)}}),o(d,e)}});var F=r(B,2);b(F,{children:(d,x)=>{i(d,{children:(e,m)=>{a();var c=Or(),n=r($(c));t(n,{c:"malloc"}),a(),o(e,c)}})}});var W=r(F,2);ar(W,{children:(d,x)=>{a();var e=u("Алгоритм двойных меток");o(d,e)}});var V=r(W,2);b(V,{children:(d,x)=>{var e=Lr(),m=$(e);i(m,{children:(n,f)=>{a();var _=u("Алгоритм двойных меток был разработан Дональдом Кнутом в 1962 году при работе над Burroughs 5000.");o(n,_)}});var c=r(m,2);i(c,{children:(n,f)=>{a();var _=u(`Структура аллокатора такая же, как и у первого алгоритма first-fit.
    По краям блоков находятся метки, хранящие информацию об обоих смежных блоках, а именно их длины и занятость.`);o(n,_)}}),o(d,e)}});var Y=r(V,2);T(Y,{children:(d,x)=>{a();var e=u("Системные вызовы");o(d,e)}});var k=r(Y,2);b(k,{children:(d,x)=>{i(d,{children:(e,m)=>{var c=Rr(),n=$(c);t(n,{c:"mmap"}),a(),o(e,c)}})}});var G=r(k,2);er(G,{language:"c",code:`
void* mmap(void* addr, size_t length, int prot, int flags,
           int fd, off_t offset);
`});var K=r(G,2);b(K,{children:(d,x)=>{var e=zr(),m=$(e);i(m,{children:(s,g)=>{var v=Tr(),l=$(v);t(l,{language:"c",c:"void* addr"});var P=r(l,2);t(P,{language:"c",c:"NULL"}),a(),o(s,v)}});var c=r(m,2);i(c,{children:(s,g)=>{var v=Cr(),l=$(v);t(l,{language:"c",c:"size_t length"}),a(),o(s,v)}});var n=r(c,2);i(n,{children:(s,g)=>{var v=Nr(),l=$(v);t(l,{language:"c",c:"int prot"});var P=r(l,2);t(P,{c:"|"});var E=r(P,4);t(E,{language:"c",c:"PROT_READ"});var M=r(E,4);t(M,{language:"c",c:"PROT_WRITE"});var O=r(M,4);t(O,{language:"c",c:"PROT_EXEC"});var R=r(O,4);t(R,{language:"c",c:"PROT_NONE"}),a(),o(s,v)}});var f=r(n,2);i(f,{children:(s,g)=>{var v=Ir(),l=$(v);t(l,{language:"c",c:"int flags"});var P=r(l,2);t(P,{c:"|"});var E=r(P,4);t(E,{language:"c",c:"MAP_SHARED"});var M=r(E,4);t(M,{language:"c",c:"MAP_PRIVATE"});var O=r(M,4);t(O,{language:"c",c:"MAP_ANONYMOUS"});var R=r(O,4);t(R,{language:"c",c:"MAP_FIXED"});var J=r(R,2);t(J,{c:"addr"});var Q=r(J,4);t(Q,{language:"c",c:"MAP_FIXED_NOREPLACE"});var Z=r(Q,4);t(Z,{language:"c",c:"MAP_POPULATE"});var rr=r(Z,4);t(rr,{language:"c",c:"MAP_LOCKED"});var _r=r(rr,4);t(_r,{language:"c",c:"MAP_HUGETLB"}),a(2),o(s,v)}});var _=r(f,2);i(_,{children:(s,g)=>{var v=Ur(),l=$(v);t(l,{language:"c",c:"int fd"});var P=r(l,2);t(P,{c:"-1"}),a(),o(s,v)}});var h=r(_,2);i(h,{children:(s,g)=>{var v=Dr(),l=$(v);t(l,{language:"c",c:"off_t offset"});var P=r(l,2);t(P,{c:"0"}),a(),o(s,v)}}),o(d,e)}});var j=r(K,2);er(j,{language:"c",code:`
void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

if (ptr == MAP_FAILED) {
    perror("mmap failed");
    return 1;
}

printf("Выделено: %p\\n\\n", ptr);

strcpy((char*)ptr, "Hello from mmap!");
printf("Прочитали: %s\\n\\n", (char*)ptr);

for (size_t i = 0; i < size - 1; i++) {
    ((char*)ptr)[i] = 'A' + (i % 26);
}
((char*)ptr)[size - 1] = '\\0';
`});var q=r(j,2);T(q,{children:(d,x)=>{a();var e=u("Упражнения");o(d,e)}});var dr=r(q,2);vr(dr,{children:(d,x)=>{var e=Hr(),m=$(e);nr(m,{number:1,children:(n,f)=>{i(n,{children:(_,h)=>{a();var s=Sr(),g=r($(s));t(g,{c:"malloc"});var v=r(g,2);t(v,{c:"free"});var l=r(v,2);A(l,{m:"O(n)"});var P=r(l,2);t(P,{c:"malloc"}),a(),o(_,s)}})}});var c=r(m,2);nr(c,{number:2,children:(n,f)=>{i(n,{children:(_,h)=>{a();var s=u(`Напишите классический first-fit аллокатор. Подумайте над его оптимизацией.
    Можно разделить общий список блоков на несколько списков по размеру блоков:
    в одном списке будут только очень маленькие блоки, в другом побольше, и так далее.`);o(_,s)}})}}),o(d,e)}}),o(tr,C)}export{ro as component};
