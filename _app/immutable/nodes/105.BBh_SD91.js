import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as c,a as $,b as _,s as r,n as e,t as g}from"../chunks/B1HoO4k0.js";import{T as vr}from"../chunks/CcX1cm_-.js";import{P as k}from"../chunks/ClksMsit.js";import{P as m}from"../chunks/B8FEnsbH.js";import{M as n}from"../chunks/e5qaD0UW.js";import{C as w}from"../chunks/DunPP-_K.js";import{H as L}from"../chunks/VyKLllFE.js";import{S as M}from"../chunks/D2QCM4hc.js";import"../chunks/i9XClpbl.js";/* empty css                *//* empty css                *//* empty css                *//* empty css                */import{I as sr}from"../chunks/Cdazp-58.js";/* empty css                */const ir=""+new URL("../assets/trie-example.lh90TSUK.svg",import.meta.url).href;var mr=c("<!> <!>",1),lr=c(`<b>Задача лучевого поиска.</b> Есть алфавит <!> размера <!>.
        Строки <!> будут являться ключами, с которыми ассоциированы записи <!>.
        Нужно по заданной строке <!> найти ассоциированную с ней запись <!>.`,1),$r=c(`Бор &mdash; дерево, каждое ребро которого помечено символом из <!>.
        Некоторые узлы помечены терминальными, и в них хранятся записи (или ссылки на записи).
        Вообще, бор полностью совпадает с деревом решений при поиске в словаре по буквенным меткам.`,1),cr=c("<!> <!>",1),pr=c(`Разберемся пока с абстрактным представлением.
        В каждом узле нам нужно хранить <!> ссылок,
        ассоциированных с символами из алфавита <!>.
        Получается, в каждом узле нам нужно хранить ассоциативный массив размера <!>,
        ключами которого служат символы из алфавита <!>,
        а значениями &mdash; ссылки на следующие узлы.`,1),hr=c("<!> <!>",1),gr=c(`На каждую вершину приходится <!> ссылок, возможно пустых.
        Дополнительные данные типа ссылок на записи, флаг терминальности и прочее пока не рассматриваем.
        Получается, что бор занимает <!>, где <!> &mdash; количество узлов.`,1),fr=c(`Начиная с корня, мы выбираем ссылку на следующий узел на основе символа в искомой строке <!>.
        Заканчиваем тогда, когда закончится строка или когда нам будет некуда идти.
        Если мы дошли до конца строки <!> и в итоге попали в терминальную вершину,
        значит строка <!> в боре есть, и мы сможем вытащить ассоциированную с ней запись, если надо.`,1),Pr=c("<!> <!>",1),kr=c(`Пусть длина искомой строки <!> равна <!>.
        Во время поиска строки <!> мы потратим
        максимум <!> переходов по ассоциированным ссылкам.`,1),xr=c("<!> <!>",1),ur=c(`Рассмотрим бор на алфавите <!> размера <!>,
        в котором хранится <!> строк.
        Давайте проанализируем количество узлов, занимаемую бором память и смежные вопросы.`,1),br=c(`Рассмотрим какой-то ветвящийся узел, у которого <!> подборов,
        в которых суммарно хранится <!> строк.`,1),yr=c(`Вероятность того, что <!> строк хранится в первом подборе, <!> строк хранится во втором подборе, ..., <!> строк хранится в <!>-м подборе,
        выражается через мультиномиальный коэффициент`,1),Sr=c(`Зная это, можно вычислить среднее количество ветвящихся узлов бора &mdash; <!>.
        При этом <!>, и для <!>`,1),Kr=c("Формула симметрична относительно перестановок <!>, а значит",1),Mr=c("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),wr=c(`Если на алфавите <!> задан линейный порядок,
        то на <!> естественным образом задаётся лексикографический порядок.
        Получается, мы можем сформулировать задачу сортировки строк из <!>.`,1),Lr=c("<!> <!>",1),Tr=c(`Итак, на алфавите <!> задан порядок.
        А значит, в ассоциативном массиве мы можем получать ассоциированные с ключами ссылки по возрастанию.
        Если структура ассоциативного массива не предполагает извлечение колючей по порядку,
        можно предварительно отсортировать ключи, а в ассоциативный массиве брать ссылки по ключам в этом порядке.`,1),Or=c("<!> <!>",1),Rr=c(`Возьмем алфавит из чисел <!>.
        Тогда можно взять язык <!>.
        На самом деле это просто по-умному записанная фраза
        &laquo;представим все числа в системе счисления по основанию <!> и будем рассматривать их как строки над алфавитом <!>&raquo;.`,1),Wr=c(`Теперь бор может хранить натуральные числа.
        Во время вставки, удаления и поиска числа <!> нам нужно сделать <!> переходов по ассоциированным ссылкам.
        Получается, эти операции работают за время <!>.`,1),qr=c("<!> <!>",1),Cr=c(`Разберем подробнее двоичную систему счисления, <!>.
        Бор здесь превращается в бинарное дерево:
        левому ребенку соответствует цифра <!>, а правому <!>.`,1),Hr=c("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function ro(er){var T=Hr(),O=$(T);vr(O,{title:"Бор"});var R=r(O,2);k(R,{children:(d,p)=>{var a=mr(),i=$(a);m(i,{children:(t,s)=>{e();var o=g(`Обратимся снова к поиску слова в словаре.
        Во всех нормальных словарях на правой границе написаны буквы (а в некоторых даже вырублены засечки),
        с помощью которых можно мгновенно найти место, где начинаются слова на определенную букву.
        Я однажды увидел справочник, в котором справа были вырублены первые буквы слов, а сверху — вторые.
        Таким образом в этом справочнике можно мгновенно найти блок слов по первой букве,
        а в нём подблок слов по второй букве.
        У книги три свободных стороны... теоретически, можно сделать книгу,
        в которой можно будет искать слова до третьей буквы!`);_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=g(`Эта идея очень просто обобщается, и из нее создается простая и лаконичная структура данных,
        позволяющая очень быстро искать информацию — бор.
        Задача поиска данных описанным методом называется лучевым поиском.`);_(t,o)}}),_(d,a)}});var W=r(R,2);k(W,{children:(d,p)=>{m(d,{children:(a,i)=>{var v=lr(),t=r($(v),2);n(t,{m:"\\Sigma"});var s=r(t,2);n(s,{m:"\\sigma"});var o=r(s,2);n(o,{m:"K_i \\in \\Sigma^*"});var l=r(o,2);n(l,{m:"R_i"});var h=r(l,2);n(h,{m:"K_i"});var P=r(h,2);n(P,{m:"R_i"}),e(),_(a,v)}})}});var q=r(W,2);k(q,{children:(d,p)=>{var a=cr(),i=$(a);m(i,{children:(t,s)=>{e();var o=g("Будем действовать точно так же, как в тех книжках с буквенными метками. Сделаем бор.");_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=$r(),l=r($(o));n(l,{m:"\\Sigma"}),e(),_(t,o)}}),_(d,a)}});var C=r(q,2);k(C,{children:(d,p)=>{m(d,{children:(a,i)=>{e();var v=g(`Вот пример бора, построенного для слов
        a, an, ani, anime, ant, day, done, doc, dock, have, her, him.`);_(a,v)}})}});var H=r(C,2);sr(H,{get src(){return ir}});var I=r(H,2);M(I,{children:(d,p)=>{e();var a=g("Хранение");_(d,a)}});var N=r(I,2);k(N,{children:(d,p)=>{var a=hr(),i=$(a);m(i,{children:(t,s)=>{e();var o=pr(),l=r($(o));n(l,{m:"\\sigma"});var h=r(l,2);n(h,{m:"\\Sigma"});var P=r(h,2);n(P,{m:"\\sigma"});var y=r(P,2);n(y,{m:"\\Sigma"}),e(),_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=g("Структура узлов получается следующая");_(t,o)}}),_(d,a)}});var U=r(N,2);w(U,{code:`struct node:
    assoc[char: node] children
    bool is_terminal
    some additional data if is_terminal`});var E=r(U,2);k(E,{children:(d,p)=>{m(d,{children:(a,i)=>{e();var v=gr(),t=r($(v));n(t,{m:"\\sigma"});var s=r(t,2);n(s,{m:"O(\\sigma m)"});var o=r(s,2);n(o,{m:"m"}),e(),_(a,v)}})}});var j=r(E,2);M(j,{children:(d,p)=>{e();var a=g("Поиск");_(d,a)}});var z=r(j,2);k(z,{children:(d,p)=>{var a=Pr(),i=$(a);m(i,{children:(t,s)=>{e();var o=g("При поиске в боре мы повторяем те же действия, что делали бы при поиске в словаре с буквенными метками.");_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=fr(),l=r($(o));n(l,{m:"K"});var h=r(l,2);n(h,{m:"K"});var P=r(h,2);n(P,{m:"K"}),e(),_(t,o)}}),_(d,a)}});var A=r(z,2);w(A,{code:`function find(node root, string key) -> node:
    i = 0
    while root != none and i < length(key):
        root = root.children[key[i]]
        i += 1

    if root == none:
        return not found
    else if root.is_terminal:
        return root
    else:
        return not found`});var B=r(A,2);k(B,{children:(d,p)=>{m(d,{children:(a,i)=>{e();var v=kr(),t=r($(v));n(t,{m:"K"});var s=r(t,2);n(s,{m:"l"});var o=r(s,2);n(o,{m:"K"});var l=r(o,2);n(l,{m:"l"}),e(),_(a,v)}})}});var D=r(B,2);M(D,{children:(d,p)=>{e();var a=g("Вставка");_(d,a)}});var F=r(D,2);k(F,{children:(d,p)=>{var a=xr(),i=$(a);m(i,{children:(t,s)=>{e();var o=g(`При вставке данных в бор мы делаем всё то же самое, что и при поиске.
        В какой-то момент узлы могут закончится, вот вставляемая строка нет.
        Тогда мы продолжаем двигаться вперед, создавая себе новые вершины на пути.`);_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=g(`В самом конце мы пометим вершину как терминальную и сохраним в ней всю нужную информацию,
        например, ссылку на запись.`);_(t,o)}}),_(d,a)}});var G=r(F,2);w(G,{code:`function insert(node root, string key) -> node:
    for i = 0; i < length(key):
        if root.children[key[i]] == none:
            root.children[key[i]] = node()

        root = root.children[key[i]]

    root.is_terminal = true
    save some additional data at root`});var J=r(G,2);L(J,{children:(d,p)=>{e();var a=g("Анализ строк");_(d,a)}});var Q=r(J,2);k(Q,{children:(d,p)=>{m(d,{children:(a,i)=>{e();var v=ur(),t=r($(v));n(t,{m:"\\Sigma"});var s=r(t,2);n(s,{m:"\\sigma"});var o=r(s,2);n(o,{m:"n"}),e(),_(a,v)}})}});var V=r(Q,2);M(V,{children:(d,p)=>{e();var a=g("Количество ветвящихся узлов");_(d,a)}});var X=r(V,2);k(X,{children:(d,p)=>{var a=Mr(),i=$(a);m(i,{children:(x,S)=>{e();var f=g(`Каждый узел бора соответствует уникальному префиксу какой-то строки.
        При этом ветвящийся узел соответствует ситуации, когда у каких-то двух строк совпадают префиксы.
        Понятно, что совпадение здесь надо считать по наибольшему общему префиксу.`);_(x,f)}});var v=r(i,2);m(v,{children:(x,S)=>{e();var f=g(`С точки зрения полезного анализа (сейчас и для будущего) имеет смысл рассматривать только ветвящиеся узлы.
        Количество узлов интересно нам в первую очередь с точки зрения оценки затрат памяти.
        Как мы увидим в дальнейшем, неветвящиеся хвосты и промежуточные участки имеют маленькое влияние.
        А их еще можно сжимать, оставляя существенными только ветвящиеся узлы.`);_(x,f)}});var t=r(v,2);m(t,{children:(x,S)=>{e();var f=br(),u=r($(f));n(u,{m:"\\sigma"});var b=r(u,2);n(b,{m:"n"}),e(),_(x,f)}});var s=r(t,2);m(s,{children:(x,S)=>{e();var f=yr(),u=r($(f));n(u,{m:"k_1"});var b=r(u,2);n(b,{m:"k_2"});var K=r(b,2);n(K,{m:"k_\\sigma"});var dr=r(K,2);n(dr,{m:"\\sigma"}),e(),_(x,f)}});var o=r(s,2);n(o,{display:!0,m:"\\prob(\\cdot) = \\frac{1}{\\sigma^n} \\cdot \\binom{n}{k_1 ~ k_2 ~ \\cdots ~ k_n}"});var l=r(o,2);m(l,{children:(x,S)=>{e();var f=Sr(),u=r($(f));n(u,{m:"M_n"});var b=r(u,2);n(b,{m:"M_0 = M_1 = 0"});var K=r(b,2);n(K,{m:"n \\ge 2"}),_(x,f)}});var h=r(l,2);n(h,{display:!0,m:"M_n = 1 + \\sum_{k_1 + k_2 + \\dotsb + k_\\sigma = n} \\frac{1}{\\sigma^n} \\cdot \\binom{n}{k_1 ~ k_2 ~ \\cdots ~ k_n} \\cdot (L_{k_1} + L_{k_2} + \\dotsb + L{k_\\sigma})"});var P=r(h,2);m(P,{children:(x,S)=>{e();var f=Kr(),u=r($(f));n(u,{m:"k_i"}),e(),_(x,f)}});var y=r(P,2);n(y,{display:!0,m:"M_n = 1 + \\frac{1}{\\sigma^{n-1}} \\sum_{k=0}^n \\binom{n}{k} \\cdot (\\sigma - 1)^{n-k} \\cdot L_k"});var nr=r(y,2);m(nr,{children:(x,S)=>{e();var f=g("С помощью трюка с биномиальными преобразованиями последовательностей можно получить выражение без рекурсии");_(x,f)}});var _r=r(nr,2);n(_r,{display:!0,m:"M_n = \\sum_{k=2}^n \\binom{n}{k} \\cdot (-1)^k \\cdot \\frac{k-1}{\\sigma^{k-1}-1} = \\frac{n}{\\ln \\sigma} + O(1)"}),_(d,a)}});var Y=r(X,2);L(Y,{children:(d,p)=>{e();var a=g("Поразрядная сортировка");_(d,a)}});var Z=r(Y,2);k(Z,{children:(d,p)=>{var a=Lr(),i=$(a);m(i,{children:(t,s)=>{e();var o=wr(),l=r($(o));n(l,{m:"\\Sigma"});var h=r(l,2);n(h,{m:"\\Sigma^*"});var P=r(h,2);n(P,{m:"\\Sigma^*"}),e(),_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=g(`Вообще, такая задача и такой подход встречаются очень часто,
        ведь большое количество данных имеют именно такую структуру.
        За примером далеко ходить не надо:
        обычные человеческие слова очень часто приходится сортировать в лексикографическом порядке.`);_(t,o)}}),_(d,a)}});var rr=r(Z,2);k(rr,{children:(d,p)=>{var a=Or(),i=$(a);m(i,{children:(t,s)=>{e();var o=Tr(),l=r($(o));n(l,{m:"\\Sigma"}),e(),_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=g(`Поместим все строки, которые мы хотим отсортировать, в бор.
        А дальше просто рекурсивно ходим по бору в соответствии с заданным порядком.`);_(t,o)}}),_(d,a)}});var or=r(rr,2);L(or,{children:(d,p)=>{e();var a=g("Цифровой бор");_(d,a)}});var ar=r(or,2);k(ar,{children:(d,p)=>{var a=qr(),i=$(a);m(i,{children:(t,s)=>{e();var o=Rr(),l=r($(o));n(l,{m:"W = \\{0, 1, 2, \\dotsc, w\\}"});var h=r(l,2);n(h,{m:"W^+ = \\NN"});var P=r(h,2);n(P,{m:"w"});var y=r(P,2);n(y,{m:"W"}),e(),_(t,o)}});var v=r(i,2);m(v,{children:(t,s)=>{e();var o=Wr(),l=r($(o));n(l,{m:"n"});var h=r(l,2);n(h,{m:"\\log_w n"});var P=r(h,2);n(P,{m:"O(\\log_w n)"}),e(),_(t,o)}}),_(d,a)}});var tr=r(ar,2);k(tr,{children:(d,p)=>{m(d,{children:(a,i)=>{e();var v=Cr(),t=r($(v));n(t,{m:"w = 2"});var s=r(t,2);n(s,{m:"0"});var o=r(s,2);n(o,{m:"1"}),e(),_(a,v)}})}}),_(er,T)}export{ro as component};
