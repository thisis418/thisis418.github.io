import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as h,a as _,b as p,s as r,n as a,t as T}from"../chunks/BWp35gWV.js";import{T as E}from"../chunks/CR7k0xtG.js";import{P}from"../chunks/DPzc5wQr.js";import{P as l}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";/* empty css                */import"../chunks/i9XClpbl.js";/* empty css                *//* empty css                */import{H as L}from"../chunks/DXKx2xvL.js";/* empty css                *//* empty css                *//* empty css                */import{I as R}from"../chunks/Cv_jjTLk.js";/* empty css                *//* empty css                *//* empty css                *//* empty css                *//* empty css                *//* empty css                */const U=""+new URL("../assets/beap-exapmle.C_pexecb.svg",import.meta.url).href;var j=h(`В обычных двоичных и <!>-арных кучах мы научились быстро вставлять элементы и извлекать минимум.
    Кроме таких операций нам может понадобится искать элементы.
    В бинарных и <!>-арных кучах нельзя реализовать эффективный поиск.`,1),q=h(`Такую пирамидку можно хранить в массиве, записывая уровни один за другим по порядку, от верхнего к нижнему.
    Элементы на уровне <!> будут хранится
    по индексам с <!> по <!>.`,1),y=h(`Гораздо удобнее представлять элементы кучи не по реальным индексам, а по парам <!>,
    где <!> &mdash; уровень вершины, а <!> &mdash; номер вершины в ряду.
    Тогда индекс вершины будет вычисляться как <!>.`,1),z=h(`У вершины с индексом <!> родители имеют индексы <!> и <!>,
    а дети имеют индексы <!> и <!>.
    Если при вычислении индексов родителей индекс выходит за границы уровня,
    то это значит, что соответствующего родителя у элемента нет.
    Также, если при вычислении индексов детей индекс выходит за границы массива,
    то это значит, что соответствующего ребёнка у элемента нет.`,1),A=h("<!> <!> <!>",1),D=h("<!> <!> <!> <!> <!> <!>",1);function sr(w){var k=D(),x=_(k);E(x,{title:"Двуродительские кучи"});var b=r(x,2);P(b,{children:(i,g)=>{l(i,{children:(t,$)=>{a();var s=j(),f=r(_(s));o(f,{m:"d"});var d=r(f,2);o(d,{m:"d"}),a(),p(t,s)}})}});var u=r(b,2);L(u,{children:(i,g)=>{a();var t=T("Двуродительская куча");p(i,t)}});var H=r(u,2);P(H,{children:(i,g)=>{l(i,{children:(t,$)=>{a();var s=T(`Нарисуем полное двоичное псевдодерево,
    в котором у каждого узла есть до двух детей и до двух родителей.
    Потребуем также, чтобы значение любого узла было не больше значений его потомков.`);p(t,s)}})}});var I=r(H,2);R(I,{get src(){return U}});var B=r(I,2);P(B,{children:(i,g)=>{var t=A(),$=_(t);l($,{children:(d,M)=>{a();var e=q(),m=r(_(e));o(m,{m:"h"});var n=r(m,2);o(n,{m:"h \\, (h-1) / 2"});var v=r(n,2);o(v,{m:"h \\, (h+1) / 2 - 1"}),a(),p(d,e)}});var s=r($,2);l(s,{children:(d,M)=>{a();var e=y(),m=r(_(e));o(m,{m:"(h, k)"});var n=r(m,2);o(n,{m:"h"});var v=r(n,2);o(v,{m:"k"});var c=r(v,2);o(c,{m:"h \\, (h - 1) / 2 + k - 1"}),a(),p(d,e)}});var f=r(s,2);l(f,{children:(d,M)=>{a();var e=z(),m=r(_(e));o(m,{m:"(h, k)"});var n=r(m,2);o(n,{m:"(h-1, k-1)"});var v=r(n,2);o(v,{m:"(h-1, k)"});var c=r(v,2);o(c,{m:"(h+1, k)"});var C=r(c,2);o(C,{m:"(h+1, k+1)"}),a(),p(d,e)}}),p(i,t)}}),p(w,k)}export{sr as component};
