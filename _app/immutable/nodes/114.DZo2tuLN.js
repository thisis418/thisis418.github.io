import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as d,a as v,b as a,s as r,n as o,t as x}from"../chunks/B1HoO4k0.js";import{T as Ir}from"../chunks/CcX1cm_-.js";import{P as u}from"../chunks/ClksMsit.js";import{P as h}from"../chunks/B8FEnsbH.js";import{M as t}from"../chunks/e5qaD0UW.js";/* empty css                */import{C as j}from"../chunks/0Rd6UPhr.js";import{C as D}from"../chunks/DunPP-_K.js";import{H as M}from"../chunks/VyKLllFE.js";import{S as U}from"../chunks/D2QCM4hc.js";/* empty css                *//* empty css                */import{I}from"../chunks/Cdazp-58.js";/* empty css                */import{E as Br}from"../chunks/BnlOlOSM.js";import{L as k}from"../chunks/_RU5sT8R.js";import{B as Er}from"../chunks/Dv4xhkGP.js";import{E as Tr}from"../chunks/Swjzo_E6.js";import{E as Hr}from"../chunks/C0Z7FaNC.js";const Dr=""+new URL("../assets/shift-down.2HV7D_QN.svg",import.meta.url).href,Mr=""+new URL("../assets/shift-up.CPwbnOJ5.svg",import.meta.url).href,Wr=""+new URL("../assets/heap-specific-way.P3SRMlqY.svg",import.meta.url).href,Jr=""+new URL("../assets/3ary-heap-example.CeOIO76W.svg",import.meta.url).href,Nr=""+new URL("../assets/dary-heap-time.CLBCX-oR.svg",import.meta.url).href;var Qr=d("<!> <!>",1),Vr=d(`Давайте создадим бинарное дерево, в котором каждая вершина будет больше своих потомков.
    При этом, для достижения минимальной высоты <!>,
    сделаем дерево полным.`,1),Xr=d(`Полное бинарное дерево можно хорошо хранить в массиве <!> длины <!> (индексация, напомню, с <!>).
    Тогда у элемента с индексом <!> детьми являются элементы с индексами <!> и <!>,
    а родителем &mdash; элемент с индексом <!>.`,1),Yr=d(`По нашему построению видно, что максимальный элемент в куче имеет индекс <!>,
    а минимальный элемент находится в одном из листьев.
    А так же для всех элементов выполнено &laquo;свойство кучи&raquo;:`,1),zr=d("<!> <!> <!> <!>",1),Ar=d("<!> <!>",1),Fr=d(`Если этот элемент слишком большой, то его надо пропихнуть вверх по куче.
    Если же он наоборот, слишком маленький, то его надо пропихнуть вниз.
    Вот эти две операции пропихивания вверх и вниз называются по-научному <b>просеиванием</b>.`,1),Gr=d("<!> <!>",1),Kr=d("<b>Просеивание вниз</b> (shift down).",1),Zr=d("<!> <!>",1),ro=d("<!> <!>",1),oo=d(`Если просеиваемый вниз элемент находился на высоте <!>,
    то выполнение операции потребует не более <!> обменов и не более <!> сравнений.
    Константа <!> вылезает потому, что сравниваем мы каждым ребенком.`,1),ao=d("<b>Просеивание вверх</b> (shift up).",1),eo=d("<!> <!>",1),no=d("<!> <!> <!>",1),to=d("Обе операции работают за время <!>.",1),_o=d(`Вставка нового элемента в кучу происходит очень просто:
    мы добавляем в конец массива <!> новый элемент и просеиваем его вверх.
    После просеивания новый элемент займет корректное положение.`,1),lo=d(`При извлечении минимума можно воспользоваться примерно тем же трюком, что и со вставкой.
    Поместим на место корня элемент <!>, который гарантированно меньше любого другого элемента.
    Теперь осталось просто просеять вниз этот элемент.`,1),vo=d(`Можно обойтись и без введения особого элемента, если вспомнить, что листы &mdash; наименьшие элементы в куче.
    Можно на место корня ставить не <!>, а какой-то лист, например последний.
    Эффект от просеивания этого элемента вниз будет точно таким же, как и от просеивания <!>:
    свойство кучи сохранено, максимум извлечён.`,1),so=d("<!> <!>",1),io=d(`Представим, что у нас есть неупорядоченный массив, который мы хотим превратить в кучу.
    Можно действовать в лоб: создать пустую кучу и добавлять туда элементы из массива.
    Такой подход имеет временную сложность <!>.`,1),mo=d("<!> <!>",1),$o=d(`Представим, что в исходном массиве уже записано полное бинарное дерево. Оно не удовлетворяет свойству кучи.
    Давайте просеем вниз все узлы, которые имеют хотя бы одного ребёнка.
    При этом будем просеивать снизу вверх, то есть начнем с элемента на позиции <!>,
    а закончим корнем, который находится на позиции <!>.`,1),ho=d("<!> <!>",1),po=d("Время работы этой операции <!>.",1),co=d(`Число вершин на высоте <!> не более <!>.
    Для каждой из них будет вызвана операция просеивания вниз,
    которая потребует не более <!> обменов и не более <!> сравнений.
    Значит, количество сравнений в операции heapify равно`,1),fo=d("А количество обменов в <!> раза меньше, <!>.",1),go=d("<!> <!> <!> <!>",1),Po=d("<!> <!>",1),bo=d(`Все неособые поддеревья являются абсолютно сбалансированными,
    значит их размер всегда равен <!>.
    А&nbsp;количество неособых поддеревьев очень легко вычисляется:`,1),xo=d(`Осталось разобраться с особыми узлами.
    Пусть двоичное представление числа <!>`,1),uo=d("<!> <!> <!> <!> <!> <!> <!>",1),yo=d(`Теперь мы можем посчитать количество всевозможных куч на <!> элементах.
    Пусть <!> &mdash; размер поддерева с корнем в <!>.
    Тогда всего куч`,1),Oo=d("<!> <!>",1),wo=d(`Нам дали массив, который нужно отсортировать.
    Применим операцию heapify, превратив массив в кучу на максимум
    за <!> сравнений и <!> обменов.
    Затем будем извлекать максимум из кучи, пока та не кончится.`,1),qo=d("<!> <!>",1),Lo=d(`Если в алгоритм пирамидальной сортировки даётся случайная перестановка чисел <!>,
    то при heapify может равновероятно получиться любая из <!> возможных куч.`,1),jo=d(`Построение кучи, как мы уже выяснили, требует <!> сравнений и <!> обменов.
    После этого мы <!> раз извлекаем максимум, который находится в корне,
    на высоте <!>.
    Эта операция просто вызывает просеивание вниз, а значит требует <!> обменов и <!> сравнений.
    В итоге пирамидальная сортировка требует`,1),Co=d("Огрубив, говорим, что пирамидальная сортировка работает за <!>.",1),ko=d("<!> <!> <!> <!>",1),Bo=d("<!>-арная куча",1),Eo=d(`Есть смысл рассматривать не только бинарные деревья для представления кучи, а вообще любые <!>-арные.
    Высота таких деревьев <!>.`,1),Ho=d(`Точно так же, как и для двоичной кучи, у <!>-арной кучи есть свойство кучи:
    значение любого узла больше значений всех его поддеревьев или, что то же самое, больше значений всех его детей.`,1),Ro=d(`Хранить полное <!>-арное дерево можно точно так же в массиве.
    У элемента с индексом <!> детьми являются элементы с индексами <!>,
    а родителем &mdash; элемент с индексом <!>.`,1),So=d("<!> <!> <!>",1),Uo=d(`Просеивание вверх требует максимум <!> обменов и сравнений,
    а просеивание вниз требует максимум <!> обменов
    и максимум <!> сравнений.`,1),Io=d("<!> <!>",1),To=d(`Разберем операцию построения <!>-арной кучи с помощью heapify.
    Количество сравнений для операции heapify равно`,1),Do=d("А количество обменов в <!> раз меньше, <!>.",1),Mo=d("<!> <!> <!>",1),Wo=d("вставка &mdash; <!>",1),Jo=d("извлечение максимума &mdash; <!>",1),No=d("построение <!>-арной кучи &mdash; <!>",1),Qo=d("<!> <!> <!>",1),Vo=d("<!> <!>",1),Xo=d(`При этом эффективность <!>-арной кучи сильно растёт только при маленьких <!>.
    Посмотрите на график зависимости числа сравнений <!> при вставке
    от размера кучи <!>.
    Разными цветами обозначены графики для разных значений <!>:
    от синего при <!> до красного при <!>.`,1),Yo=d("<!> <!>",1),zo=d("<!> &mdash; создать кучу на массиве",1),Ao=d("<!> &mdash; добавить объект <!> в кучу",1),Fo=d("<!> &mdash; по заданному индексу <!> изменить значение элемента в куче на <!>",1),Go=d("<!> &mdash; извлечь из кучи минимальный элемент",1),Ko=d("<!> &mdash; посмотреть, какой в куче минимальный элемент, не извлекая его",1),Zo=d("<!> <!> <!> <!> <!>",1),ra=d(`Напишите бенчмарки, которые замеряют время выполнения и количество операций сравнения
    для <!>, <!> и <!> при разном размере кучи <!> и при разных сценариях работы
    (много вставок, затем много извлечений; поочерёдные вставки и извлечения; случайные операции и так далее).`,1),oa=d("Постройте графики зависимости времени операции от <!> и от <!>.",1),aa=d(`Проведите аналогичные замеры для операции <!> и постройте график зависимости от <!> при разных входных данных
    (почти отсортированный массив, обратно отсортированный, случайная перестановка и так далее).`,1),ea=d("<!> <!> <!>",1),na=d("<!> <!> <!>",1),ta=d(`Напишите код, который вычисляет <b>точное количество</b> куч,
    которые можно построить на массиве <!>.
    Постройте график зависимости логарифма количества куч от <!>.`,1),_a=d("<!> <!>",1),da=d("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Ca(Rr){var W=da(),J=v(W);Ir(J,{title:"Двоичная и d-арная куча"});var N=r(J,2);u(N,{children:(s,b)=>{var n=Qr(),m=v(n);h(m,{children:(_,p)=>{o();var e=x("Про приоритетные очереди");a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x("С помощью линейных структур нельзя реализовать эффективную приоритетную очередь.");a(_,e)}}),a(s,n)}});var Q=r(N,2);M(Q,{children:(s,b)=>{o();var n=x("Двоичная куча");a(s,n)}});var V=r(Q,2);u(V,{children:(s,b)=>{var n=zr(),m=v(n);h(m,{children:(e,i)=>{o();var l=Vr(),c=r(v(l));t(c,{m:"\\lfloor \\log_2 n \\rfloor + 1"}),o(),a(e,l)}});var $=r(m,2);h($,{children:(e,i)=>{o();var l=Xr(),c=r(v(l));j(c,{c:"h"});var f=r(c,2);t(f,{m:"n"});var g=r(f,2);t(g,{m:"0"});var P=r(g,2);t(P,{m:"i"});var y=r(P,2);t(y,{m:"2i+1"});var L=r(y,2);t(L,{m:"2i+2"});var E=r(L,2);t(E,{m:"\\lfloor (i-1)/2 \\rfloor"}),o(),a(e,l)}});var _=r($,2);h(_,{children:(e,i)=>{o();var l=Yr(),c=r(v(l));t(c,{m:"0"}),o(),a(e,l)}});var p=r(_,2);t(p,{display:!0,m:"\\code{h}[i] \\ge \\code{h} \\bigl[ \\lfloor (i-1)/2 \\rfloor \\bigr] \\quad \\text{для всех}~ i"}),a(s,n)}});var X=r(V,2);u(X,{children:(s,b)=>{var n=Ar(),m=v(n);h(m,{children:(_,p)=>{o();var e=x(`Теперь мы можем производить какие-то операции с кучей.
    А именно, вставлять элементы, изменять элементы и извлекать минимум (про тонкости реализации позже).`);a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x(`После изменения элементов свойство кучи может нарушиться.
    Поэтому нам надо научиться быстро восстанавливать его.`);a(_,e)}}),a(s,n)}});var Y=r(X,2);U(Y,{children:(s,b)=>{o();var n=x("Восстановление свойства кучи");a(s,n)}});var z=r(Y,2);u(z,{children:(s,b)=>{var n=Gr(),m=v(n);h(m,{children:(_,p)=>{o();var e=x(`Пусть какой-то один элемент мешает свойству кучи быть выполненным.
    Как мы увидим позже, любые операции над кучей в итоге оставляют ровно один плохой элемент.`);a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=Fr();o(2),a(_,e)}}),a(s,n)}});var A=r(z,2);u(A,{children:(s,b)=>{var n=ro(),m=v(n);h(m,{children:(_,p)=>{var e=Kr();o(),a(_,e)}});var $=r(m,2);Br($,{children:(_,p)=>{var e=Zr(),i=v(e);k(i,{children:(c,f)=>{o();var g=x("Если просеиваемый элемент меньше, чем его дети, то меняем его с наибольшим из его детей.");a(c,g)}});var l=r(i,2);k(l,{children:(c,f)=>{o();var g=x("Продолжаем его просеивать, пока он не встанет на нормальное место или пока он не станет листом.");a(c,g)}}),a(_,e)}}),a(s,n)}});var F=r(A,2);I(F,{get src(){return Dr}});var G=r(F,2);D(G,{code:`function shift_down(mutable array h, int i):
    const int n = length(h)

    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2

        if right < n and h[right] > h[left]:
            j = right
        else:
            j = left

        break if h[i] >= h[j]

        swap h[i], h[j]
        i = j`});var K=r(G,2);u(K,{children:(s,b)=>{h(s,{children:(n,m)=>{o();var $=oo(),_=r(v($));t(_,{m:"h"});var p=r(_,2);t(p,{m:"h-1"});var e=r(p,2);t(e,{m:"2h-2"});var i=r(e,2);t(i,{m:"2"}),o(),a(n,$)}})}});var Z=r(K,2);u(Z,{children:(s,b)=>{var n=no(),m=v(n);h(m,{children:(p,e)=>{var i=ao();o(),a(p,i)}});var $=r(m,2);Br($,{children:(p,e)=>{var i=eo(),l=v(i);k(l,{children:(f,g)=>{o();var P=x("Если просеиваемый элемент меньше, чем его родитель, то меняем его с его родителем.");a(f,P)}});var c=r(l,2);k(c,{children:(f,g)=>{o();var P=x("Продолжаем его просеивать, пока он не встанет на нормальное место или пока он не станет корнем.");a(f,P)}}),a(p,i)}});var _=r($,2);h(_,{children:(p,e)=>{o();var i=x("Здесь нет никаких ветвлений, в отличие от просеивания вниз, поэтому код будет более красивым");a(p,i)}}),a(s,n)}});var rr=r(Z,2);I(rr,{get src(){return Mr}});var or=r(rr,2);D(or,{code:`function shift_up(mutable array h, int i):
    while h[i] > h[(i - 1) / 2]:
        swap h[i], h[(i - 1) / 2]
        i = (i - 1) / 2`});var ar=r(or,2);u(ar,{children:(s,b)=>{h(s,{children:(n,m)=>{o();var $=to(),_=r(v($));t(_,{m:"O(\\text{высота кучи}) = O(\\log n)"}),o(),a(n,$)}})}});var er=r(ar,2);U(er,{children:(s,b)=>{o();var n=x("Вставка");a(s,n)}});var nr=r(er,2);u(nr,{children:(s,b)=>{h(s,{children:(n,m)=>{o();var $=_o(),_=r(v($));j(_,{c:"h"}),o(),a(n,$)}})}});var tr=r(nr,2);U(tr,{children:(s,b)=>{o();var n=x("Извлечение максимума");a(s,n)}});var _r=r(tr,2);u(_r,{children:(s,b)=>{var n=so(),m=v(n);h(m,{children:(_,p)=>{o();var e=lo(),i=r(v(e));t(i,{m:"-\\oo"}),o(),a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=vo(),i=r(v(e));t(i,{m:"-\\oo"});var l=r(i,2);t(l,{m:"-\\oo"}),o(),a(_,e)}}),a(s,n)}});var dr=r(_r,2);U(dr,{children:(s,b)=>{o();var n=x("Построение кучи");a(s,n)}});var lr=r(dr,2);u(lr,{children:(s,b)=>{var n=mo(),m=v(n);h(m,{children:(_,p)=>{o();var e=io(),i=r(v(e));t(i,{m:"O(n \\log n)"}),o(),a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x(`Но в куче очень много беспорядков. Можно этим воспользоваться.
    Построить кучу из массива может операция heapify.`);a(_,e)}}),a(s,n)}});var vr=r(lr,2);u(vr,{children:(s,b)=>{var n=ho(),m=v(n);h(m,{children:(_,p)=>{o();var e=$o(),i=r(v(e));t(i,{m:"\\lfloor n/2 \\rfloor"});var l=r(i,2);t(l,{m:"1"}),o(),a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x(`В итоге мы из массива получим нормальную кучу.
    До просеивания какого-то узла оба его поддерева удовлетворяли свойству кучи.
    После просеивания этого узла он вместе со своими поддеревьями будет образовывать кучу.
    Значит, после просеивания всех узлов у нас получится куча.`);a(_,e)}}),a(s,n)}});var sr=r(vr,2);D(sr,{code:`function heapify(mutable array h):
    const int n = length(h)
    
    for int i = (n-1)/2; i >= 0; i--:
        sift_down(h, i)`});var ir=r(sr,2);u(ir,{children:(s,b)=>{var n=go(),m=v(n);h(m,{children:(e,i)=>{o();var l=po(),c=r(v(l));t(c,{m:"O(n)"}),o(),a(e,l)}});var $=r(m,2);h($,{children:(e,i)=>{o();var l=co(),c=r(v(l));t(c,{m:"h"});var f=r(c,2);t(f,{m:"\\lceil n / 2^h \\rceil"});var g=r(f,2);t(g,{m:"h"});var P=r(g,2);t(P,{m:"2h"}),o(),a(e,l)}});var _=r($,2);t(_,{display:!0,m:"\\sum_{h=1}^{\\lfloor \\log_2 n \\rfloor + 1} \\Bigl\\lceil \\frac{n}{2^h} \\Bigr\\rceil \\cdot (2h-2) = 2n \\sum_{h=1}^{\\lfloor \\log_2 n \\rfloor + 1} \\frac{h-1}{2^h} = 4n + O(\\log n)"});var p=r(_,2);h(p,{children:(e,i)=>{o();var l=fo(),c=r(v(l));t(c,{m:"2"});var f=r(c,2);t(f,{m:"2n + O(\\log n)"}),o(),a(e,l)}}),a(s,n)}});var mr=r(ir,2);U(mr,{children:(s,b)=>{o();var n=x("Анализ алгоритмов на куче");a(s,n)}});var $r=r(mr,2);u($r,{children:(s,b)=>{var n=Po(),m=v(n);h(m,{children:(_,p)=>{o();var e=x(`Одна из самых важных характеристик кучи — размеры её поддеревьев.
    Просто так получить все значения, к сожалению нельзя.
    Проблемы возникают только из-за того, что куча — полное дерево, но не всегда абсолютно сбалансированное.`);a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x(`В куче есть «особый путь», соединяющий корень кучи с последним листом.
    На картинке я его отметил красным.`);a(_,e)}}),a(s,n)}});var hr=r($r,2);I(hr,{get src(){return Wr}});var pr=r(hr,2);u(pr,{children:(s,b)=>{var n=uo(),m=v(n);h(m,{children:(c,f)=>{o();var g=x(`Давайте все узлы, лежащие на особом пути, называть особыми.
    И поддеревья с корнями в особых узлах тоже будем называть особыми.`);a(c,g)}});var $=r(m,2);h($,{children:(c,f)=>{o();var g=bo(),P=r(v(g));t(P,{m:"2^k - 1"}),o(),a(c,g)}});var _=r($,2);t(_,{display:!0,m:"\\text{неособых деревьев размера}~ 2^k-1 ~\\text{ровно} \\left\\lfloor \\frac{n - 2^{k-1}}{2^k} \\right\\rfloor ~\\text{штук}"});var p=r(_,2);h(p,{children:(c,f)=>{o();var g=xo(),P=r(v(g));t(P,{m:"n"}),a(c,g)}});var e=r(p,2);t(e,{display:!0,m:"n = \\bigl( b_{h} \\, b_{h-1} \\, b_{h-2} \\, \\dotsm \\, b_2, b_1, b_0 \\bigr)_2 \\quad \\text{где}~ h = \\lfloor \\log_2 n \\rfloor"});var i=r(e,2);h(i,{children:(c,f)=>{o();var g=x(`Тогда размеры особых поддеревьев можно явно выразить через эти цифры.
    Напишу сверху вниз`);a(c,g)}});var l=r(i,2);t(l,{display:!0,m:`
            \\bigl( 1 \\, b_{h-1} \\, b_{h-2} \\, \\dotsm \\, b_2 \\, b_1 \\, b_0 \\bigr)_2 \\quad
            \\bigl( 1 \\, b_{h-2} \\, \\dotsm \\, b_2 \\, b_1 \\, b_0)_2 \\quad
            \\cdots \\quad
            \\bigl(1 \\, b_1 \\, b_0 \\bigr)_2 \\quad
            \\bigl( 1 \\, b_0 \\bigr)_2 \\quad
            1_2`}),a(s,n)}});var cr=r(pr,2);u(cr,{children:(s,b)=>{var n=Oo(),m=v(n);h(m,{children:(_,p)=>{o();var e=yo(),i=r(v(e));t(i,{m:"n"});var l=r(i,2);t(l,{m:"s_v"});var c=r(l,2);t(c,{m:"v"}),o(),a(_,e)}});var $=r(m,2);t($,{display:!0,m:"\\frac{n!}{s_1 \\cdot s_2 \\cdot s_3 \\dotsm s_{n-1} \\cdot s_n} = n! \\bigg/ \\prod_{v} s_v "}),a(s,n)}});var fr=r(cr,2);M(fr,{children:(s,b)=>{o();var n=x("Пирамидальная сортировка");a(s,n)}});var gr=r(fr,2);u(gr,{children:(s,b)=>{h(s,{children:(n,m)=>{o();var $=x(`С помощью кучи можно реализовать прекрасный алгоритм сортировки, называемый пирамидальной сортировкой.
    Названия действительно не совпадают.
    По-русски куча это пирамида, но такое название приоритетной очереди не прижилось в профессиональных кругах.
    А сортировка, работающая с помощью кучи, по-прежнему называется пирамидальной.
    В английском языке все хорошо: структура данных heap, сортировка heap sort.`);a(n,$)}})}});var Pr=r(gr,2);u(Pr,{children:(s,b)=>{var n=qo(),m=v(n);h(m,{children:(_,p)=>{o();var e=wo(),i=r(v(e));t(i,{m:"4n + O(\\log n)"});var l=r(i,2);t(l,{m:"2n + O(\\log n)"}),o(),a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=x(`Heapify работает без дополнительной памяти, а вытаскиваемый максимум помещается в самый конец массива.
    Поэтому, можно с каждой операцией извлечения максимума уменьшать логический размер массива.
    В итоге максимумы будут складываться с конца в порядке убывания, и в итоге мы получим отсортированный массив.`);a(_,e)}}),a(s,n)}});var br=r(Pr,2);D(br,{code:`function heap_sort(mutable array h):
    int n = length(h)

    heapify()

    repeat n times:
        swap h[0] = h[n-1]
        n -= 1
        shift_down(0)`});var xr=r(br,2);u(xr,{children:(s,b)=>{var n=ko(),m=v(n);h(m,{children:(e,i)=>{o();var l=Lo(),c=r(v(l));t(c,{m:"(1, 2, \\dotsc, n)"});var f=r(c,2);t(f,{m:"n! \\bigm/ \\prod_{v} s_v"}),o(),a(e,l)}});var $=r(m,2);h($,{children:(e,i)=>{o();var l=jo(),c=r(v(l));t(c,{m:"4n + O(\\log n)"});var f=r(c,2);t(f,{m:"2n + O(\\log n)"});var g=r(f,2);t(g,{m:"n"});var P=r(g,2);t(P,{m:"\\lfloor \\log_2 n \\rfloor + 1"});var y=r(P,2);t(y,{m:"\\lfloor \\log_2 n \\rfloor"});var L=r(y,2);t(L,{m:"2 \\lfloor \\log_2 n \\rfloor"}),o(),a(e,l)}});var _=r($,2);t(_,{display:!0,m:`
          \\text{максимум} \\quad
          2 n \\lfloor \\log_2 n \\rfloor + 4n + O(\\log n) ~~\\text{сравнений}
          \\quad \\text{и} \\quad
          n \\lfloor \\log_2 n \\rfloor + 2n + O(\\log n) ~~\\text{обменов}
          `});var p=r(_,2);h(p,{children:(e,i)=>{o();var l=Co(),c=r(v(l));t(c,{m:"\\Theta(n \\log n)"}),o(),a(e,l)}}),a(s,n)}});var ur=r(xr,2);M(ur,{children:(s,b)=>{var n=Bo(),m=v(n);t(m,{m:"d"}),o(),a(s,n)}});var yr=r(ur,2);u(yr,{children:(s,b)=>{var n=So(),m=v(n);h(m,{children:(p,e)=>{o();var i=Eo(),l=r(v(i));t(l,{m:"d"});var c=r(l,2);t(c,{m:"\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor + 1"}),o(),a(p,i)}});var $=r(m,2);h($,{children:(p,e)=>{o();var i=Ho(),l=r(v(i));t(l,{m:"d"}),o(),a(p,i)}});var _=r($,2);h(_,{children:(p,e)=>{o();var i=Ro(),l=r(v(i));t(l,{m:"d"});var c=r(l,2);t(c,{m:"i"});var f=r(c,2);t(f,{m:"di+1, d_i+2, \\dotsc, di+d"});var g=r(f,2);t(g,{m:"\\lfloor (i-1) / d \\rfloor"}),o(),a(p,i)}}),a(s,n)}});var Or=r(yr,2);I(Or,{get src(){return Jr}});var wr=r(Or,2);u(wr,{children:(s,b)=>{var n=Io(),m=v(n);h(m,{children:(_,p)=>{o();var e=x(`Все операции: просеивание, вставка, извлечение максимума и построение выполняются точно так же,
    как и с обычной двоичной кучей.`);a(_,e)}});var $=r(m,2);h($,{children:(_,p)=>{o();var e=Uo(),i=r(v(e));t(i,{m:"\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor"});var l=r(i,2);t(l,{m:"\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor"});var c=r(l,2);t(c,{m:"d \\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor"}),o(),a(_,e)}}),a(s,n)}});var qr=r(wr,2);u(qr,{children:(s,b)=>{var n=Mo(),m=v(n);h(m,{children:(p,e)=>{o();var i=To(),l=r(v(i));t(l,{m:"d"}),o(),a(p,i)}});var $=r(m,2);t($,{display:!0,m:`
          \\sum_{h=1}^{{\\small\\lfloor} \\log_d {\\small(} \\mathstrut n (d-1) {\\small)} {\\small\\rfloor} + 1} \\Bigl\\lceil \\frac{n}{d^h} \\Bigr\\rceil \\cdot (dh - d)
          = dn \\sum_{h=1}^{{\\small\\lfloor} \\log_d {\\small(} \\mathstrut n (d-1) {\\small)} {\\small\\rfloor} + 1} \\frac{h-1}{d^h}
          = \\frac{d^2}{(d-1)^2} \\cdot n + O(\\log_d n)
          `});var _=r($,2);h(_,{children:(p,e)=>{o();var i=Do(),l=r(v(i));t(l,{m:"d"});var c=r(l,2);t(c,{m:"d / (d-1)^2 \\cdot n + O(\\log_d n)"}),o(),a(p,i)}}),a(s,n)}});var Lr=r(qr,2);u(Lr,{children:(s,b)=>{var n=Vo(),m=v(n);h(m,{children:(_,p)=>{o();var e=x("То есть операции выполняются за время");a(_,e)}});var $=r(m,2);Er($,{children:(_,p)=>{var e=Qo(),i=v(e);k(i,{children:(f,g)=>{o();var P=Wo(),y=r(v(P));t(y,{m:"O(\\log_d n)"}),a(f,P)}});var l=r(i,2);k(l,{children:(f,g)=>{o();var P=Jo(),y=r(v(P));t(y,{m:"O(d \\log_d n)"}),a(f,P)}});var c=r(l,2);k(c,{children:(f,g)=>{o();var P=No(),y=r(v(P));t(y,{m:"d"});var L=r(y,2);t(L,{m:"O(n)"}),a(f,P)}}),a(_,e)}}),a(s,n)}});var jr=r(Lr,2);u(jr,{children:(s,b)=>{h(s,{children:(n,m)=>{o();var $=Xo(),_=r(v($));t(_,{m:"d"});var p=r(_,2);t(p,{m:"d"});var e=r(p,2);t(e,{m:"\\log_d \\bigr( n (d-1) \\bigr)"});var i=r(e,2);t(i,{m:"n"});var l=r(i,2);t(l,{m:"d"});var c=r(l,2);t(c,{m:"d=2"});var f=r(c,2);t(f,{m:"d=20"}),o(),a(n,$)}})}});var Cr=r(jr,2);I(Cr,{get src(){return Nr}});var kr=r(Cr,2);M(kr,{children:(s,b)=>{o();var n=x("Упражнения");a(s,n)}});var Sr=r(kr,2);Tr(Sr,{children:(s,b)=>{var n=_a(),m=v(n);Hr(m,{number:1,type:"implement",children:(_,p)=>{var e=na(),i=v(e);u(i,{children:(f,g)=>{var P=Yo(),y=v(P);h(y,{children:(E,H)=>{o();var R=x("Реализуйте бинарную кучу на массиве.");a(E,R)}});var L=r(y,2);h(L,{children:(E,H)=>{o();var R=x("Необходимо реализовать поддержку следующих операций");a(E,R)}}),a(f,P)}});var l=r(i,2);Er(l,{wide:!0,children:(f,g)=>{var P=Zo(),y=v(P);k(y,{children:(O,C)=>{h(O,{children:(w,S)=>{var q=zo(),B=v(q);j(B,{c:"heapify(array a)"}),o(),a(w,q)}})}});var L=r(y,2);k(L,{children:(O,C)=>{h(O,{children:(w,S)=>{var q=Ao(),B=v(q);j(B,{c:"insert(object x)"});var T=r(B,2);j(T,{c:"x"}),o(),a(w,q)}})}});var E=r(L,2);k(E,{children:(O,C)=>{h(O,{children:(w,S)=>{var q=Fo(),B=v(q);j(B,{c:"change(int i, object x)"});var T=r(B,2);j(T,{c:"i"});var Ur=r(T,2);j(Ur,{c:"x"}),a(w,q)}})}});var H=r(E,2);k(H,{children:(O,C)=>{h(O,{children:(w,S)=>{var q=Go(),B=v(q);j(B,{c:"extract_min()"}),o(),a(w,q)}})}});var R=r(H,2);k(R,{children:(O,C)=>{h(O,{children:(w,S)=>{var q=Ko(),B=v(q);j(B,{c:"peek_min()"}),o(),a(w,q)}})}}),a(f,P)}});var c=r(l,2);u(c,{children:(f,g)=>{var P=ea(),y=v(P);h(y,{children:(H,R)=>{o();var O=ra(),C=r(v(O));j(C,{c:"insert(object x)"});var w=r(C,2);j(w,{c:"change(int i, object x)"});var S=r(w,2);j(S,{c:"extract_min()"});var q=r(S,2);t(q,{m:"n"}),o(),a(H,O)}});var L=r(y,2);h(L,{children:(H,R)=>{o();var O=oa(),C=r(v(O));t(C,{m:"n"});var w=r(C,2);t(w,{m:"\\log n"}),o(),a(H,O)}});var E=r(L,2);h(E,{children:(H,R)=>{o();var O=aa(),C=r(v(O));j(C,{c:"heapify(array a)"});var w=r(C,2);t(w,{m:"n"}),o(),a(H,O)}}),a(f,P)}}),a(_,e)}});var $=r(m,2);Hr($,{number:2,type:"implement",children:(_,p)=>{u(_,{children:(e,i)=>{h(e,{children:(l,c)=>{o();var f=ta(),g=r(v(f),3);t(g,{m:"\\{1, 2, \\dotsc, n\\}"});var P=r(g,2);t(P,{m:"n"}),o(),a(l,f)}})}})}}),a(s,n)}}),a(Rr,W)}export{Ca as component};
