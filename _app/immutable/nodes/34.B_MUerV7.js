import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as v,a as d,b as t,s as r,n as o,t as y}from"../chunks/BWp35gWV.js";import{H as z}from"../chunks/DXKx2xvL.js";import{S as A}from"../chunks/LIUKG8Hf.js";import{P as x}from"../chunks/B7flgP-x.js";import{M as a}from"../chunks/BqyEoRxA.js";import{C as K}from"../chunks/BvAJckrt.js";import{S as Q}from"../chunks/CBbFRhrb.js";import{P as R}from"../chunks/DPzc5wQr.js";import{T as U}from"../chunks/CR7k0xtG.js";var V=v(`Пусть <!>.
    Мы хотим найти корень <!>, то есть такую точку <!>, что`,1),W=v("<!> <!>",1),X=v(`Пусть <!>.
    Мы хотим найти корень <!>, то есть такой вектор <!>, что`,1),Y=v("<!> <!>",1),Z=v(`Будем опять находить решение итеративно.
    Пусть <!> &mdash; какое-то приближённое решение задачи, и мы хотим улучшить это решение.
    То есть мы хотим найти такое <!>, чтобы <!>.`,1),rr=v(`Мы очень хотим выбрать такой шаг <!>, чтобы <!>.
    Используем предыдущую формулу`,1),ar=v(`Теперь нам нужно выбрать вектор <!>, по которому нужно двигаться.
    Учитывая, что градиент &mdash; направление наибыстрейшего подъема, кажется естественным выбрать вектор <!> так, чтобы он был коллинеарен градиенту`,1),or=v(`Осталось решить уравнение <!>.
    Получаем`,1),er=v("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),tr=v(`Напишем алгоритм в псевдокоде.
    Для этого нам нужно уметь вычислять функцию <!> и её градиент <!>.`,1),nr=v(`Наш метод будет работать только если начальное значение <!> уже близко к корню.
    Если это не так, то у нас точно возникнет большое количество проблем.`,1),_r=v(`Вместо поиска корня <!> можно найти минимум функции <!>.
    В принципе, для этого можно использовать и другие алгоритмы, но мы посмотрим на алгоритм Ньютона.`,1),dr=v("<!> <!> <!>",1),vr=v(`Пусть <!> &mdash; многомерная функция.
    Мы хотим научиться решать уравнение <!>.`,1),lr=v("Действовать придётся итеративно, начиная с какого-то приближения <!>.",1),sr=v("<!> <!>",1),mr=v("Вспомним формулу для линеаризации, где <!> &mdash; какой-то небольшой шаг:",1),ir=v(`Попробуем выбрать <!> так, чтобы <!>.
    Используем приближение`,1),fr=v(`У нас получилась система линейных уравнений относительно <!>.
    Решаем, находя обратную матрицу`,1),xr=v("<!> <!> <!> <!> <!> <!>",1),cr=v(`Получается, для решения уравнения <!>, нужно выполнять итеративный процесс,
    начиная с точки <!>`,1),pr=v("<!> <!>",1),$r=v("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Tr(B){var D=$r(),j=d(D);U(j,{title:"Метод Ньютона"});var T=r(j,2);A(T,{title:"Нахождение корня функции",children:(s,P)=>{var e=W(),m=d(e);x(m,{children:(i,c)=>{o();var l=V(),n=r(d(l));a(n,{m:"f \\colon \\RR \\to \\RR"});var _=r(n,2);a(_,{m:"f"});var h=r(_,2);a(h,{m:"x^* \\in \\RR"}),o(),t(i,l)}});var f=r(m,2);a(f,{display:!0,m:"f(x^*) = 0"}),t(s,e)}});var S=r(T,2);z(S,{children:(s,P)=>{o();var e=y("Скалярная функция многих переменных");t(s,e)}});var q=r(S,2);A(q,{title:"Нахождение корня скалярной функции многих переменных",children:(s,P)=>{var e=Y(),m=d(e);x(m,{children:(i,c)=>{o();var l=X(),n=r(d(l));a(n,{m:"f \\colon \\RR^n \\to \\RR"});var _=r(n,2);a(_,{m:"f"});var h=r(_,2);a(h,{m:"x^* \\in \\RR^n"}),o(),t(i,l)}});var f=r(m,2);a(f,{display:!0,m:"f(x^*) = 0"}),t(s,e)}});var w=r(q,2);R(w,{children:(s,P)=>{var e=er(),m=d(e);x(m,{children:($,F)=>{o();var p=Z(),b=r(d(p));a(b,{m:"x_k"});var u=r(b,2);a(u,{m:"\\Delta x"});var J=r(u,2);a(J,{m:"f(x_k + \\Delta x) = 0"}),o(),t($,p)}});var f=r(m,2);x(f,{children:($,F)=>{o();var p=y("По формуле Тейлора");t($,p)}});var i=r(f,2);a(i,{display:!0,m:"f(x_k + \\Delta x) \\approx f(x_k) + \\nabla f (x_k) ^\\T \\cdot \\Delta x"});var c=r(i,2);x(c,{children:($,F)=>{o();var p=rr(),b=r(d(p));a(b,{m:"\\Delta x"});var u=r(b,2);a(u,{m:"f(x_k + \\Delta x) = 0"}),o(),t($,p)}});var l=r(c,2);a(l,{display:!0,m:"f(x_k) + \\nabla f (x_k) ^\\T \\cdot \\Delta x \\approx 0"});var n=r(l,2);x(n,{children:($,F)=>{o();var p=ar(),b=r(d(p));a(b,{m:"\\Delta x"});var u=r(b,2);a(u,{m:"\\Delta x"}),o(),t($,p)}});var _=r(n,2);a(_,{display:!0,m:"\\Delta x = - \\alpha \\cdot \\nabla f (x_k)"});var h=r(_,2);x(h,{children:($,F)=>{o();var p=or(),b=r(d(p));a(b,{m:"f(x_k) + \\nabla f (x_k) ^\\T \\cdot (- \\alpha \\cdot \\nabla f (x_k)) = 0"}),o(),t($,p)}});var g=r(h,2);a(g,{display:!0,m:"\\alpha = \\frac{f(x_k)}{\\nabla f (x_k) \\cdot \\nabla f (x_k) ^\\T} = \\frac{f(x_k)}{ \\|\\nabla f (x_k)\\|_2^2}"});var k=r(g,2);x(k,{children:($,F)=>{o();var p=y(`Мы поняли, как выбирать шаг, для того чтобы двигаться к нулю все ближе.
    Результирующий алгоритм состоит всего из одной формулы`);t($,p)}}),t(s,e)}});var C=r(w,2);a(C,{display:!0,m:"x_{k+1} = x_k - \\frac{f(x_k)}{\\| \\nabla f (x_k) \\|_2^2} \\cdot \\nabla f (x_k)"});var H=r(C,2);R(H,{children:(s,P)=>{x(s,{children:(e,m)=>{o();var f=tr(),i=r(d(f));a(i,{m:"f"});var c=r(i,2);a(c,{m:"\\nabla f"}),o(),t(e,f)}})}});var M=r(H,2);K(M,{code:`
function f(vector x) -> real: ...
function gradient(vector[real] x) -> vector[real]: ...

function solve_by_newton(f, gradient) -> real:
    select x: real

    while f(x) >= EPSILON:
        x = f(x) / (norm(gradient(x)) ** 2) * gradient(x)

    return x
`});var E=r(M,2);Q(E,{children:(s,P)=>{o();var e=y("Далёкие от корня значения");t(s,e)}});var I=r(E,2);R(I,{children:(s,P)=>{var e=dr(),m=d(e);x(m,{children:(c,l)=>{o();var n=nr(),_=r(d(n));a(_,{m:"x_0"}),o(),t(c,n)}});var f=r(m,2);x(f,{children:(c,l)=>{o();var n=_r(),_=r(d(n));a(_,{m:"f"});var h=r(_,2);a(h,{m:"\\frac{1}{2} f(x)^2"}),o(),t(c,n)}});var i=r(f,2);a(i,{display:!0,m:`\\nabla \\left( \\frac{1}{2} \\cdot f^2 \\right) = f \\cdot \\nabla f \\quad\\text{и}\\quad
    \\hess \\left( \\frac{1}{2} \\cdot f^2 \\right) = \\nabla f \\cdot \\nabla f ^\\T + f \\cdot \\hess f`}),t(s,e)}});var L=r(I,2);z(L,{children:(s,P)=>{o();var e=y("Многомерные функции");t(s,e)}});var N=r(L,2);R(N,{children:(s,P)=>{var e=sr(),m=d(e);x(m,{children:(i,c)=>{o();var l=vr(),n=r(d(l));a(n,{m:"F \\colon \\RR^n \\to \\RR^n"});var _=r(n,2);a(_,{m:"F(x) = \\0"}),o(),t(i,l)}});var f=r(m,2);x(f,{children:(i,c)=>{o();var l=lr(),n=r(d(l));a(n,{m:"x_0 \\in \\RR^n"}),o(),t(i,l)}}),t(s,e)}});var O=r(N,2);R(O,{children:(s,P)=>{var e=xr(),m=d(e);x(m,{children:(_,h)=>{o();var g=mr(),k=r(d(g));a(k,{m:"h \\in \\RR^n"}),o(),t(_,g)}});var f=r(m,2);a(f,{display:!0,m:"F(x + h) = F(x) + \\jacobi F (x) \\cdot h + o \\bigl( \\| h \\| \\bigr)"});var i=r(f,2);x(i,{children:(_,h)=>{o();var g=ir(),k=r(d(g));a(k,{m:"h"});var $=r(k,2);a($,{m:"F(x+h) = \\0"}),o(),t(_,g)}});var c=r(i,2);a(c,{display:!0,m:"\\0 = F(x+h) \\approx F(x) + \\jacobi F (x) \\cdot h"});var l=r(c,2);x(l,{children:(_,h)=>{o();var g=fr(),k=r(d(g));a(k,{m:"h"}),o(),t(_,g)}});var n=r(l,2);a(n,{display:!0,m:"\\jacobi F (x) \\cdot h = - F(x) \\implies h = - \\bigl( \\jacobi F (x) \\bigr)^{-1} \\cdot F(x)"}),t(s,e)}});var G=r(O,2);R(G,{children:(s,P)=>{var e=pr(),m=d(e);x(m,{children:(i,c)=>{o();var l=cr(),n=r(d(l));a(n,{m:"F(x) = \\0"});var _=r(n,2);a(_,{m:"x_0"}),t(i,l)}});var f=r(m,2);a(f,{display:!0,m:"x_{j+1} = x_j - \\bigl( \\jacobi F (x_j) \\bigr)^{-1} \\cdot F(x_j)"}),t(s,e)}}),t(B,D)}export{Tr as component};
