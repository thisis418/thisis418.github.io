import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as c,a as m,b as o,s as a,n as t,t as i}from"../chunks/BWp35gWV.js";import{T as Y}from"../chunks/CR7k0xtG.js";import{P}from"../chunks/DPzc5wQr.js";import{P as d}from"../chunks/B7flgP-x.js";import{M as O}from"../chunks/BqyEoRxA.js";import{C as Z}from"../chunks/BmgYHZay.js";import{H as Q}from"../chunks/DXKx2xvL.js";/* empty css                *//* empty css                */import{S as R}from"../chunks/CBbFRhrb.js";import{C as f}from"../chunks/BvAJckrt.js";/* empty css                *//* empty css                *//* empty css                */var rr=c("<!> <!> <!>",1),or=c(`Скорость работы памяти и кэшей измеряется по двум разным величинам.
    Это <b>latency</b> &mdash; задержка между моментом начала чтения или записи и моментом поступления данных
    и <b>bandwidth (пропускная способность)</b> &mdash; число операций в памяти,
    которые могут быть обработаны за единицу времени.`,1),er=c("<b>Кэш L1 &mdash; кеш первого уровня.</b>"),nr=c("<!> <!> <!> <!>",1),ar=c("<b>Кэш L2 &mdash; кеш второго уровня.</b>"),tr=c("<!> <!> <!> <!>",1),sr=c("<b>Кэш L3 &mdash; кеш третьего уровня.</b>"),vr=c("<!> <!> <!> <!>",1),dr=c(`<b>Линия кэша (cache line)</b> &mdash; минимальная единица обмена данными между уровнями кэша и оперативной памятью.
    Размер линии кэша у большинства процессоров составляет 64 байта.`,1),_r=c(`Когда процессор читает из памяти один байт, в кэш загружается вся линия в 64 байта, содержащая этот байт.
    Таким образом обеспечивается локальность данных в кэше, а сама идея такой работы пошла
    из <b>принципа локальности</b>: если программа обратилась к одному байту,
    то высока вероятность, что вскоре она обратится и к соседним.`,1),lr=c("<!> <!>",1),$r=c("<b>Прямая ассоциативность</b> или прямо отображаемый кэш (direct-mapped cache).",1),ir=c("<!> <!> <!>",1),pr=c("<b>Полная ассоциативность</b> (fully associative cache).",1),cr=c("<!> <!> <!>",1),hr=c("<b>Частично-ассоциативный кэш</b> (set associative cache).",1),Pr=c("<!> <!> <!> <!>",1),mr=c(`В моем примере программа, прибавляющая ко всем элементам массива <!>,
    использует оба режима доступа: сначала читает из памяти значение элемента,
    а потом записывает в память результат инкремента.`,1),fr=c("<!> <!> <!>",1),Lr=c(`Обе программы отлично векторизуются современными компиляторами.
    Более того, программа с чистой записью может полностью превратиться в вызов <!>,
    что минимизирует нагрузку на процессор в случае, если массив выходит за границы кэша L1.`,1),xr=c("<!> <!>",1),gr=c(`<b>Кэш L1.</b> Кэш L1 физически находится в ядре процессора, работает на его частоте и имеет широкие двунаправленные шины.
    Ограничения здесь возникают в самом конвейере исполнения.`,1),br=c("<!> <!> <!>",1),ur=c(`<b>Кэш L2.</b> Кэш L2 находится за пределами ядра, но на том же кристале.
    Шины всё еще достаточно широкие и двунаправленные.
    Расстояние от кэша L2 до кэша L1 и до ядра приличное, но не очень большое.`,1),Cr=c(`В смешанном режиме префетчер не может эффективно работать со смешанной нагрузкой,
    потому что шаблон доступа к памяти становится сложнее, когда чередуются операции чтения и записи.
    Также кэш L2 имеет ограниченные буферы для отслеживания шаблонов,
    поэтому смешанный режим в <!> раза быстрее заполнит эти буферы.`,1),Ur=c("<!> <!> <!> <!>",1),wr=c(`<b>Кэш L3.</b> Кэш L3 общий для всех ядер.
    Используется межядерная шина с ячеистой и/или кольцевой топологией.
    Это создает дополнительные накладные расходы на поддержание когерентности данных между ядрами.`,1),Sr=c("<!> <!> <!>",1),yr=c("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Nr(V){var L=yr(),x=m(L);Y(x,{title:"Процессорный кэш"});var g=a(x,2);P(g,{children:(_,h)=>{var e=rr(),l=m(e);d(l,{children:(s,r)=>{t();var n=i(`Процессор работает на частотах в несколько гигагерц, а оперативная память — на частотах в сотни мегагерц.
    Это создает огромный разрыв в скорости.
    Если бы процессор каждый раз ждал данные из оперативной памяти, он простаивал бы десятки, а то и сотни тактов.`);o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=i(`Кэш процессора — это чрезвычайно быстрая, но небольшая память на кристалле,
    служащая буфером между ядром и оперативной памятью.
    Для максимальной эффективности он организован в виде иерархии из нескольких уровней,
    где уровни, расположенные ближе к ядру, обладают наименьшей латентностью и скоростью доступа, но и меньшим объемом,
    в то время как более удаленные уровни больше по размеру, но немного медленнее.`);o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i(`Эта система позволяет хранить копии наиболее востребованных данных и инструкций,
    обеспечивая процессору практически мгновенный доступ к ним,
    что кардинально повышает общую производительность системы.`);o(s,n)}}),o(_,e)}});var b=a(g,2);P(b,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=or();t(4),o(e,v)}})}});var u=a(b,2);Q(u,{children:(_,h)=>{t();var e=i("Иерархия и организация кешей");o(_,e)}});var C=a(u,2);R(C,{children:(_,h)=>{t();var e=i("Иерархия");o(_,e)}});var U=a(C,2);P(U,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=i("Сразу скажу, что у каждого вида кэша может быть несколько экземпляров.");o(e,v)}})}});var w=a(U,2);P(w,{children:(_,h)=>{var e=nr(),l=m(e);d(l,{children:(r,n)=>{var $=er();o(r,$)}});var v=a(l,2);d(v,{children:(r,n)=>{t();var $=i(`Самый быстрый кэш, доступ к нему происходит за 1–3 такта.
    Находится непосредственно в каждом ядре.`);o(r,$)}});var p=a(v,2);d(p,{children:(r,n)=>{t();var $=i(`Обычно разделён на два отдельных кэша:
    кэш инструкций (L1i), хранящий инструкции процессора, и кэш данных (L1d), хранящий данные для операций.
    Такое разделение позволяет одновременно читать инструкцию и данные к ней.
    Также такое разделение позволяет оптимизировать структуру под разные шаблоны доступа.`);o(r,$)}});var s=a(p,2);d(s,{children:(r,n)=>{t();var $=i(`Обычно занимает объём 32–64 КБ на каждый экземпляр,
    при этом экземпляры кэша L1d чаще всего чуть больше экземпляров кэш L1i.`);o(r,$)}}),o(_,e)}});var S=a(w,2);P(S,{children:(_,h)=>{var e=tr(),l=m(e);d(l,{children:(r,n)=>{var $=ar();o(r,$)}});var v=a(l,2);d(v,{children:(r,n)=>{t();var $=i(`Медленнее L1, доступ к нему происходит за 10–20 тактов.
    Экземпляр такого кеша быть для каждого ядра свой, а может быть общий для пары ядер.
    Находится часто не прям в ядре, а на той же части кристала, что и ядро.`);o(r,$)}});var p=a(v,2);d(p,{children:(r,n)=>{t();var $=i(`Унифицированный кэш, то есть хранит одновременно и инструкции, и данные.
    Служит буфером между кэшами L1 и L3.`);o(r,$)}});var s=a(p,2);d(s,{children:(r,n)=>{t();var $=i("Обычно экземпляр занимает объём 256 КБ – 1 МБ на обычных CPU и 1–2 МБ на современных мощных CPU.");o(r,$)}}),o(_,e)}});var y=a(S,2);P(y,{children:(_,h)=>{var e=vr(),l=m(e);d(l,{children:(r,n)=>{var $=sr();o(r,$)}});var v=a(l,2);d(v,{children:(r,n)=>{t();var $=i(`Значительно медленнее L2, доступ к нему происходит за 30–50 тактов.
    Располагается на кристале процессора, но является общим для всех ядер.
    Чаще всего имеет всего один экземпляр.`);o(r,$)}});var p=a(v,2);d(p,{children:(r,n)=>{t();var $=i(`Унифицированный кэш, имеющий сложный механизм для обеспечения согласованности данных между кэшами разных ядер.
    На нём работает самый эффективный префетч, который предсказывает,
    к каким данным из оперативной памяти будет в дальнейшем обращаться процессор.`);o(r,$)}});var s=a(p,2);d(s,{children:(r,n)=>{t();var $=i("Обычно экземпляр занимает объём 4–8 МБ на обычных CPU и 8–32 МБ на современных мощных CPU.");o(r,$)}}),o(_,e)}});var k=a(y,2);P(k,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=i(`Вся иерархия кэшей работает примерно по следующему принципу.
    Сначала ядро процессора ищет данные или инструкцию в кэше L1.
    Если в кэше L1 нет нужной информации, то есть если случился промах в кэше L1, то ядро обращается к кэшу L2.
    Если данных или инструкции нет и в кэше L2, то ядро обращается в L3.
    И только в случае промаха во всех уровнях происходит обращение к оперативной памяти.
    При этом найденные данные поднимаются наверх по иерархии.`);o(e,v)}})}});var H=a(k,2);P(H,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=i("Посмотреть на количество экземпляров кэшей и их размер на вашем компьютере (в linux) можно с помощью команды");o(e,v)}})}});var M=a(H,2);f(M,{language:"shell",code:"lscpu | grep 'cache'"});var T=a(M,2);R(T,{children:(_,h)=>{t();var e=i("Организация кэшей");o(_,e)}});var q=a(T,2);P(q,{children:(_,h)=>{var e=lr(),l=m(e);d(l,{children:(p,s)=>{var r=dr();t(),o(p,r)}});var v=a(l,2);d(v,{children:(p,s)=>{t();var r=_r();t(2),o(p,r)}}),o(_,e)}});var j=a(q,2);P(j,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=i(`Кэши организованы по принципу ассоциативности, который определяет гибкость размещения данных в кэше.
    Существует три основных типа ассоциативности:`);o(e,v)}})}});var z=a(j,2);P(z,{children:(_,h)=>{var e=ir(),l=m(e);d(l,{children:(s,r)=>{var n=$r();t(),o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=i(`Каждая линия из памяти может быть помещена только в одно конкретное место в кэше.
    Можно мысленно разделить кэш на ячейки, и тогда по адресу ячейки памяти однозначно определяется номер ячейки кэша,
    куда будет помещены данные из той ячейки памяти.`);o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i(`У этого типа ассоциативности есть одна серьезная проблема: конфликты.
    Если две часто используемые переменные претендуют на одно и то же место в кэше,
    то они будут постоянно вытеснять друг друга, вызывая лавину промахов в кэше, даже если он в целом пуст.`);o(s,n)}}),o(_,e)}});var A=a(z,2);P(A,{children:(_,h)=>{var e=cr(),l=m(e);d(l,{children:(s,r)=>{var n=pr();t(),o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=i("Каждая линия из памяти может быть помещена в любое место кэша.");o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i(`С точки зрения конфликтов минимизации конфликтов такой тип ассоциативности идеален.
    К сожалению, поиск в таком кэше будет занимать много времени, ведь нам нужно будет проверить все линии кэша.
    Для больших кэшей такой тип ассоциативности неприменим.`);o(s,n)}}),o(_,e)}});var B=a(A,2);P(B,{children:(_,h)=>{var e=Pr(),l=m(e);d(l,{children:(r,n)=>{var $=hr();t(),o(r,$)}});var v=a(l,2);d(v,{children:(r,n)=>{t();var $=i(`Кэш делится на бакеты (sets). Каждый бакет содержит фиксированное количество каналов (ways).
    Каждая линия из памяти может быть помещена в любой канал одного конкретного бакета.
    Номер бакета определяется по адресу ячейки памяти.`);o(r,$)}});var p=a(v,2);d(p,{children:(r,n)=>{t();var $=i("Здесь убираются недостатки предыдущих типов ассоциативности.");o(r,$)}});var s=a(p,2);d(s,{children:(r,n)=>{t();var $=i(`Именно такой тип ассоциативности используется в современных процессорах.
    Кэш L1 является 8-канальным или полностью ассоциативным.
    Кэш L2 может иметь 8 или 16 каналов.
    Кэш L3 может иметь от 12 до 32 каналов.`);o(r,$)}}),o(_,e)}});var D=a(B,2);Q(D,{children:(_,h)=>{t();var e=i("Пропускная способность");o(_,e)}});var E=a(D,2);P(E,{children:(_,h)=>{d(_,{children:(e,l)=>{t();var v=i(`Все слои кэша процессора размещены на том же чипе, что и сам процессор,
    поэтому пропускная способность, задержка и все остальные характеристики масштабируются вместе с тактовой частотой.
    Оперативная память, в свою очередь, работает на своей фиксированной частоте,
    и её характеристики остаются неизменными.`);o(e,v)}})}});var F=a(E,2);P(F,{children:(_,h)=>{var e=fr(),l=m(e);d(l,{children:(s,r)=>{t();var n=i(`К кэшу, равно как и к памяти, есть два разных режима доступа: чтение и запись.
    Режимы работают по-разному и имеют разное влияние на эффективность программы.`);o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=mr(),$=a(m(n));O($,{m:"1"}),t(),o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i("Давайте разграничим режимы доступа к памяти");o(s,n)}}),o(_,e)}});var G=a(F,2);f(G,{code:`
for (int i = 0; i < n; i++)
    s += a[i];
`});var I=a(G,2);f(I,{code:`
for (int i = 0; i < n; i++)
    a[i] = 0;
`});var J=a(I,2);P(J,{children:(_,h)=>{var e=xr(),l=m(e);d(l,{children:(p,s)=>{t();var r=Lr(),n=a(m(r));Z(n,{language:"cpp",c:"memset"}),t(),o(p,r)}});var v=a(l,2);d(v,{children:(p,s)=>{t();var r=i(`Но однонаправленный и двунаправленный доступ к памяти работают по-разному.
    Понятно, что для каждого уровня иерархии памяти на производительность влияют разные вещи.
    Разберем подробнее, кто и как на что влияет.`);o(p,r)}}),o(_,e)}});var K=a(J,2);P(K,{children:(_,h)=>{var e=br(),l=m(e);d(l,{children:(s,r)=>{var n=gr();t(),o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=i(`Современные процессоры имеют 2–4 порта LSU, каждый порт может обрабатывать 1 операцию за такт.
    В случае с одновременной работы в обоих режимах каждая операция store зависит от операций load,
    поэтому высокой эффективность здесь добиться не получится.`);o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i(`Кэш L1 разделён на 6–8 банков — независимых модулей памяти,
    которые могут параллельно обслуживать операции доступа. Один банк может обслуживать 1 операцию за такт.
    Даже если в процессоре есть свободные порты LSU, они могут и не работать параллельно,
    если оба обращения идут в один банк памяти кэша L1.`);o(s,n)}}),o(_,e)}});var N=a(K,2);P(N,{children:(_,h)=>{var e=Ur(),l=m(e);d(l,{children:(r,n)=>{var $=ur();t(),o(r,$)}});var v=a(l,2);d(v,{children:(r,n)=>{t();var $=i(`В одном режиме работы заметной разницы между кэшем L2 и кэшем L1 практически нет:
    префетчер прекрасно обнаруживает шаблон доступа и подгружает все данные в кеш.`);o(r,$)}});var p=a(v,2);d(p,{children:(r,n)=>{t();var $=Cr(),X=a(m($));O(X,{m:"2"}),t(),o(r,$)}});var s=a(p,2);d(s,{children:(r,n)=>{t();var $=i(`Промахи в кеше L1, конечно, тоже играют свою роль,
    но их вклад незначительный из-за физической близости кешей L1 и L2.`);o(r,$)}}),o(_,e)}});var W=a(N,2);P(W,{children:(_,h)=>{var e=Sr(),l=m(e);d(l,{children:(s,r)=>{var n=wr();t(),o(s,n)}});var v=a(l,2);d(v,{children:(s,r)=>{t();var n=i(`При операции записи в L3 требуется инвалидировать соответствующие строки в кеши L1 и L2 других ядер,
    что порождает дополнительные транзакции по межядерной шине.
    Получается, что операция записи требует несколько транзакций
    (минимум invalidation request, acknowledge, write data).`);o(s,n)}});var p=a(v,2);d(p,{children:(s,r)=>{t();var n=i(`Ограниченная пропускная способность межядерной шины и арбитраж доступа между транзакциями чтения и записи
    создают конкуренцию, особенно при многопоточном доступе к одним данным.`);o(s,n)}}),o(_,e)}}),o(V,L)}export{Nr as component};
