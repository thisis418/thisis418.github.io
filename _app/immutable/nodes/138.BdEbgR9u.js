import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as h,a as f,b as e,s as r,t as l,n}from"../chunks/BWp35gWV.js";import{T as V}from"../chunks/CR7k0xtG.js";import{P as d}from"../chunks/B7flgP-x.js";import{P as g}from"../chunks/DPzc5wQr.js";import"../chunks/i9XClpbl.js";/* empty css                */import{M as x}from"../chunks/BqyEoRxA.js";import{E as W}from"../chunks/BJkbutPt.js";/* empty css                */import{L as u}from"../chunks/NE91WFFs.js";import{D as Y}from"../chunks/DlTIf4aM.js";import{H as I}from"../chunks/DXKx2xvL.js";import{C as K}from"../chunks/BvAJckrt.js";import{I as Z}from"../chunks/Cv_jjTLk.js";import{S as rr}from"../chunks/CBbFRhrb.js";const or=""+new URL("../assets/linked-list-in-memory.CmFSs5ID.svg",import.meta.url).href;var tr=h(`<b>Линейный список</b> &mdash; последовательность узлов (nodes), в которых хранятся записи.
    Все <!> узлов <!> логически организованы последовательно.
    То есть узел <!> следует за узлом <!> и предшествует узлу <!> для всех <!>.`,1),er=h("<!> <!>",1),nr=h("Получение доступа к <!>-му узлу списка для чтения, изменения полей записи и т.д.",1),ar=h("Вставка нового узла сразу после или до <!>-го узла списка",1),sr=h("Удаление <!>-го узла из списка",1),dr=h("<!> <!> <!> <!> <!> <!>",1),lr=h(`Отдельного внимания заслуживают операции 1-3 при граничных случаях <!> и <!>.
    При таком условии эти операции можно выполнять в общем случае эффективнее и проще.`,1),_r=h("<!> <!>",1),vr=h(`Линейные списки, упорядоченные посредством ссылок называются <b>связными</b> списками.
    Есть несколько типов связных списков, которые я предлагаю подробно рассмотреть.`,1),$r=h("<!> <!> <!>",1),ir=h(`Связный список, в котором в каждом узле хранится только ссылка на следующий элемент,
    называется <b>односвязным списком</b> (одна связь).`,1),pr=h("<!> <!>",1),mr=h("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Er(N){var S=mr(),C=f(S);V(C,{title:"Линейные и связные списки"});var D=r(C,2);g(D,{children:(t,$)=>{d(t,{children:(o,_)=>{n();var a=l(`Давайте обсудим способы линейного представления набора данных.
    Хранить данные из набора мы будем в линейном списке.`);e(o,a)}})}});var M=r(D,2);Y(M,{title:"Линейный список",children:(t,$)=>{d(t,{children:(o,_)=>{var a=tr(),v=r(f(a),2);x(v,{m:"n"});var i=r(v,2);x(i,{m:"x_1, x_2, \\dotsc, x_n"});var s=r(i,2);x(s,{m:"x_k"});var c=r(s,2);x(c,{m:"x_{k-1}"});var p=r(c,2);x(p,{m:"x_{k+1}"});var k=r(p,2);x(k,{m:"1 < k < n"}),n(),e(o,a)}})}});var w=r(M,2);g(w,{children:(t,$)=>{var o=er(),_=f(o);d(_,{children:(v,i)=>{n();var s=l(`Обращаю внимание на то, что это только логическая упорядоченность.
    Физически узлы могут располагаться как угодно, какие-то узлы даже могут физически отсутствовать,
    главное чтобы логическая связь была такой.`);e(v,s)}});var a=r(_,2);d(a,{children:(v,i)=>{n();var s=l("С элементами линейного списка обычно совершаются следующие операции");e(v,s)}}),e(t,o)}});var y=r(w,2);W(y,{wide:!0,children:(t,$)=>{var o=dr(),_=f(o);u(_,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=nr(),L=r(f(m));x(L,{m:"k"}),n(),e(P,m)}})}});var a=r(_,2);u(a,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=ar(),L=r(f(m));x(L,{m:"k"}),n(),e(P,m)}})}});var v=r(a,2);u(v,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=sr(),L=r(f(m));x(L,{m:"k"}),n(),e(P,m)}})}});var i=r(v,2);u(i,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=l("Объединение нескольких списков в один");e(P,m)}})}});var s=r(i,2);u(s,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=l("Разбиение одного списка на несколько");e(P,m)}})}});var c=r(s,2);u(c,{children:(p,k)=>{d(p,{children:(P,b)=>{n();var m=l("Создание копии списка");e(P,m)}})}}),e(t,o)}});var E=r(y,2);g(E,{children:(t,$)=>{var o=_r(),_=f(o);d(_,{children:(v,i)=>{n();var s=l(`Сделать структуру данных, которая бы эффективно выполняла все эти операции очень сложно.
    На самом деле для большинства задач это и не нужно.`);e(v,s)}});var a=r(_,2);d(a,{children:(v,i)=>{n();var s=lr(),c=r(f(s));x(c,{m:"k=1"});var p=r(c,2);x(p,{m:"k=n"}),n(),e(v,s)}}),e(t,o)}});var H=r(E,2);I(H,{children:(t,$)=>{n();var o=l("Связные списки");e(t,o)}});var R=r(H,2);g(R,{children:(t,$)=>{var o=$r(),_=f(o);d(_,{children:(i,s)=>{n();var c=l(`Линейные списки линейными делает логическая упорядоченность их элементов.
    Естественно желание превратить логическую упорядоченность в физическую.
    Вариантов это сделать много, но мы разберём только два основных, на которых строятся все остальные.
    Давайте превратим логическое высказывание «за этим узлом следует» в физическую ссылку.`);e(i,c)}});var a=r(_,2);d(a,{children:(i,s)=>{n();var c=l(`Назовем каждый элемент линейного списка узлом, и будем в узле, помимо данных,
    хранить ещё и все нужные ссылки. Нам нужно хранить как минимум ссылку на следующий узел.
    Таким образом мы сможем физически упорядочить данные в памяти.`);e(i,c)}});var v=r(a,2);d(v,{children:(i,s)=>{n();var c=vr();n(2),e(i,c)}}),e(t,o)}});var T=r(R,2);rr(T,{children:(t,$)=>{n();var o=l("Односвязный список");e(t,o)}});var F=r(T,2);g(F,{children:(t,$)=>{var o=pr(),_=f(o);d(_,{children:(v,i)=>{n();var s=ir();n(2),e(v,s)}});var a=r(_,2);d(a,{children:(v,i)=>{n();var s=l("Структура узла представляет собой нечто подобное");e(v,s)}}),e(t,o)}});var O=r(F,2);K(O,{code:`struct node:
    ref node next
    some additional data`});var U=r(O,2);g(U,{children:(t,$)=>{d(t,{children:(o,_)=>{n();var a=l(`В памяти связные списки могут располагаться как угодно.
    Это значит, что операции вставки и удаления в уже найденное место выполняются за постоянное время,
    поскольку не требуют перемещения других элементов списка`);e(o,a)}})}});var X=r(U,2);Z(X,{get src(){return or},children:(t,$)=>{n();var o=l("Связный список в памяти");e(t,o)},$$slots:{default:!0}});var j=r(X,2);I(j,{children:(t,$)=>{n();var o=l("Двусвязные списки");e(t,o)}});var q=r(j,2);g(q,{children:(t,$)=>{d(t,{children:(o,_)=>{n();var a=l("В каждый узел связного списка можно включить не одну. а две связи: на следующий и на предыдущий узлы.");e(o,a)}})}});var z=r(q,2);K(z,{code:`struct node:
    node previous
    node next
    ...data...`});var A=r(z,2);I(A,{children:(t,$)=>{n();var o=l("Полуторасвязный список");e(t,o)}});var B=r(A,2);g(B,{children:(t,$)=>{d(t,{children:(o,_)=>{n();var a=l("Sparse list");e(o,a)}})}});var G=r(B,2);I(G,{children:(t,$)=>{n();var o=l("XOR список");e(t,o)}});var J=r(G,2);g(J,{children:(t,$)=>{d(t,{})}});var Q=r(J,2);I(Q,{children:(t,$)=>{n();var o=l("Развёрнутый список");e(t,o)}}),e(N,S)}export{Er as component};
