import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as v,a as m,b as _,s as r,n as a,t as x}from"../chunks/BWp35gWV.js";import{T as dr}from"../chunks/CR7k0xtG.js";import{P as R}from"../chunks/DPzc5wQr.js";import{P as g}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";import{H as L}from"../chunks/DXKx2xvL.js";import{S as q}from"../chunks/CBbFRhrb.js";var vr=v(`Пусть <!> &mdash; минимальное с точки зрения теории информации количество бит,
    требуемое для хранения информации о данных. <b>Компактная структура данных</b> &mdash; структура, хранящая все эти данные,
    и при этом использующая максимально близкое к <!> количество бит.`,1),tr=v("<!> <!>",1),mr=v(`<b>Компактный индексируемый словарь</b> или <b>RSD</b> (Rank-Select Dictionary) &mdash;
    битовый массив, поддерживающий две дополнительные операции rank и select.`,1),sr=v(`Сам битовый массив &mdash; массив из <!> битов
    (здесь везде индексы, а не номера, поэтому счёт начинается с <!>)`,1),ir=v("<!> <!> <!>",1),$r=v("<b>Rank</b> &mdash; операция подсчёта битов на префиксе.",1),fr=v(`<!> &mdash; количество единичных битов на префиксе длины <!>,
    то есть на позициях от <!> до <!>:`,1),gr=v(`<!> &mdash; количество нулевых битов на префиксе длины <!>,
    то есть на позициях от <!> до <!>:`,1),pr=v(`В операции rank спрятался веса Хемминга <!> (количество единичных бит в числе, popcount).
    А именно,`,1),cr=v("<!> <!> <!> <!> <!> <!> <!>",1),hr=v("<b>Select</b> &mdash; операция поиска позиции бита.",1),kr=v("<!> &mdash; позиция <!>-го единичного бита",1),br=v("<!> &mdash; позиция <!>-го нулевого бита",1),Pr=v("<!> <!> <!> <!> <!>",1),ur=v(`Rank можно считать с помощью префиксных сумм.
    Для этого нужно завести отдельный массив <!> длины <!> и хранить в нём по номеру <!> сумму на префиксе длиной <!>:`,1),jr=v("Теперь операцию rank можно выполнить за <!>, а точнее за одно обращение к массиву <!>:",1),Rr=v("<!> <!> <!> <!>",1),xr=v(`Rank &mdash; неубывающая функция, и <!> &mdash; неубывающий массив.
    Значит, значение функции select можно найти бинарным поиском по значению rank.`,1),yr=v(`Это вычисление сделает максимум <!> сравнений
    и займёт время <!>.`,1),Or=v("<!> <!>",1),qr=v("Важное уточнение по поводу занимаемой массивом <!> памяти.",1),Lr=v(`Исходные данные &mdash; битовый массив <!>, занимающий в памяти <!> бит.
    А в массиве <!> мы храним числа,
    и если это обычные <!>-битные числа,
    то занимаемая массивом <!> память составляет <!> бит.
    Это слишком много.`,1),Sr=v(`Важное замечание, которое позволит сократить память.
    В массиве <!> мы храним количества единичных битов на префиксах массива <!>,
    а оно не может быть больше <!>,
    а значит размер хранимых чисел не превышает <!> бит.`,1),wr=v(`То есть, например, если в битовом массиве <!> у нас <!> бит,
    то для чисел массива <!> можно выделять по <!> бит, а не по <!>.`,1),zr=v("В итоге занимаемая массивом <!> память оказывается <!> бит.",1),Br=v("<!> <!> <!> <!> <!>",1),Dr=v(`Можно пойти дальше, и попытаться ещё оптимизировать память. <!>, значит для хранения этого значения не нужно вообще места, <!>, значит для хранения этого значения нужно не больше <!> бита, <!>, значит для хранения этого значения нужно не больше <!> битов.
    Продолжая эти рассуждения, получаем, что для хранения <!> нужно не больше <!> бит.
    В итоге получаем, что минимальное количество памяти, требуемое для хранения массива <!>, равно`,1),Hr=v(`Результат неплохой: для битового массива <!> размером <!> МБ
    потребуется дополнительно примерно <!> ГБ на массив <!>.`,1),Mr=v(`Числа на позициях от <!> до <!> занимают <!> бит.
    Значит, в таком способе хранения число <!> записано в битах на позициях
    с <!> по <!>,
    где <!> &mdash; количество бит в числе <!>.`,1),Tr=v(`Если эта последовательность бит находится в памяти с произвольным доступом,
    то время получения значения <!> почти константное:
    нам нужно вычислить начало отсчёта и выделить <!> бит.`,1),Ar=v("<!> <!> <!> <!> <!>",1),Cr=v(`Мы смогли реализовать битовый массив,
    поддерживающий операции rank за <!> и select за <!>,
    занимающий <!> бит.`,1),Er=v(`Давайте хранить в массиве <!> сумму не всех префиксов, а только префиксов чётной длины.
    То есть`,1),Fr=v(`То есть мы сократили потребление памяти в <!> раза,
    при этом сохранив константную временную сложность вычисления операции rank.`,1),Gr=v("<!> <!> <!>. <!> <!> <!>",1),Ir=v(`Развиваем идею. Будем хранить не каждый второй префикс, а каждый <!>-й.
    Точнее, мы делим весь исходный массив <!> на блоки длиной <!>,
    и в массив <!> будем сохранять только суммы префиксов до начала каждого блока.
    То есть`,1),Jr=v("Для вычисления rank нужно найти префикс и прибавить к нему сумму не более <!> слагаемых",1),Kr=v(`Получается, что для вычисления операции rank мы совершим не более <!> операций сложения.
    Итого, мы можем считать rank за время <!> с предподсчётом за время <!>.`,1),Nr=v(`Для чисел массива <!> мы выделяем одинаковое количество бит,
    равное максимальному размеру числа &mdash; <!>.
    В итоге мы храним всего <!> бит.`,1),Qr=v(`Компромисса между скоростью и памятью достичь трудно.
    Мы хотим, чтобы rank считался как можно быстрее, а значит <!> должно быть как можно меньше.
    А ещё мы хотим, чтобы памяти занималось как можно меньше, значит <!> должно быть как можно больше.
    На самом деле компромисс искать не надо.`,1),Ur=v("<!> <!> <!> <!> <!> <!> <!>",1),Vr=v(`На минуту остановимся и подумаем, что вообще у нас получилось.
    Изначально мы пытались ответить на вопрос &laquo;какова сумма первых <!> битов?&raquo;
    Теперь, после разделения на блоки, мы пытаемся ответить на вопрос
    &laquo;какова сумма первых <!> битов блока?&raquo;
    То есть мы свели исходную задачу к меньшей.
    А эту меньшую задачу можно решить уже отработанным методом &mdash; префиксные суммы.`,1),Wr=v(`Давайте для каждого блока с индексом <!> посчитаем префиксные суммы
    и сохраним их в массив <!>.
    То есть`,1),Xr=v(`А что по памяти? В массивах <!> мы храним в сумме <!> чисел,
    при этом каждое число не превосходит <!>,
    ведь храним мы там количество бит в префиксе блока длины <!>.
    Значит, каждое число занимает максимум <!> бит,
    а все массивы <!> занимают <!> бит. Итого вся дополнительная память &mdash; память на массив <!> и на все массивы <!>:`,1),Yr=v("Минимум достигается при <!>, и",1),Zr=v("<!> <!> <!> <!> <!> <!> <!> <!> <!>",1),ro=v("Здесь мы получаем память <!>",1),oo=v("Здесь мы получаем сначала память <!>, а потом и <!>",1),ao=v("<!> <!>",1),eo=v("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function fo(nr){var S=eo(),w=m(S);dr(w,{title:"Компактные структуры данных"});var z=r(w,2);R(z,{children:($,u)=>{var d=tr(),k=m(d);g(k,{children:(f,b)=>{a();var c=vr(),t=r(m(c));o(t,{m:"z"});var h=r(t,4);o(h,{m:"z"}),a(),_(f,c)}});var p=r(k,2);g(p,{children:(f,b)=>{a();var c=x("Компактные структуры данных еще называют безызбыточными.");_(f,c)}}),_($,d)}});var B=r(z,2);L(B,{children:($,u)=>{a();var d=x("Битовые массивы");_($,d)}});var D=r(B,2);R(D,{children:($,u)=>{g($,{})}});var H=r(D,2);L(H,{children:($,u)=>{a();var d=x("Компактные индексируемые словари");_($,d)}});var M=r(H,2);R(M,{children:($,u)=>{var d=ir(),k=m(d);g(k,{children:(b,c)=>{var t=mr();a(3),_(b,t)}});var p=r(k,2);g(p,{children:(b,c)=>{a();var t=sr(),h=r(m(t));o(h,{m:"n"});var n=r(h,2);o(n,{m:"0"}),a(),_(b,t)}});var f=r(p,2);o(f,{display:!0,m:"b_0 \\, b_1 \\, b_2 \\, \\cdots \\, b_{n-2} \\, b_{n-1}"}),_($,d)}});var T=r(M,2);R(T,{children:($,u)=>{var d=cr(),k=m(d);g(k,{children:(n,l)=>{var e=$r();a(),_(n,e)}});var p=r(k,2);g(p,{children:(n,l)=>{var e=fr(),s=m(e);o(s,{m:"\\rank_1 (k)"});var i=r(s,2);o(i,{m:"k"});var P=r(i,2);o(P,{m:"0"});var j=r(P,2);o(j,{m:"k-1"}),a(),_(n,e)}});var f=r(p,2);o(f,{display:!0,m:"\\rank_1 (k) \\defeq \\sum_{j=0}^{k-1} b_j"});var b=r(f,2);g(b,{children:(n,l)=>{var e=gr(),s=m(e);o(s,{m:"\\rank_0 (k)"});var i=r(s,2);o(i,{m:"k"});var P=r(i,2);o(P,{m:"0"});var j=r(P,2);o(j,{m:"k-1"}),a(),_(n,e)}});var c=r(b,2);o(c,{display:!0,m:"\\rank_0 (k) \\defeq \\sum_{j=0}^{k-1} (1 - b_j) = k - \\sum_{j=0}^{k-1} b_j = k - \\rank_1 (k)"});var t=r(c,2);g(t,{children:(n,l)=>{a();var e=pr(),s=r(m(e));o(s,{m:"\\nu"}),a(),_(n,e)}});var h=r(t,2);o(h,{display:!0,m:"\\nu \\Bigl( \\bigl( b_0 \\, b_1 \\, b_2 \\, \\dotsm \\, b_{n-2} \\, b_{n-1} \\bigr)_2 \\Bigr) = \\rank_1 (n)"}),_($,d)}});var A=r(T,2);R(A,{children:($,u)=>{var d=Pr(),k=m(d);g(k,{children:(t,h)=>{var n=hr();a(),_(t,n)}});var p=r(k,2);g(p,{children:(t,h)=>{var n=kr(),l=m(n);o(l,{m:"\\select_1 (k)"});var e=r(l,2);o(e,{m:"k"}),a(),_(t,n)}});var f=r(p,2);o(f,{display:!0,m:"\\select_1 (k) \\defeq \\min \\bigl\\{ j : \\rank_1 (j+1) = k \\bigr\\}"});var b=r(f,2);g(b,{children:(t,h)=>{var n=br(),l=m(n);o(l,{m:"\\select_0 (k)"});var e=r(l,2);o(e,{m:"k"}),a(),_(t,n)}});var c=r(b,2);o(c,{display:!0,m:"\\select_0 (k) \\defeq \\min \\bigl\\{ j : \\rank_0 (j+1) = k \\bigr\\}"}),_($,d)}});var C=r(A,2);q(C,{children:($,u)=>{a();var d=x("Наивная реализация");_($,d)}});var E=r(C,2);R(E,{children:($,u)=>{var d=Rr(),k=m(d);g(k,{children:(c,t)=>{a();var h=ur(),n=r(m(h));o(n,{m:"R"});var l=r(n,2);o(l,{m:"n"});var e=r(l,2);o(e,{m:"k"});var s=r(e,2);o(s,{m:"k"}),a(),_(c,h)}});var p=r(k,2);o(p,{display:!0,m:"R_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{j=0}^{k-1} b_j & \\otherwise}"});var f=r(p,2);g(f,{children:(c,t)=>{a();var h=jr(),n=r(m(h));o(n,{m:"O(1)"});var l=r(n,2);o(l,{m:"R"}),a(),_(c,h)}});var b=r(f,2);o(b,{display:!0,m:"\\rank_1 (k) = R_k"}),_($,d)}});var F=r(E,2);R(F,{children:($,u)=>{var d=Or(),k=m(d);g(k,{children:(f,b)=>{a();var c=xr(),t=r(m(c));o(t,{m:"R"}),a(),_(f,c)}});var p=r(k,2);g(p,{children:(f,b)=>{a();var c=yr(),t=r(m(c));o(t,{m:"\\lfloor \\log_2 (n+1) \\rfloor + 1"});var h=r(t,2);o(h,{m:"O(\\log n)"}),a(),_(f,c)}}),_($,d)}});var G=r(F,2);R(G,{children:($,u)=>{var d=Br(),k=m(d);g(k,{children:(t,h)=>{a();var n=qr(),l=r(m(n));o(l,{m:"R"}),a(),_(t,n)}});var p=r(k,2);g(p,{children:(t,h)=>{a();var n=Lr(),l=r(m(n));o(l,{m:"b"});var e=r(l,2);o(e,{m:"n"});var s=r(e,2);o(s,{m:"R"});var i=r(s,2);o(i,{m:"64"});var P=r(i,2);o(P,{m:"R"});var j=r(P,2);o(j,{m:"64 \\cdot (n+1)"}),a(),_(t,n)}});var f=r(p,2);g(f,{children:(t,h)=>{a();var n=Sr(),l=r(m(n));o(l,{m:"R"});var e=r(l,2);o(e,{m:"b"});var s=r(e,2);o(s,{m:"n"});var i=r(s,2);o(i,{m:"\\lfloor \\log_2 n \\rfloor + 1"}),a(),_(t,n)}});var b=r(f,2);g(b,{children:(t,h)=>{a();var n=wr(),l=r(m(n));o(l,{m:"b"});var e=r(l,2);o(e,{m:"2^{10}-1"});var s=r(e,2);o(s,{m:"R"});var i=r(s,2);o(i,{m:"10"});var P=r(i,2);o(P,{m:"64"}),a(),_(t,n)}});var c=r(b,2);g(c,{children:(t,h)=>{a();var n=zr(),l=r(m(n));o(l,{m:"R"});var e=r(l,2);o(e,{m:"\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot (n + 1)"}),a(),_(t,n)}}),_($,d)}});var I=r(G,2);R(I,{children:($,u)=>{var d=Ar(),k=m(d);g(k,{children:(t,h)=>{a();var n=Dr(),l=r(m(n));o(l,{m:"R_0 = 0"});var e=r(l,2);o(e,{m:"R_1 \\le 1"});var s=r(e,2);o(s,{m:"1"});var i=r(s,2);o(i,{m:"R_2 \\le 2"});var P=r(i,2);o(P,{m:"2"});var j=r(P,2);o(j,{m:"R_k"});var y=r(j,2);o(y,{m:"\\lfloor \\log_2 k \\rfloor + 1"});var O=r(y,2);o(O,{m:"R"}),a(),_(t,n)}});var p=r(k,2);o(p,{display:!0,m:"\\sum_{k=1}^n \\bigl( \\lfloor \\log_2 k \\rfloor + 1 \\bigr) = \\sum_{d=1}^{\\lfloor \\log_2 n \\rfloor} d \\cdot 2^{d - 1} + \\bigl( \\lfloor \\log_2 n \\rfloor + 1\\bigr) \\cdot \\bigl( n - 2^{\\lfloor \\log_2 n \\rfloor} + 1 \\bigr) = \\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot (n + 1) - 2^{\\lfloor \\log_2 n \\rfloor + 1} + 1"});var f=r(p,2);g(f,{children:(t,h)=>{a();var n=Hr(),l=r(m(n));o(l,{m:"b"});var e=r(l,2);o(e,{m:"40"});var s=r(e,2);o(s,{m:"1"});var i=r(s,2);o(i,{m:"R"}),a(),_(t,n)}});var b=r(f,2);g(b,{children:(t,h)=>{a();var n=Mr(),l=r(m(n));o(l,{m:"1"});var e=r(l,2);o(e,{m:"j"});var s=r(e,2);o(s,{m:"\\sum_{k=1}^j \\bigl( \\lfloor \\log_2 k \\rfloor + 1 \\bigr) = \\bigl( \\lfloor \\log_2 j \\rfloor + 1 \\bigr) \\cdot (j + 1) - 2^{\\lfloor \\log_2 j \\rfloor + 1} + 1"});var i=r(s,2);o(i,{m:"j"});var P=r(i,2);o(P,{m:"j m - 2^m + 1"});var j=r(P,2);o(j,{m:"(j+1) \\cdot m - 2^m + 1"});var y=r(j,2);o(y,{m:"m = \\lfloor \\log_2 j \\rfloor + 1"});var O=r(y,2);o(O,{m:"j"}),a(),_(t,n)}});var c=r(b,2);g(c,{children:(t,h)=>{a();var n=Tr(),l=r(m(n));o(l,{m:"R_j"});var e=r(l,2);o(e,{m:"m"}),a(),_(t,n)}}),_($,d)}});var J=r(I,2);R(J,{children:($,u)=>{g($,{children:(d,k)=>{a();var p=Cr(),f=r(m(p));o(f,{m:"O(1)"});var b=r(f,2);o(b,{m:"O(\\log n)"});var c=r(b,2);o(c,{m:"O(n \\log n)"}),a(),_(d,p)}})}});var K=r(J,2);q(K,{children:($,u)=>{a();var d=x("Декомпозиция");_($,d)}});var N=r(K,2);R(N,{children:($,u)=>{var d=Gr(),k=m(d);g(k,{children:(h,n)=>{a();var l=x(`Наивная реализация довольно простая, и это, к сожалению, единственный её плюс.
    Всё ещё проблемой является количество дополнительной информации, требуемое для вычисления rank.
    Меньше бит на числа выделять не получится — мы и так взяли минимально возможный размер.
    Остаётся только хранить меньше чисел.`);_(h,l)}});var p=r(k,2);g(p,{children:(h,n)=>{a();var l=Er(),e=r(m(l));o(e,{m:"R"}),a(),_(h,l)}});var f=r(p,2);o(f,{display:!0,m:`R_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{j = 0}^{2 k - 1} b_j & \\otherwise}
          \\quad\\text{для}~ 0 \\le k \\le \\lfloor n/2 \\rfloor`});var b=r(f,2);g(b,{children:(h,n)=>{a();var l=x("Тогда сам rank считается по формуле");_(h,l)}});var c=r(b,2);o(c,{display:!0,m:"\\rank_1 (k) = \\cases{R_m & \\if k = 2m \\\\ R_m + b_{k-1} & \\if k = 2m - 1}"});var t=r(c,2);g(t,{children:(h,n)=>{a();var l=Fr(),e=r(m(l));o(e,{m:"2"}),a(),_(h,l)}}),_($,d)}});var Q=r(N,2);R(Q,{children:($,u)=>{var d=Ur(),k=m(d);g(k,{children:(n,l)=>{a();var e=Ir(),s=r(m(e));o(s,{m:"\\ell"});var i=r(s,2);o(i,{m:"b"});var P=r(i,2);o(P,{m:"\\ell"});var j=r(P,2);o(j,{m:"L"}),a(),_(n,e)}});var p=r(k,2);o(p,{display:!0,m:"L_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{l = 0}^{k-1} \\sum_{j=0}^{\\ell - 1} b_{l \\ell + j} = \\sum_{j=0}^{k \\ell - 1} b_j  & \\otherwise} \\quad\\text{для}~ 0 \\le k \\le \\lfloor n / \\ell \\rfloor"});var f=r(p,2);g(f,{children:(n,l)=>{a();var e=Jr(),s=r(m(e));o(s,{m:"\\ell"}),a(),_(n,e)}});var b=r(f,2);o(b,{display:!0,m:"\\rank_1 (k) = L_{\\lfloor k / \\ell \\rfloor} + \\sum_{j = \\lfloor k / \\ell \\rfloor \\cdot \\ell}^k b_j"});var c=r(b,2);g(c,{children:(n,l)=>{a();var e=Kr(),s=r(m(e));o(s,{m:"\\ell"});var i=r(s,2);o(i,{m:"O(\\ell)"});var P=r(i,2);o(P,{m:"O(n)"}),a(),_(n,e)}});var t=r(c,2);g(t,{children:(n,l)=>{a();var e=Nr(),s=r(m(e));o(s,{m:"L"});var i=r(s,2);o(i,{m:"\\lfloor \\log_2 n \\rfloor + 1"});var P=r(i,2);o(P,{m:"\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot \\lfloor n / \\ell \\rfloor = O(n \\log n / \\ell)"}),a(),_(n,e)}});var h=r(t,2);g(h,{children:(n,l)=>{a();var e=Qr(),s=r(m(e));o(s,{m:"\\ell"});var i=r(s,2);o(i,{m:"\\ell"}),a(),_(n,e)}}),_($,d)}});var U=r(Q,2);R(U,{children:($,u)=>{var d=Zr(),k=m(d);g(k,{children:(e,s)=>{a();var i=Vr(),P=r(m(i));o(P,{m:"k"});var j=r(P,2);o(j,{m:"k \\bmod \\ell"}),a(),_(e,i)}});var p=r(k,2);g(p,{children:(e,s)=>{a();var i=Wr(),P=r(m(i));o(P,{m:"s = \\lfloor k / \\ell \\rfloor"});var j=r(P,2);o(j,{m:"R_s"}),a(),_(e,i)}});var f=r(p,2);o(f,{display:!0,m:"R_s [i] = \\sum_{j = s \\ell}^{s \\ell + i} b_j "});var b=r(f,2);g(b,{children:(e,s)=>{a();var i=x("И теперь, для вычисления операции rank, надо просто сложить два числа");_(e,i)}});var c=r(b,2);o(c,{display:!0,m:"\\rank_1 (k) = L \\bigl[ \\lfloor k / \\ell \\rfloor \\bigr] + R_{\\lfloor k / \\ell \\rfloor} [k \\bmod \\ell]"});var t=r(c,2);g(t,{children:(e,s)=>{a();var i=Xr(),P=r(m(i));o(P,{m:"R_s"});var j=r(P,2);o(j,{m:"n"});var y=r(j,2);o(y,{m:"\\ell"});var O=r(y,2);o(O,{m:"\\ell"});var rr=r(O,2);o(rr,{m:"\\lfloor \\log_2 \\ell \\rfloor + 1"});var or=r(rr,2);o(or,{m:"R_s"});var ar=r(or,2);o(ar,{m:"n \\cdot \\bigl( \\lfloor \\log_2 \\ell \\rfloor + 1 \\bigr)"});var er=r(ar,2);o(er,{m:"L"});var lr=r(er,2);o(lr,{m:"R_s"}),a(),_(e,i)}});var h=r(t,2);o(h,{display:!0,m:`\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot \\lfloor n / \\ell \\rfloor
          + n \\cdot \\bigl( \\lfloor \\log_2 \\ell \\rfloor + 1 \\bigr)`});var n=r(h,2);g(n,{children:(e,s)=>{a();var i=Yr(),P=r(m(i));o(P,{m:"\\ell \\approx \\ln 2n"}),a(),_(e,i)}});var l=r(n,2);o(l,{display:!0,m:"\\min \\space \\approx n \\cdot \\left( \\frac{\\ln \\ln 2n + 1}{\\ln 2} + 1 \\right) = n \\log_2 \\ln n + O(n) = O(n \\log \\log n)"}),_($,d)}});var V=r(U,2);q(V,{children:($,u)=>{a();var d=x("Многоуровневая декомпозиция");_($,d)}});var W=r(V,2);R(W,{children:($,u)=>{g($,{children:(d,k)=>{a();var p=ro(),f=r(m(p));o(f,{m:"O(n \\log^* n)"}),_(d,p)}})}});var X=r(W,2);q(X,{children:($,u)=>{a();var d=x("Четыре русских");_($,d)}});var Y=r(X,2);R(Y,{children:($,u)=>{g($,{children:(d,k)=>{a();var p=oo(),f=r(m(p));o(f,{m:"O(n)"});var b=r(f,2);o(b,{m:"o(n)"}),_(d,p)}})}});var Z=r(Y,2);L(Z,{children:($,u)=>{a();var d=x("Разделенные строки");_($,d)}});var _r=r(Z,2);R(_r,{children:($,u)=>{var d=ao(),k=m(d);g(k,{children:(f,b)=>{a();var c=x("Рассмотрим элементарный, немного нерациональный, слишком простой пример.");_(f,c)}});var p=r(k,2);g(p,{children:(f,b)=>{a();var c=x(`Пусть у нас имеется набор строк.
    Этот набор мы превратили в одну строку, соединив исходные строки в одну.`);_(f,c)}}),_($,d)}}),_(nr,S)}export{fo as component};
