import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as c,a as x,b as o,s as r,t as n,n as t}from"../chunks/B1HoO4k0.js";import{T as Y}from"../chunks/CcX1cm_-.js";import{P as v}from"../chunks/B8FEnsbH.js";import{P as f}from"../chunks/ClksMsit.js";import"../chunks/i9XClpbl.js";/* empty css                */import{M as p}from"../chunks/e5qaD0UW.js";import{E as Z}from"../chunks/BnlOlOSM.js";/* empty css                */import{L as u}from"../chunks/_RU5sT8R.js";/* empty css                *//* empty css                */import{H}from"../chunks/VyKLllFE.js";import{C as Q}from"../chunks/DunPP-_K.js";import{I as rr}from"../chunks/Cdazp-58.js";const or=""+new URL("../assets/linked-list-in-memory.CmFSs5ID.svg",import.meta.url).href;var tr=c(`<b>Линейный список</b> &mdash; последовательность узлов (nodes), в которых хранятся записи.
    Все <!> узлов <!> таковы,
    что узел <!> следует за узлом <!> и предшествует узлу <!> для всех <!>.`,1),er=c("Получение доступа к <!>-му узлу списка для чтения, изменения полей записи и т.д.",1),ar=c("Вставка нового узла сразу после или до <!>-го узла списка",1),nr=c("Удаление <!>-го узла из списка",1),sr=c("<!> <!> <!> <!> <!> <!>",1),dr=c("<!> <!> <!> <!> <!>",1),_r=c(`Отдельного внимания заслуживают операции 1-3 при граничных случаях <!> и <!>.
    При таком условии эти операции можно выполнять в общем случае эффективнее и проще.`,1),vr=c("<!> <!>",1),lr=c("<!> <!>",1),ir=c("Такой линейный список называется <b>связным</b> (односвязным), ведь у каждого узла есть связь со следующим.",1),$r=c("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Hr(V){var S=$r(),T=x(S);Y(T,{title:"Линейные и связные списки"});var w=r(T,2);f(w,{children:(a,_)=>{var e=dr(),l=x(e);v(l,{children:(i,k)=>{t();var $=n(`Давайте обсудим способы линейного представления набора данных.
    Хранить данные из набора мы будем в линейном списке.`);o(i,$)}});var s=r(l,2);v(s,{children:(i,k)=>{var $=tr(),b=r(x($),2);p(b,{m:"n"});var L=r(b,2);p(L,{m:"x_1, x_2, \\dotsc, x_n"});var I=r(L,2);p(I,{m:"x_k"});var C=r(I,2);p(C,{m:"x_{k-1}"});var M=r(C,2);p(M,{m:"x_{k+1}"});var R=r(M,2);p(R,{m:"1 < k < n"}),t(),o(i,$)}});var h=r(s,2);v(h,{children:(i,k)=>{t();var $=n(`Обращаю внимание на то, что это только логическая упорядоченность.
    Физически узлы могут располагаться как угодно, какие-то узлы даже могут физически отсутствовать,
    главное чтобы логическая связь была такой.`);o(i,$)}});var g=r(h,2);v(g,{children:(i,k)=>{t();var $=n("С элементами линейного списка обычно совершаются следующие операции");o(i,$)}});var P=r(g,2);Z(P,{children:(i,k)=>{var $=sr(),b=x($);u(b,{children:(m,y)=>{t();var d=er(),E=r(x(d));p(E,{m:"k"}),t(),o(m,d)}});var L=r(b,2);u(L,{children:(m,y)=>{t();var d=ar(),E=r(x(d));p(E,{m:"k"}),t(),o(m,d)}});var I=r(L,2);u(I,{children:(m,y)=>{t();var d=nr(),E=r(x(d));p(E,{m:"k"}),t(),o(m,d)}});var C=r(I,2);u(C,{children:(m,y)=>{t();var d=n("Объединение нескольких списков в один");o(m,d)}});var M=r(C,2);u(M,{children:(m,y)=>{t();var d=n("Разбиение одного списка на несколько");o(m,d)}});var R=r(M,2);u(R,{children:(m,y)=>{t();var d=n("Создание копии списка");o(m,d)}}),o(i,$)}}),o(a,e)}});var D=r(w,2);f(D,{children:(a,_)=>{var e=vr(),l=x(e);v(l,{children:(h,g)=>{t();var P=n(`Сделать структуру данных, которая бы эффективно выполняла все эти операции очень сложно.
    На самом деле для большинства задач это и не нужно.`);o(h,P)}});var s=r(l,2);v(s,{children:(h,g)=>{t();var P=_r(),i=r(x(P));p(i,{m:"k=1"});var k=r(i,2);p(k,{m:"k=n"}),t(),o(h,P)}}),o(a,e)}});var F=r(D,2);H(F,{children:(a,_)=>{t();var e=n("Односвязные списки");o(a,e)}});var O=r(F,2);f(O,{children:(a,_)=>{var e=lr(),l=x(e);v(l,{children:(h,g)=>{t();var P=n(`Линейные списки линейными делает логическая упорядоченность.
    Естественно желание превратить логическую упорядоченность в физическую.`);o(h,P)}});var s=r(l,2);v(s,{children:(h,g)=>{t();var P=n(`Назовем каждый элемент линейного списка узлом, и будем в узле, помимо данных,
    хранить ещё и ссылку на следующий узел.
    Таким образом мы сможем физически упорядочить данные в памяти.
    Структура узла выглядит так`);o(h,P)}}),o(a,e)}});var U=r(O,2);Q(U,{code:`struct node:
    node next
    some additional data`});var X=r(U,2);f(X,{children:(a,_)=>{v(a,{children:(e,l)=>{t();var s=ir();t(2),o(e,s)}})}});var j=r(X,2);f(j,{children:(a,_)=>{v(a,{children:(e,l)=>{t();var s=n(`В памяти связные списки могут располагаться как угодно.
    Это значит, что время, затрачиваемое на все операции с узлами, не зависит от размера списка.`);o(e,s)}})}});var q=r(j,2);rr(q,{get src(){return or},children:(a,_)=>{t();var e=n("Связный список в памяти");o(a,e)},$$slots:{default:!0}});var z=r(q,2);H(z,{children:(a,_)=>{t();var e=n("Двусвязные списки");o(a,e)}});var A=r(z,2);f(A,{children:(a,_)=>{v(a,{children:(e,l)=>{t();var s=n("В каждый узел связного списка можно включить не одну. а две связи: на следующий и на предыдущий узлы.");o(e,s)}})}});var B=r(A,2);Q(B,{code:`struct node:
    node previous
    node next
    ...data...`});var G=r(B,2);H(G,{children:(a,_)=>{t();var e=n("Полуторасвязный список");o(a,e)}});var J=r(G,2);f(J,{children:(a,_)=>{v(a,{children:(e,l)=>{t();var s=n("Sparse list");o(e,s)}})}});var K=r(J,2);H(K,{children:(a,_)=>{t();var e=n("XOR список");o(a,e)}});var N=r(K,2);f(N,{children:(a,_)=>{v(a,{})}});var W=r(N,2);H(W,{children:(a,_)=>{t();var e=n("Развёрнутый список");o(a,e)}}),o(V,S)}export{Hr as component};
