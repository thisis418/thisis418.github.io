import"../chunks/CWj6FrbW.js";import"../chunks/69_IOA4Y.js";import{f as i,a as m,b as n,s as r,n as e,t as w}from"../chunks/BWp35gWV.js";import{T as Y}from"../chunks/CR7k0xtG.js";/* empty css                *//* empty css                */import{P as s}from"../chunks/B7flgP-x.js";import{M as o}from"../chunks/BqyEoRxA.js";import{P as D}from"../chunks/DPzc5wQr.js";import{H as Z}from"../chunks/DXKx2xvL.js";import{S as Q}from"../chunks/CBbFRhrb.js";import{S as rr}from"../chunks/LIUKG8Hf.js";import{C as R}from"../chunks/BvAJckrt.js";import{P as or}from"../chunks/BBkyo9uE.js";var er=i(`Пусть у нас есть поток данных (stream) <!>,
        при этом все данные &mdash; элементы какого-то универсума <!>.
        Мы хотим уметь считать, сколько раз элемент <!> встретился в этом потоке к моменту времени <!>, то есть уметь считать значение функции`,1),ar=i("Будем решать задачу для фиксированной временной границы <!>.",1),nr=i("<!> <!> <!>",1),tr=i(`Дан поток данных <!>.
        Можно считать, что мы сделали временной срез при <!>.`,1),_r=i(`Нам нужно оценивать количество вхождений элемента <!> в этот поток <!> &mdash;
        значение функции <!>.`,1),dr=i(`Но ответы на запросы лояльные. Мы даем ответ с точностью <!>,
        при этом позволяем себе ошибаться с вероятностью <!>.
        Формально, <!>,
        где <!> &mdash; предсказанное нами количество вхождений.`,1),sr=i("<!> <!> <!> <!> <!>",1),ir=i(`Пусть <!> &mdash; глубина aka количество хеш-функций,
        и <!> &mdash; размер хеш-пространства.
        Счётчики будем хранить в двумерном массиве <!> высоты <!> и ширины <!>.
        Изначально массив <!> проинициализирован нулями.`,1),lr=i("Создадим еще <!> независимых хеш-функций <!>.",1),vr=i("<!> <!> <!>",1),mr=i(`При получении запроса на добавления в &laquo;счётчик&raquo; элемента <!> мы для каждой строки <!> массива <!> увеличиваем значение
        соответствующего счётчика <!> на <!>.`,1),cr=i(`Для получения оценки количества вхождений элемента <!> в поток данных нам надо посчитать минимум
        по всем счётчикам, включающим в себя этот элемент:`,1),pr=i("<!> <!> <!>",1),$r=i("<b>Доказательство</b> того, что структура работает, и работает хорошо.",1),hr=i("Начнем с доказательства завышенности оценок. Для любой строки <!> и любого элемента <!>",1),fr=i(`Хеш-функции <!> &laquo;хорошие&raquo;, то есть они свои входы равномерно распределяют по
            выходам.`,1),xr=i("Рассмотрим произвольную строку <!>. Ошибка оценки <!> выражается как",1),gr=i("Выберем <!>, тогда мы сможем получить оценку",1),Pr=i(`Но это только для одной строки. А при получении оценки мы выбираем минимум, значит, общая ошибка
            превысит <!>, только тогда, когда переоценку дадут все <!> строк.`,1),ur=i("Учитывая, что <!>, получаем оценку",1),yr=i("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1),br=i("<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>",1);function Ar(V){var U=br(),C=m(U);Y(C,{title:"Count sketch"});var M=r(C,2);D(M,{children:(c,b)=>{var t=nr(),x=m(t);s(x,{children:(d,P)=>{e();var a=er(),l=r(m(a));o(l,{m:"s_1, s_2, s_3, \\dotsc, s_i, \\dotsc"});var v=r(l,2);o(v,{m:"\\UUU"});var $=r(v,2);o($,{m:"x"});var f=r($,2);o(f,{m:"t"}),e(),n(d,a)}});var p=r(x,2);o(p,{display:!0,m:"f_t(x) = \\sum_{i=1}^t \\indic(s_i = x)"});var g=r(p,2);s(g,{children:(d,P)=>{e();var a=ar(),l=r(m(a));o(l,{m:"t"}),e(),n(d,a)}}),n(c,t)}});var B=r(M,2);rr(B,{title:"Задача подсчета",children:(c,b)=>{var t=sr(),x=m(t);s(x,{children:(a,l)=>{e();var v=tr(),$=r(m(v));o($,{m:"S = s_1, s_2, s_3, \\dotsc, s_{n-1}, s_n"});var f=r($,2);o(f,{m:"t = n"}),e(),n(a,v)}});var p=r(x,2);s(p,{children:(a,l)=>{e();var v=_r(),$=r(m(v));o($,{m:"x"});var f=r($,2);o(f,{m:"S"});var y=r(f,2);o(y,{m:"f(x)"}),e(),n(a,v)}});var g=r(p,2);o(g,{display:!0,m:"f(x) = \\sum_{i=1}^n \\indic(s_i = x)"});var d=r(g,2);s(d,{children:(a,l)=>{e();var v=dr(),$=r(m(v));o($,{m:"\\epsilon"});var f=r($,2);o(f,{m:"\\delta"});var y=r(f,2);o(y,{m:"\\prob \\big( \\hat f (x) \\le f(x) + \\epsilon n \\big) \\ge 1 - \\delta"});var k=r(y,2);o(k,{m:"\\hat f (x)"}),e(),n(a,v)}});var P=r(d,2);s(P,{children:(a,l)=>{e();var v=w("А ещё нам нужно уметь обновлять поток — добавлять и удалять элементы.");n(a,v)}}),n(c,t)}});var H=r(B,2);Z(H,{children:(c,b)=>{e();var t=w("Count-Min sketch");n(c,t)}});var N=r(H,2);D(N,{children:(c,b)=>{s(c,{children:(t,x)=>{e();var p=w(`Для решения задачи подсчета можно использовать структуру данных Count-Min sketch.
        Она применима только тогда, когда в поток элементы только добавляются.`);n(t,p)}})}});var T=r(N,2);D(T,{children:(c,b)=>{var t=vr(),x=m(t);s(x,{children:(d,P)=>{e();var a=w("Будем использовать хеширование.");n(d,a)}});var p=r(x,2);s(p,{children:(d,P)=>{e();var a=ir(),l=r(m(a));o(l,{m:"d = \\lceil \\ln 1/\\delta \\rceil"});var v=r(l,2);o(v,{m:"w = \\lceil e/\\epsilon \\rceil"});var $=r(v,2);o($,{m:"c \\in \\NN_0^{d \\times w}"});var f=r($,2);o(f,{m:"d"});var y=r(f,2);o(y,{m:"w"});var k=r(y,2);o(k,{m:"c"}),e(),n(d,a)}});var g=r(p,2);s(g,{children:(d,P)=>{e();var a=lr(),l=r(m(a));o(l,{m:"d"});var v=r(l,2);o(v,{m:"h_1, h_2, \\dotsc, h_d \\colon \\UUU \\surjto \\{1, 2, \\dotsb, w\\}"}),e(),n(d,a)}}),n(c,t)}});var j=r(T,2);R(j,{code:`const real delta = 0.01
const real epsilon = 0.01

const int w = ceil(e / epsilon)
const int d = ceil(ln(1 / delta))

const array h[d]

array[int] c[d][w]`});var z=r(j,2);Q(z,{children:(c,b)=>{e();var t=w("Обновление");n(c,t)}});var A=r(z,2);D(A,{children:(c,b)=>{s(c,{children:(t,x)=>{e();var p=mr(),g=r(m(p));o(g,{m:"x"});var d=r(g,2);o(d,{m:"i"});var P=r(d,2);o(P,{m:"c"});var a=r(P,2);o(a,{m:"h_i(x)"});var l=r(a,2);o(l,{m:"1"}),e(),n(t,p)}})}});var E=r(A,2);R(E,{code:`function add(self, element):
    for i = 0; i < d; i++:
        column = h[i](element)
        c[i][column] += 1`});var F=r(E,2);Q(F,{children:(c,b)=>{e();var t=w("Оценка");n(c,t)}});var G=r(F,2);D(G,{children:(c,b)=>{var t=pr(),x=m(t);s(x,{children:(d,P)=>{e();var a=cr(),l=r(m(a));o(l,{m:"x"}),e(),n(d,a)}});var p=r(x,2);o(p,{display:!0,m:"\\hat f (x) = \\min_{1 \\le i \\le d} c[i][h_i(i)]"});var g=r(p,2);s(g,{children:(d,P)=>{e();var a=w(`Все показатели счетчиков получаются завышенными, ведь у любой хеш-функции неизбежно будут коллизии.
        Когда мы берем минимум, мы выбираем наименее завышенную оценку.`);n(d,a)}}),n(c,t)}});var W=r(G,2);or(W,{children:(c,b)=>{D(c,{children:(t,x)=>{var p=yr(),g=m(p);s(g,{children:(h,q)=>{var _=$r();e(),n(h,_)}});var d=r(g,2);s(d,{children:(h,q)=>{e();var _=hr(),u=r(m(_));o(u,{m:"i"});var S=r(u,2);o(S,{m:"x"}),n(h,_)}});var P=r(d,2);o(P,{display:!0,m:"c[i][h_i(x)] = f(x) + \\sum_{\\substack{y \\neq x \\\\ h_i(y) = h_i(x)}} f(y) \\ge f(x)"});var a=r(P,2);s(a,{children:(h,q)=>{e();var _=fr(),u=r(m(_));o(u,{m:"h_i"}),e(),n(h,_)}});var l=r(a,2);s(l,{children:(h,q)=>{e();var _=xr(),u=r(m(_));o(u,{m:"i"});var S=r(u,2);o(S,{m:"\\Delta_i"}),e(),n(h,_)}});var v=r(l,2);o(v,{display:!0,m:"\\Delta_i = c[i][h_i(x)] - f(x) = \\sum_{\\substack{y \\neq x \\\\ h_i(y) = h_i(x)}} f(y)"});var $=r(v,2);s($,{children:(h,q)=>{e();var _=w("Тогда математическое ожидание ошибки оценки");n(h,_)}});var f=r($,2);o(f,{display:!0,m:"\\expect \\Delta_i = \\sum_{y \\neq x} f(y) \\cdot \\prob \\big( h_i(y) \\neq h_i(x) \\big) = \\frac{n - f(x)}{w} \\le \\frac{n}{w}"});var y=r(f,2);s(y,{children:(h,q)=>{e();var _=w("Применим неравенство Маркова");n(h,_)}});var k=r(y,2);o(k,{display:!0,m:"\\prob(\\Delta_i \\ge a) \\le \\frac{\\expect \\Delta_i}{a} \\le \\frac{n}{wa}"});var I=r(k,2);s(I,{children:(h,q)=>{e();var _=gr(),u=r(m(_));o(u,{m:"a = \\epsilon n"}),e(),n(h,_)}});var J=r(I,2);o(J,{display:!0,m:"\\prob(\\Delta_i \\ge \\epsilon n) \\le \\frac{1}{w \\epsilon} \\le \\frac{1}{e}"});var K=r(J,2);s(K,{children:(h,q)=>{e();var _=Pr(),u=r(m(_));o(u,{m:"\\epsilon n"});var S=r(u,2);o(S,{m:"d"}),e(),n(h,_)}});var L=r(K,2);o(L,{display:!0,m:"\\prob \\Bigg( \\bigunion_{i=1}^d \\{ \\Delta_i \\ge \\epsilon n \\} \\Bigg) \\le \\left( \\frac{1}{e} \\right)^d"});var O=r(L,2);s(O,{children:(h,q)=>{e();var _=ur(),u=r(m(_));o(u,{m:"(1/e)^d \\le e^{-\\ln 1/\\delta} = \\delta"}),e(),n(h,_)}});var X=r(O,2);o(X,{display:!0,m:"\\prob (\\hat f (x) > f(x) + \\epsilon n ) \\le \\delta"}),n(t,p)}})}}),n(V,U)}export{Ar as component};
