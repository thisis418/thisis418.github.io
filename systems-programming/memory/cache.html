<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="icon" href="../../favicon.svg"/>
    <link rel="stylesheet" href="../../fonts/Inter/inter.css"/>
    <link rel="stylesheet" href="../../fonts/JetBrainsMono/jetbrainsmono.css"/>
    <link rel="stylesheet" href="../../variables.css"/>
    <link rel="stylesheet" href="../../global.css"/>
    <link rel="stylesheet" href="../../katex.css"/>

    <link rel="stylesheet" media="print" href="../../print.css">

    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    
		<link href="../../_app/immutable/assets/Link.Cb7NHG_N.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/0._avqqY0J.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/2.DXAScjb8.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Title.DPHn_YVg.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Par.K_845M5t.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/P.B2DWHBcA.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Math.BETNsMrj.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/InternalCode.18_KRbfN.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Code.DJ30TqtG.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Heading.B4n5dO8q.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Subheading.PZ7MELIW.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Codeblock.CTVfIT4f.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/EnumList.CtnWplwG.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/ListItem.BKpMqDLa.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/ExerciseList.Czer9ibd.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Icon.D0g2C4hd.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Exercise.Dg7vTOjD.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.BJRRbOI6.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C4PYaXYV.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D05M-i-Q.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/B1HoO4k0.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DIeogL5L.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D2mTW_Ts.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/zmIfRZ_X.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DB1w4rN-.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DDIRtGou.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.BVG58rn_.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CWj6FrbW.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/52QGYHnB.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/6jNYTp5s.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C66zIgpa.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.BdmhUO9D.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DGFEnqK6.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BsetDOSZ.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DQVJezX5.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C_bKaSJV.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/2.7yTcSGO6.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/131.DxBfBst5.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/69_IOA4Y.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CcX1cm_-.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/ClksMsit.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/B8FEnsbH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/e5qaD0UW.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BsuxlmZu.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CYtJBVty.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/0Rd6UPhr.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BPEYcd7-.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/i9XClpbl.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/VyKLllFE.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D2QCM4hc.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DunPP-_K.js"><!--[--><!--]--><!--[--><!--]--><title>Процессорный кэш</title>
</head>
<body data-sveltekit-preload-data="hover">
<div style="display: contents"><!--[--><!--[--><!----><header class="svelte-10uf3cq"><img src="/favicon.svg" alt="" role="presentation" class="svelte-10uf3cq"/> <nav class="svelte-10uf3cq"><a href="/scenario" class="svelte-1txvory colorless"><!---->Сценарий<!----></a><!----></nav></header><!----> <main><!--[--><!----><article class="svelte-1cvbhgs"><!----><div class="title svelte-uw1xhm"><!--[!--><h1 class="svelte-uw1xhm">Процессорный кэш</h1><!--]--></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Процессор работает на частотах в несколько гигагерц, а оперативная память — на частотах в сотни мегагерц.
    Это создает огромный разрыв в скорости.
    Если бы процессор каждый раз ждал данные из оперативной памяти, он простаивал бы десятки, а то и сотни тактов.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Кэш процессора — это чрезвычайно быстрая, но небольшая память на кристалле,
    служащая буфером между ядром и оперативной памятью.
    Для максимальной эффективности он организован в виде иерархии из нескольких уровней,
    где уровни, расположенные ближе к ядру, обладают наименьшей латентностью и скоростью доступа, но и меньшим объемом,
    в то время как более удаленные уровни больше по размеру, но немного медленнее.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Эта система позволяет хранить копии наиболее востребованных данных и инструкций,
    обеспечивая процессору практически мгновенный доступ к ним,
    что кардинально повышает общую производительность системы.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Скорость работы памяти и кэшей измеряется по двум разным величинам.
    Это <b>latency</b> — задержка между моментом начала чтения или записи и моментом поступления данных
    и <b>bandwidth (пропускная способность)</b> — число операций в памяти,
    которые могут быть обработаны за единицу времени.<!----></p><!----></div><!----> <h1 class="svelte-mdj34r"><!---->Иерархия и организация кешей<!----></h1><!----> <h1 class="svelte-1dact7k"><!---->Иерархия<!----></h1><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Сразу скажу, что у каждого вида кэша может быть несколько экземпляров.<!----></p><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L1 — кеш первого уровня.</b><!----></p><!----> <p class="svelte-cr0fdf"><!---->Самый быстрый кэш, доступ к нему происходит за 1–3 такта.
    Находится непосредственно в каждом ядре.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Обычно разделён на два отдельных кэша:
    кэш инструкций (L1i), хранящий инструкции процессора, и кэш данных (L1d), хранящий данные для операций.
    Такое разделение позволяет одновременно читать инструкцию и данные к ней.
    Также такое разделение позволяет оптимизировать структуру под разные шаблоны доступа.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Обычно занимает объём 32–64 КБ на каждый экземпляр,
    при этом экземпляры кэша L1d чаще всего чуть больше экземпляров кэш L1i.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L2 — кеш второго уровня.</b><!----></p><!----> <p class="svelte-cr0fdf"><!---->Медленнее L1, доступ к нему происходит за 10–20 тактов.
    Экземпляр такого кеша быть для каждого ядра свой, а может быть общий для пары ядер.
    Находится часто не прям в ядре, а на той же части кристала, что и ядро.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Унифицированный кэш, то есть хранит одновременно и инструкции, и данные.
    Служит буфером между кэшами L1 и L3.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Обычно экземпляр занимает объём 256 КБ – 1 МБ на обычных CPU и 1–2 МБ на современных мощных CPU.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L3 — кеш третьего уровня.</b><!----></p><!----> <p class="svelte-cr0fdf"><!---->Значительно медленнее L2, доступ к нему происходит за 30–50 тактов.
    Располагается на кристале процессора, но является общим для всех ядер.
    Чаще всего имеет всего один экземпляр.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Унифицированный кэш, имеющий сложный механизм для обеспечения согласованности данных между кэшами разных ядер.
    На нём работает самый эффективный префетч, который предсказывает,
    к каким данным из оперативной памяти будет в дальнейшем обращаться процессор.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Обычно экземпляр занимает объём 4–8 МБ на обычных CPU и 8–32 МБ на современных мощных CPU.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Вся иерархия кэшей работает примерно по следующему принципу.
    Сначала ядро процессора ищет данные или инструкцию в кэше L1.
    Если в кэше L1 нет нужной информации, то есть если случился промах в кэше L1, то ядро обращается к кэшу L2.
    Если данных или инструкции нет и в кэше L2, то ядро обращается в L3.
    И только в случае промаха во всех уровнях происходит обращение к оперативной памяти.
    При этом найденные данные поднимаются наверх по иерархии.<!----></p><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Посмотреть на количество экземпляров кэшей и их размер на вашем компьютере (в linux) можно с помощью команды<!----></p><!----></div><!----> <div class="codeblock svelte-in28rj"><div class="overflow-box svelte-in28rj"><code class="language-shell svelte-127l4oe"><!---->lscpu <span class="operator">|</span> <span class="function">grep</span> <span class="string">&apos;cache&apos;</span><!----></code><!----></div></div><!----> <h1 class="svelte-1dact7k"><!---->Организация кэшей<!----></h1><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Линия кэша (cache line)</b> — минимальная единица обмена данными между уровнями кэша и оперативной памятью.
    Размер линии кэша у большинства процессоров составляет 64 байта.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Когда процессор читает из памяти один байт, в кэш загружается вся линия в 64 байта, содержащая этот байт.
    Таким образом обеспечивается локальность данных в кэше, а сама идея такой работы пошла
    из <b>принципа локальности</b>: если программа обратилась к одному байту,
    то высока вероятность, что вскоре она обратится и к соседним.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Кэши организованы по принципу ассоциативности, который определяет гибкость размещения данных в кэше.
    Существует три основных типа ассоциативности:<!----></p><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Прямая ассоциативность</b> или прямо отображаемый кэш (direct-mapped cache).<!----></p><!----> <p class="svelte-cr0fdf"><!---->Каждая линия из памяти может быть помещена только в одно конкретное место в кэше.
    Можно мысленно разделить кэш на ячейки, и тогда по адресу ячейки памяти однозначно определяется номер ячейки кэша,
    куда будет помещены данные из той ячейки памяти.<!----></p><!----> <p class="svelte-cr0fdf"><!---->У этого типа ассоциативности есть одна серьезная проблема: конфликты.
    Если две часто используемые переменные претендуют на одно и то же место в кэше,
    то они будут постоянно вытеснять друг друга, вызывая лавину промахов в кэше, даже если он в целом пуст.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Полная ассоциативность</b> (fully associative cache).<!----></p><!----> <p class="svelte-cr0fdf"><!---->Каждая линия из памяти может быть помещена в любое место кэша.<!----></p><!----> <p class="svelte-cr0fdf"><!---->С точки зрения конфликтов минимизации конфликтов такой тип ассоциативности идеален.
    К сожалению, поиск в таком кэше будет занимать много времени, ведь нам нужно будет проверить все линии кэша.
    Для больших кэшей такой тип ассоциативности неприменим.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Частично-ассоциативный кэш</b> (set associative cache).<!----></p><!----> <p class="svelte-cr0fdf"><!---->Кэш делится на бакеты (sets). Каждый бакет содержит фиксированное количество каналов (ways).
    Каждая линия из памяти может быть помещена в любой канал одного конкретного бакета.
    Номер бакета определяется по адресу ячейки памяти.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Здесь убираются недостатки предыдущих типов ассоциативности.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Именно такой тип ассоциативности используется в современных процессорах.
    Кэш L1 является 8-канальным или полностью ассоциативным.
    Кэш L2 может иметь 8 или 16 каналов.
    Кэш L3 может иметь от 12 до 32 каналов.<!----></p><!----><!----></div><!----> <h1 class="svelte-mdj34r"><!---->Пропускная способность<!----></h1><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Все слои кэша процессора размещены на том же чипе, что и сам процессор,
    поэтому пропускная способность, задержка и все остальные характеристики масштабируются вместе с тактовой частотой.
    Оперативная память, в свою очередь, работает на своей фиксированной частоте,
    и её характеристики остаются неизменными.<!----></p><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->К кэшу, равно как и к памяти, есть два разных режима доступа: чтение и запись.
    Режимы работают по-разному и имеют разное влияние на эффективность программы.<!----></p><!----> <p class="svelte-cr0fdf"><!---->В моем примере программа, прибавляющая ко всем элементам массива <!--[!--><span class="math"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><!----></span><!--]--><!---->,
    использует оба режима доступа: сначала читает из памяти значение элемента,
    а потом записывает в память результат инкремента.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Давайте разграничим режимы доступа к памяти<!----></p><!----><!----></div><!----> <div class="codeblock svelte-in28rj"><div class="overflow-box svelte-in28rj"><code class="language-pseudocode svelte-127l4oe"><!----><span class="keyword">for</span> <span class="punctuation">(</span><span class="builtin">int</span> i <span class="operator">=</span> <span class="number">0</span><span class="punctuation">;</span> i <span class="operator">&lt;</span> n<span class="punctuation">;</span> i<span class="operator">+</span><span class="operator">+</span><span class="punctuation">)</span>
    s <span class="operator">+=</span> a<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">;</span><!----></code><!----></div></div><!----> <div class="codeblock svelte-in28rj"><div class="overflow-box svelte-in28rj"><code class="language-pseudocode svelte-127l4oe"><!----><span class="keyword">for</span> <span class="punctuation">(</span><span class="builtin">int</span> i <span class="operator">=</span> <span class="number">0</span><span class="punctuation">;</span> i <span class="operator">&lt;</span> n<span class="punctuation">;</span> i<span class="operator">+</span><span class="operator">+</span><span class="punctuation">)</span>
    a<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation">;</span><!----></code><!----></div></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><!---->Обе программы отлично векторизуются современными компиляторами.
    Более того, программа с чистой записью может полностью превратиться в вызов <span class="code svelte-1kfz46x"><code class="language-cpp svelte-127l4oe"><!---->memset<!----></code><!----></span><!---->,
    что минимизирует нагрузку на процессор в случае, если массив выходит за границы кэша L1.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Но однонаправленный и двунаправленный доступ к памяти работают по-разному.
    Понятно, что для каждого уровня иерархии памяти на производительность влияют разные вещи.
    Разберем подробнее, кто и как на что влияет.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L1.</b> Кэш L1 физически находится в ядре процессора, работает на его частоте и имеет широкие двунаправленные шины.
    Ограничения здесь возникают в самом конвейере исполнения.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Современные процессоры имеют 2–4 порта LSU, каждый порт может обрабатывать 1 операцию за такт.
    В случае с одновременной работы в обоих режимах каждая операция store зависит от операций load,
    поэтому высокой эффективность здесь добиться не получится.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Кэш L1 разделён на 6–8 банков — независимых модулей памяти,
    которые могут параллельно обслуживать операции доступа. Один банк может обслуживать 1 операцию за такт.
    Даже если в процессоре есть свободные порты LSU, они могут и не работать параллельно,
    если оба обращения идут в один банк памяти кэша L1.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L2.</b> Кэш L2 находится за пределами ядра, но на том же кристале.
    Шины всё еще достаточно широкие и двунаправленные.
    Расстояние от кэша L2 до кэша L1 и до ядра приличное, но не очень большое.<!----></p><!----> <p class="svelte-cr0fdf"><!---->В одном режиме работы заметной разницы между кэшем L2 и кэшем L1 практически нет:
    префетчер прекрасно обнаруживает шаблон доступа и подгружает все данные в кеш.<!----></p><!----> <p class="svelte-cr0fdf"><!---->В смешанном режиме префетчер не может эффективно работать со смешанной нагрузкой,
    потому что шаблон доступа к памяти становится сложнее, когда чередуются операции чтения и записи.
    Также кэш L2 имеет ограниченные буферы для отслеживания шаблонов,
    поэтому смешанный режим в <!--[!--><span class="math"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><!----></span><!--]--><!----> раза быстрее заполнит эти буферы.<!----></p><!----> <p class="svelte-cr0fdf"><!---->Промахи в кеше L1, конечно, тоже играют свою роль,
    но их вклад незначительный из-за физической близости кешей L1 и L2.<!----></p><!----><!----></div><!----> <div class="par svelte-q2zea3"><p class="svelte-cr0fdf"><b>Кэш L3.</b> Кэш L3 общий для всех ядер.
    Используется межядерная шина с ячеистой и/или кольцевой топологией.
    Это создает дополнительные накладные расходы на поддержание когерентности данных между ядрами.<!----></p><!----> <p class="svelte-cr0fdf"><!---->При операции записи в L3 требуется инвалидировать соответствующие строки в кеши L1 и L2 других ядер,
    что порождает дополнительные транзакции по межядерной шине.
    Получается, что операция записи требует несколько транзакций
    (минимум invalidation request, acknowledge, write data).<!----></p><!----> <p class="svelte-cr0fdf"><!---->Ограниченная пропускная способность межядерной шины и арбитраж доступа между транзакциями чтения и записи
    создают конкуренцию, особенно при многопоточном доступе к одним данным.<!----></p><!----><!----></div><!----><!----><!----></article> <div class="svelte-1cvbhgs"></div><!----><!--]--><!----></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_48jyze = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../_app/immutable/entry/start.BJRRbOI6.js"),
						import("../../_app/immutable/entry/app.BVG58rn_.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2, 131],
							data: [null,null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
</body>
</html>
